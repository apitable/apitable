import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http';
import { Configuration} from '../configuration'
import { Observable, of, from } from '../rxjsStub';
import {mergeMap, map} from  '../rxjsStub';
import { ActionExecutionVO } from '../models/ActionExecutionVO';
import { ActionSimpleVO } from '../models/ActionSimpleVO';
import { ActionTypeCreateRO } from '../models/ActionTypeCreateRO';
import { ActionTypeEditRO } from '../models/ActionTypeEditRO';
import { ActionVO } from '../models/ActionVO';
import { ActiveSheetsOpRo } from '../models/ActiveSheetsOpRo';
import { ActivityStatusRo } from '../models/ActivityStatusRo';
import { AddNodeRoleRo } from '../models/AddNodeRoleRo';
import { AddRoleMemberRo } from '../models/AddRoleMemberRo';
import { AddSpaceRoleRo } from '../models/AddSpaceRoleRo';
import { AgentCreateRO } from '../models/AgentCreateRO';
import { AgentUpdateParams } from '../models/AgentUpdateParams';
import { AgentVO } from '../models/AgentVO';
import { Ai } from '../models/Ai';
import { AiInfoVO } from '../models/AiInfoVO';
import { AiSetting } from '../models/AiSetting';
import { AiTrainingDataSource } from '../models/AiTrainingDataSource';
import { AiUpdateParams } from '../models/AiUpdateParams';
import { AlbumContentVo } from '../models/AlbumContentVo';
import { AlbumGroupVo } from '../models/AlbumGroupVo';
import { AlbumVo } from '../models/AlbumVo';
import { AppInfo } from '../models/AppInfo';
import { AppInstance } from '../models/AppInstance';
import { ApplicationContext } from '../models/ApplicationContext';
import { ApplicationContextClassLoader } from '../models/ApplicationContextClassLoader';
import { ApplicationContextClassLoaderParent } from '../models/ApplicationContextClassLoaderParent';
import { AssetUploadCertificateRO } from '../models/AssetUploadCertificateRO';
import { AssetUploadCertificateVO } from '../models/AssetUploadCertificateVO';
import { AssetUploadNotifyRO } from '../models/AssetUploadNotifyRO';
import { AssetUploadResult } from '../models/AssetUploadResult';
import { AssetUrlSignatureRo } from '../models/AssetUrlSignatureRo';
import { AssetUrlSignatureVo } from '../models/AssetUrlSignatureVo';
import { AssetsAuditOpRo } from '../models/AssetsAuditOpRo';
import { AssetsAuditRo } from '../models/AssetsAuditRo';
import { AssetsAuditVo } from '../models/AssetsAuditVo';
import { AttachOfficePreviewRo } from '../models/AttachOfficePreviewRo';
import { AttachOpRo } from '../models/AttachOpRo';
import { AttachUrlOpRo } from '../models/AttachUrlOpRo';
import { AuditContent } from '../models/AuditContent';
import { AutomationApiRobotRo } from '../models/AutomationApiRobotRo';
import { AutomationApiTriggerCreateRo } from '../models/AutomationApiTriggerCreateRo';
import { AutomationApiTriggerRo } from '../models/AutomationApiTriggerRo';
import { AutomationPropertyRO } from '../models/AutomationPropertyRO';
import { AutomationPropertyVO } from '../models/AutomationPropertyVO';
import { AutomationServiceCreateRO } from '../models/AutomationServiceCreateRO';
import { AutomationServiceEditRO } from '../models/AutomationServiceEditRO';
import { AutomationSimpleVO } from '../models/AutomationSimpleVO';
import { AutomationTaskSimpleVO } from '../models/AutomationTaskSimpleVO';
import { AutomationTriggerCreateVo } from '../models/AutomationTriggerCreateVo';
import { AutomationVO } from '../models/AutomationVO';
import { Banner } from '../models/Banner';
import { BatchDeleteNodeRoleRo } from '../models/BatchDeleteNodeRoleRo';
import { BatchFieldRoleDeleteRo } from '../models/BatchFieldRoleDeleteRo';
import { BatchFieldRoleEditRo } from '../models/BatchFieldRoleEditRo';
import { BatchModifyNodeRoleRo } from '../models/BatchModifyNodeRoleRo';
import { BillingDetail } from '../models/BillingDetail';
import { BillingInfo } from '../models/BillingInfo';
import { BillingSessionVO } from '../models/BillingSessionVO';
import { ChatbotEnableRo } from '../models/ChatbotEnableRo';
import { CheckUserEmailRo } from '../models/CheckUserEmailRo';
import { CheckoutCreation } from '../models/CheckoutCreation';
import { CheckoutCreationVO } from '../models/CheckoutCreationVO';
import { ClientInfoVO } from '../models/ClientInfoVO';
import { CodeValidateRo } from '../models/CodeValidateRo';
import { ConfigDatasheetRo } from '../models/ConfigDatasheetRo';
import { ConfigRo } from '../models/ConfigRo';
import { ContentCensorReportRo } from '../models/ContentCensorReportRo';
import { ContentCensorResultVo } from '../models/ContentCensorResultVo';
import { Control } from '../models/Control';
import { CreateActionRO } from '../models/CreateActionRO';
import { CreateAppInstance } from '../models/CreateAppInstance';
import { CreateDatasheetRo } from '../models/CreateDatasheetRo';
import { CreateDatasheetVo } from '../models/CreateDatasheetVo';
import { CreateOrderRo } from '../models/CreateOrderRo';
import { CreateRoleRo } from '../models/CreateRoleRo';
import { CreateSpaceResultVo } from '../models/CreateSpaceResultVo';
import { CreateTeamRo } from '../models/CreateTeamRo';
import { CreateTemplateRo } from '../models/CreateTemplateRo';
import { CreateTriggerRO } from '../models/CreateTriggerRO';
import { CreateUnitTeamRo } from '../models/CreateUnitTeamRo';
import { CreatedMemberInfoVo } from '../models/CreatedMemberInfoVo';
import { CreditUsage } from '../models/CreditUsage';
import { CustomerInvoice } from '../models/CustomerInvoice';
import { CustomerInvoices } from '../models/CustomerInvoices';
import { DataSource } from '../models/DataSource';
import { DataSourceParam } from '../models/DataSourceParam';
import { DatasheetPermissionView } from '../models/DatasheetPermissionView';
import { DeleteBatchMemberRo } from '../models/DeleteBatchMemberRo';
import { DeleteMemberRo } from '../models/DeleteMemberRo';
import { DeleteNodeRoleRo } from '../models/DeleteNodeRoleRo';
import { DeleteRoleMemberRo } from '../models/DeleteRoleMemberRo';
import { DeptLeader } from '../models/DeptLeader';
import { DeptOrder } from '../models/DeptOrder';
import { DevelopUserVo } from '../models/DevelopUserVo';
import { DeveloperInfoVo } from '../models/DeveloperInfoVo';
import { DeveloperVo } from '../models/DeveloperVo';
import { DingTalkAgentBindSpaceDTO } from '../models/DingTalkAgentBindSpaceDTO';
import { DingTalkBindOpRo } from '../models/DingTalkBindOpRo';
import { DingTalkBindSpaceVo } from '../models/DingTalkBindSpaceVo';
import { DingTalkDaTemplateCreateRo } from '../models/DingTalkDaTemplateCreateRo';
import { DingTalkDaTemplateDeleteRo } from '../models/DingTalkDaTemplateDeleteRo';
import { DingTalkDaTemplateUpdateRo } from '../models/DingTalkDaTemplateUpdateRo';
import { DingTalkDdConfigRo } from '../models/DingTalkDdConfigRo';
import { DingTalkDdConfigVo } from '../models/DingTalkDdConfigVo';
import { DingTalkInternalSkuPageRo } from '../models/DingTalkInternalSkuPageRo';
import { DingTalkIsvAdminUserLoginVo } from '../models/DingTalkIsvAdminUserLoginVo';
import { DingTalkIsvAminUserLoginRo } from '../models/DingTalkIsvAminUserLoginRo';
import { DingTalkIsvUserLoginRo } from '../models/DingTalkIsvUserLoginRo';
import { DingTalkIsvUserLoginVo } from '../models/DingTalkIsvUserLoginVo';
import { DingTalkTenantMainAdminChangeRo } from '../models/DingTalkTenantMainAdminChangeRo';
import { DingTalkUserDetail } from '../models/DingTalkUserDetail';
import { DingTalkUserLoginRo } from '../models/DingTalkUserLoginRo';
import { DingTalkUserLoginVo } from '../models/DingTalkUserLoginVo';
import { DryRunOrderArgs } from '../models/DryRunOrderArgs';
import { EmailCodeValidateRo } from '../models/EmailCodeValidateRo';
import { EmailOpRo } from '../models/EmailOpRo';
import { Environment } from '../models/Environment';
import { EventVO } from '../models/EventVO';
import { FavoriteNodeInfo } from '../models/FavoriteNodeInfo';
import { FeatureVo } from '../models/FeatureVo';
import { Feedback } from '../models/Feedback';
import { FeedbackCreateParam } from '../models/FeedbackCreateParam';
import { FeedbackPagination } from '../models/FeedbackPagination';
import { FeedbackUpdateParam } from '../models/FeedbackUpdateParam';
import { FeedbackVO } from '../models/FeedbackVO';
import { FeishuAppConfigRo } from '../models/FeishuAppConfigRo';
import { FeishuAppEventConfigRo } from '../models/FeishuAppEventConfigRo';
import { FeishuTenantDetailVO } from '../models/FeishuTenantDetailVO';
import { FeishuTenantMainAdminChangeRo } from '../models/FeishuTenantMainAdminChangeRo';
import { Field } from '../models/Field';
import { FieldCollaboratorVO } from '../models/FieldCollaboratorVO';
import { FieldControlProp } from '../models/FieldControlProp';
import { FieldPermission } from '../models/FieldPermission';
import { FieldPermissionInfo } from '../models/FieldPermissionInfo';
import { FieldPermissionView } from '../models/FieldPermissionView';
import { FieldRole } from '../models/FieldRole';
import { FieldRoleCreateRo } from '../models/FieldRoleCreateRo';
import { FieldRoleDeleteRo } from '../models/FieldRoleDeleteRo';
import { FieldRoleEditRo } from '../models/FieldRoleEditRo';
import { FieldRoleMemberVo } from '../models/FieldRoleMemberVo';
import { FieldRoleSetting } from '../models/FieldRoleSetting';
import { GlobalWidgetInfo } from '../models/GlobalWidgetInfo';
import { GlobalWidgetListRo } from '../models/GlobalWidgetListRo';
import { GmApplyFeatureRo } from '../models/GmApplyFeatureRo';
import { GmLabFeatureVo } from '../models/GmLabFeatureVo';
import { GmLabsFeatureCreatorRo } from '../models/GmLabsFeatureCreatorRo';
import { HotsTransformIpRo } from '../models/HotsTransformIpRo';
import { HqAddUserRo } from '../models/HqAddUserRo';
import { HqAddUserVo } from '../models/HqAddUserVo';
import { IdaasAuthCallbackRo } from '../models/IdaasAuthCallbackRo';
import { IdaasAuthLoginVo } from '../models/IdaasAuthLoginVo';
import { IdaasBindInfoVo } from '../models/IdaasBindInfoVo';
import { ImportExcelOpRo } from '../models/ImportExcelOpRo';
import { InstanceConfig } from '../models/InstanceConfig';
import { InstanceConfigProfile } from '../models/InstanceConfigProfile';
import { IntegralDeductRo } from '../models/IntegralDeductRo';
import { IntegralRecordVO } from '../models/IntegralRecordVO';
import { Intent } from '../models/Intent';
import { InternalCreditUsageVo } from '../models/InternalCreditUsageVo';
import { InternalPermissionRo } from '../models/InternalPermissionRo';
import { InternalSpaceApiRateLimitVo } from '../models/InternalSpaceApiRateLimitVo';
import { InternalSpaceApiUsageVo } from '../models/InternalSpaceApiUsageVo';
import { InternalSpaceAutomationRunMessageV0 } from '../models/InternalSpaceAutomationRunMessageV0';
import { InternalSpaceCapacityVo } from '../models/InternalSpaceCapacityVo';
import { InternalSpaceInfoVo } from '../models/InternalSpaceInfoVo';
import { InternalSpaceSubscriptionVo } from '../models/InternalSpaceSubscriptionVo';
import { InternalSpaceUsageVo } from '../models/InternalSpaceUsageVo';
import { InviteCodeRewardRo } from '../models/InviteCodeRewardRo';
import { InviteInfoVo } from '../models/InviteInfoVo';
import { InviteMemberAgainRo } from '../models/InviteMemberAgainRo';
import { InviteMemberRo } from '../models/InviteMemberRo';
import { InviteRo } from '../models/InviteRo';
import { InviteUserInfo } from '../models/InviteUserInfo';
import { InviteValidRo } from '../models/InviteValidRo';
import { JSONConfig } from '../models/JSONConfig';
import { JSONObject } from '../models/JSONObject';
import { LabsFeatureVo } from '../models/LabsFeatureVo';
import { LoadSearchDTO } from '../models/LoadSearchDTO';
import { LoginResultVO } from '../models/LoginResultVO';
import { LoginRo } from '../models/LoginRo';
import { LogoutVO } from '../models/LogoutVO';
import { MainAdminInfoVo } from '../models/MainAdminInfoVo';
import { MarkNodeMoveRo } from '../models/MarkNodeMoveRo';
import { MarketplaceSpaceAppVo } from '../models/MarketplaceSpaceAppVo';
import { MemberBriefInfoVo } from '../models/MemberBriefInfoVo';
import { MemberInfo } from '../models/MemberInfo';
import { MemberInfoVo } from '../models/MemberInfoVo';
import { MemberMobile } from '../models/MemberMobile';
import { MemberPageVo } from '../models/MemberPageVo';
import { MemberRo } from '../models/MemberRo';
import { MemberTeamPathInfo } from '../models/MemberTeamPathInfo';
import { MemberUnitsVo } from '../models/MemberUnitsVo';
import { Message } from '../models/Message';
import { MessageCreditLimit } from '../models/MessageCreditLimit';
import { MessageCreditUsageVO } from '../models/MessageCreditUsageVO';
import { MessageItem } from '../models/MessageItem';
import { Meta } from '../models/Meta';
import { MigrationResourcesRo } from '../models/MigrationResourcesRo';
import { ModifyNodeRoleRo } from '../models/ModifyNodeRoleRo';
import { MpSignatureRo } from '../models/MpSignatureRo';
import { Node } from '../models/Node';
import { NodeBundleOpRo } from '../models/NodeBundleOpRo';
import { NodeCollaboratorVO } from '../models/NodeCollaboratorVO';
import { NodeCollaboratorsVo } from '../models/NodeCollaboratorsVo';
import { NodeCopyOpRo } from '../models/NodeCopyOpRo';
import { NodeDescOpRo } from '../models/NodeDescOpRo';
import { NodeExtra } from '../models/NodeExtra';
import { NodeInfo } from '../models/NodeInfo';
import { NodeInfoTreeVo } from '../models/NodeInfoTreeVo';
import { NodeInfoVo } from '../models/NodeInfoVo';
import { NodeInfoWindowVo } from '../models/NodeInfoWindowVo';
import { NodeMoveOpRo } from '../models/NodeMoveOpRo';
import { NodeOpRo } from '../models/NodeOpRo';
import { NodePathVo } from '../models/NodePathVo';
import { NodePermissionView } from '../models/NodePermissionView';
import { NodeRecoverRo } from '../models/NodeRecoverRo';
import { NodeRelRo } from '../models/NodeRelRo';
import { NodeRoleMemberVo } from '../models/NodeRoleMemberVo';
import { NodeRoleUnit } from '../models/NodeRoleUnit';
import { NodeSearchResult } from '../models/NodeSearchResult';
import { NodeShareInfoVO } from '../models/NodeShareInfoVO';
import { NodeShareSettingInfoVO } from '../models/NodeShareSettingInfoVO';
import { NodeShareSettingPropsVO } from '../models/NodeShareSettingPropsVO';
import { NodeShareTree } from '../models/NodeShareTree';
import { NodeSimpleVO } from '../models/NodeSimpleVO';
import { NodeUpdateOpRo } from '../models/NodeUpdateOpRo';
import { NotificationCreateRo } from '../models/NotificationCreateRo';
import { NotificationDetailVo } from '../models/NotificationDetailVo';
import { NotificationListRo } from '../models/NotificationListRo';
import { NotificationPageRo } from '../models/NotificationPageRo';
import { NotificationReadRo } from '../models/NotificationReadRo';
import { NotificationRevokeRo } from '../models/NotificationRevokeRo';
import { NotificationStatisticsVo } from '../models/NotificationStatisticsVo';
import { NotifyBody } from '../models/NotifyBody';
import { OneAccessCopyInfoRo } from '../models/OneAccessCopyInfoRo';
import { OpAssetRo } from '../models/OpAssetRo';
import { Operator } from '../models/Operator';
import { OrderDetailVo } from '../models/OrderDetailVo';
import { OrderItem } from '../models/OrderItem';
import { OrderPaymentVo } from '../models/OrderPaymentVo';
import { OrderPreview } from '../models/OrderPreview';
import { OrgUnitRo } from '../models/OrgUnitRo';
import { OrganizationUnitVo } from '../models/OrganizationUnitVo';
import { Page } from '../models/Page';
import { PageInfoAppInfo } from '../models/PageInfoAppInfo';
import { PageInfoAppInstance } from '../models/PageInfoAppInstance';
import { PageInfoAssetsAuditVo } from '../models/PageInfoAssetsAuditVo';
import { PageInfoContentCensorResultVo } from '../models/PageInfoContentCensorResultVo';
import { PageInfoFieldRoleMemberVo } from '../models/PageInfoFieldRoleMemberVo';
import { PageInfoIntegralRecordVO } from '../models/PageInfoIntegralRecordVO';
import { PageInfoMemberPageVo } from '../models/PageInfoMemberPageVo';
import { PageInfoNodeRoleMemberVo } from '../models/PageInfoNodeRoleMemberVo';
import { PageInfoQrCodePageVo } from '../models/PageInfoQrCodePageVo';
import { PageInfoRoleMemberVo } from '../models/PageInfoRoleMemberVo';
import { PageInfoSpaceAuditPageVO } from '../models/PageInfoSpaceAuditPageVO';
import { PageInfoSpaceCapacityPageVO } from '../models/PageInfoSpaceCapacityPageVO';
import { PageInfoSpaceRoleVo } from '../models/PageInfoSpaceRoleVo';
import { PageInfoUnitMemberInfoVo } from '../models/PageInfoUnitMemberInfoVo';
import { PageInfoUnitRoleInfoVo } from '../models/PageInfoUnitRoleInfoVo';
import { PageInfoUnitTeamInfoVo } from '../models/PageInfoUnitTeamInfoVo';
import { PageInfoVCodeActivityPageVo } from '../models/PageInfoVCodeActivityPageVo';
import { PageInfoVCodeCouponPageVo } from '../models/PageInfoVCodeCouponPageVo';
import { PageInfoVCodePageVo } from '../models/PageInfoVCodePageVo';
import { PageLong } from '../models/PageLong';
import { PageRoleBaseInfoDto } from '../models/PageRoleBaseInfoDto';
import { PageVoid } from '../models/PageVoid';
import { PaginationMessage } from '../models/PaginationMessage';
import { ParseErrorRecordVO } from '../models/ParseErrorRecordVO';
import { PausedUserHistoryDto } from '../models/PausedUserHistoryDto';
import { PausedUserHistoryRo } from '../models/PausedUserHistoryRo';
import { PayOrderRo } from '../models/PayOrderRo';
import { PaymentMethodDetail } from '../models/PaymentMethodDetail';
import { PaymentOrderStatusVo } from '../models/PaymentOrderStatusVo';
import { PlayerBaseVo } from '../models/PlayerBaseVo';
import { PriceVO } from '../models/PriceVO';
import { ProductPriceVo } from '../models/ProductPriceVo';
import { ProductVO } from '../models/ProductVO';
import { QrCodeBaseInfo } from '../models/QrCodeBaseInfo';
import { QrCodePageVo } from '../models/QrCodePageVo';
import { QrCodeStatisticsVo } from '../models/QrCodeStatisticsVo';
import { QrCodeVo } from '../models/QrCodeVo';
import { QueryUserInfoRo } from '../models/QueryUserInfoRo';
import { QuoteTemplateRo } from '../models/QuoteTemplateRo';
import { RecommendVo } from '../models/RecommendVo';
import { RedirectView } from '../models/RedirectView';
import { RedirectViewServletContext } from '../models/RedirectViewServletContext';
import { RedirectViewServletContextFilterRegistrationsValue } from '../models/RedirectViewServletContextFilterRegistrationsValue';
import { RedirectViewServletContextJspConfigDescriptor } from '../models/RedirectViewServletContextJspConfigDescriptor';
import { RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner } from '../models/RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner';
import { RedirectViewServletContextJspConfigDescriptorTaglibsInner } from '../models/RedirectViewServletContextJspConfigDescriptorTaglibsInner';
import { RedirectViewServletContextServletRegistrationsValue } from '../models/RedirectViewServletContextServletRegistrationsValue';
import { RedirectViewServletContextSessionCookieConfig } from '../models/RedirectViewServletContextSessionCookieConfig';
import { RefreshApiKeyRo } from '../models/RefreshApiKeyRo';
import { RegisterRO } from '../models/RegisterRO';
import { RemindExtraRo } from '../models/RemindExtraRo';
import { RemindMemberRo } from '../models/RemindMemberRo';
import { RemindUnitRecRo } from '../models/RemindUnitRecRo';
import { RemindUnitsNoPermissionRo } from '../models/RemindUnitsNoPermissionRo';
import { ResponseData } from '../models/ResponseData';
import { ResponseDataAiInfoVO } from '../models/ResponseDataAiInfoVO';
import { ResponseDataAlbumContentVo } from '../models/ResponseDataAlbumContentVo';
import { ResponseDataAppInstance } from '../models/ResponseDataAppInstance';
import { ResponseDataAssetUploadResult } from '../models/ResponseDataAssetUploadResult';
import { ResponseDataAutomationTriggerCreateVo } from '../models/ResponseDataAutomationTriggerCreateVo';
import { ResponseDataAutomationVO } from '../models/ResponseDataAutomationVO';
import { ResponseDataBillingInfo } from '../models/ResponseDataBillingInfo';
import { ResponseDataBillingSessionVO } from '../models/ResponseDataBillingSessionVO';
import { ResponseDataBoolean } from '../models/ResponseDataBoolean';
import { ResponseDataCreateDatasheetVo } from '../models/ResponseDataCreateDatasheetVo';
import { ResponseDataCreateSpaceResultVo } from '../models/ResponseDataCreateSpaceResultVo';
import { ResponseDataCreditUsages } from '../models/ResponseDataCreditUsages';
import { ResponseDataCustomerInvoices } from '../models/ResponseDataCustomerInvoices';
import { ResponseDataDatasheetPermissionView } from '../models/ResponseDataDatasheetPermissionView';
import { ResponseDataDevelopUserVo } from '../models/ResponseDataDevelopUserVo';
import { ResponseDataDeveloperInfoVo } from '../models/ResponseDataDeveloperInfoVo';
import { ResponseDataDeveloperVo } from '../models/ResponseDataDeveloperVo';
import { ResponseDataDingTalkBindSpaceVo } from '../models/ResponseDataDingTalkBindSpaceVo';
import { ResponseDataDingTalkDdConfigVo } from '../models/ResponseDataDingTalkDdConfigVo';
import { ResponseDataDingTalkIsvAdminUserLoginVo } from '../models/ResponseDataDingTalkIsvAdminUserLoginVo';
import { ResponseDataDingTalkIsvUserLoginVo } from '../models/ResponseDataDingTalkIsvUserLoginVo';
import { ResponseDataDingTalkUserDetail } from '../models/ResponseDataDingTalkUserDetail';
import { ResponseDataDingTalkUserLoginVo } from '../models/ResponseDataDingTalkUserLoginVo';
import { ResponseDataEventVO } from '../models/ResponseDataEventVO';
import { ResponseDataFeedback } from '../models/ResponseDataFeedback';
import { ResponseDataFeedbackPagination } from '../models/ResponseDataFeedbackPagination';
import { ResponseDataFeedbackVO } from '../models/ResponseDataFeedbackVO';
import { ResponseDataFeishuTenantDetailVO } from '../models/ResponseDataFeishuTenantDetailVO';
import { ResponseDataFieldCollaboratorVO } from '../models/ResponseDataFieldCollaboratorVO';
import { ResponseDataFieldPermissionView } from '../models/ResponseDataFieldPermissionView';
import { ResponseDataGmLabFeatureVo } from '../models/ResponseDataGmLabFeatureVo';
import { ResponseDataHqAddUserVo } from '../models/ResponseDataHqAddUserVo';
import { ResponseDataIdaasAuthLoginVo } from '../models/ResponseDataIdaasAuthLoginVo';
import { ResponseDataIdaasBindInfoVo } from '../models/ResponseDataIdaasBindInfoVo';
import { ResponseDataInteger } from '../models/ResponseDataInteger';
import { ResponseDataInternalCreditUsageVo } from '../models/ResponseDataInternalCreditUsageVo';
import { ResponseDataInternalSpaceApiRateLimitVo } from '../models/ResponseDataInternalSpaceApiRateLimitVo';
import { ResponseDataInternalSpaceApiUsageVo } from '../models/ResponseDataInternalSpaceApiUsageVo';
import { ResponseDataInternalSpaceAutomationRunMessageV0 } from '../models/ResponseDataInternalSpaceAutomationRunMessageV0';
import { ResponseDataInternalSpaceCapacityVo } from '../models/ResponseDataInternalSpaceCapacityVo';
import { ResponseDataInternalSpaceInfoVo } from '../models/ResponseDataInternalSpaceInfoVo';
import { ResponseDataInternalSpaceSubscriptionVo } from '../models/ResponseDataInternalSpaceSubscriptionVo';
import { ResponseDataInternalSpaceUsageVo } from '../models/ResponseDataInternalSpaceUsageVo';
import { ResponseDataInviteInfoVo } from '../models/ResponseDataInviteInfoVo';
import { ResponseDataLabsFeatureVo } from '../models/ResponseDataLabsFeatureVo';
import { ResponseDataListActionVO } from '../models/ResponseDataListActionVO';
import { ResponseDataListAgentVO } from '../models/ResponseDataListAgentVO';
import { ResponseDataListAlbumVo } from '../models/ResponseDataListAlbumVo';
import { ResponseDataListAssetUploadCertificateVO } from '../models/ResponseDataListAssetUploadCertificateVO';
import { ResponseDataListAssetUploadResult } from '../models/ResponseDataListAssetUploadResult';
import { ResponseDataListAssetUrlSignatureVo } from '../models/ResponseDataListAssetUrlSignatureVo';
import { ResponseDataListAutomationSimpleVO } from '../models/ResponseDataListAutomationSimpleVO';
import { ResponseDataListAutomationTaskSimpleVO } from '../models/ResponseDataListAutomationTaskSimpleVO';
import { ResponseDataListDatasheetPermissionView } from '../models/ResponseDataListDatasheetPermissionView';
import { ResponseDataListFavoriteNodeInfo } from '../models/ResponseDataListFavoriteNodeInfo';
import { ResponseDataListFieldPermissionView } from '../models/ResponseDataListFieldPermissionView';
import { ResponseDataListGlobalWidgetInfo } from '../models/ResponseDataListGlobalWidgetInfo';
import { ResponseDataListMarketplaceSpaceAppVo } from '../models/ResponseDataListMarketplaceSpaceAppVo';
import { ResponseDataListMemberBriefInfoVo } from '../models/ResponseDataListMemberBriefInfoVo';
import { ResponseDataListMemberInfoVo } from '../models/ResponseDataListMemberInfoVo';
import { ResponseDataListMemberPageVo } from '../models/ResponseDataListMemberPageVo';
import { ResponseDataListNodeInfo } from '../models/ResponseDataListNodeInfo';
import { ResponseDataListNodeInfoVo } from '../models/ResponseDataListNodeInfoVo';
import { ResponseDataListNodePathVo } from '../models/ResponseDataListNodePathVo';
import { ResponseDataListNodeSearchResult } from '../models/ResponseDataListNodeSearchResult';
import { ResponseDataListNotificationDetailVo } from '../models/ResponseDataListNotificationDetailVo';
import { ResponseDataListOrganizationUnitVo } from '../models/ResponseDataListOrganizationUnitVo';
import { ResponseDataListPausedUserHistoryDto } from '../models/ResponseDataListPausedUserHistoryDto';
import { ResponseDataListProductPriceVo } from '../models/ResponseDataListProductPriceVo';
import { ResponseDataListProductVO } from '../models/ResponseDataListProductVO';
import { ResponseDataListRoleInfoVo } from '../models/ResponseDataListRoleInfoVo';
import { ResponseDataListRubbishNodeVo } from '../models/ResponseDataListRubbishNodeVo';
import { ResponseDataListSearchMemberVo } from '../models/ResponseDataListSearchMemberVo';
import { ResponseDataListSpaceLinkVo } from '../models/ResponseDataListSpaceLinkVo';
import { ResponseDataListSpaceShowcaseVo } from '../models/ResponseDataListSpaceShowcaseVo';
import { ResponseDataListSpaceVO } from '../models/ResponseDataListSpaceVO';
import { ResponseDataListString } from '../models/ResponseDataListString';
import { ResponseDataListTeamTreeVo } from '../models/ResponseDataListTeamTreeVo';
import { ResponseDataListTemplateCategoryMenuVo } from '../models/ResponseDataListTemplateCategoryMenuVo';
import { ResponseDataListTemplateVo } from '../models/ResponseDataListTemplateVo';
import { ResponseDataListTrainingInfoVO } from '../models/ResponseDataListTrainingInfoVO';
import { ResponseDataListTriggerVO } from '../models/ResponseDataListTriggerVO';
import { ResponseDataListUnitInfoVo } from '../models/ResponseDataListUnitInfoVo';
import { ResponseDataListUserInPausedDto } from '../models/ResponseDataListUserInPausedDto';
import { ResponseDataListVCodeActivityVo } from '../models/ResponseDataListVCodeActivityVo';
import { ResponseDataListVCodeCouponVo } from '../models/ResponseDataListVCodeCouponVo';
import { ResponseDataListWidgetInfo } from '../models/ResponseDataListWidgetInfo';
import { ResponseDataListWidgetPack } from '../models/ResponseDataListWidgetPack';
import { ResponseDataListWidgetPackageInfoVo } from '../models/ResponseDataListWidgetPackageInfoVo';
import { ResponseDataListWidgetReleaseListVo } from '../models/ResponseDataListWidgetReleaseListVo';
import { ResponseDataListWidgetStoreListInfo } from '../models/ResponseDataListWidgetStoreListInfo';
import { ResponseDataListWidgetTemplatePackageInfo } from '../models/ResponseDataListWidgetTemplatePackageInfo';
import { ResponseDataListWidgetUploadTokenVo } from '../models/ResponseDataListWidgetUploadTokenVo';
import { ResponseDataLoginResultVO } from '../models/ResponseDataLoginResultVO';
import { ResponseDataLoginResultVo } from '../models/ResponseDataLoginResultVO';
import { ResponseDataLogoutVO } from '../models/ResponseDataLogoutVO';
import { ResponseDataMainAdminInfoVo } from '../models/ResponseDataMainAdminInfoVo';
import { ResponseDataMemberInfoVo } from '../models/ResponseDataMemberInfoVo';
import { ResponseDataMemberUnitsVo } from '../models/ResponseDataMemberUnitsVo';
import { ResponseDataMessageCreditUsageVO } from '../models/ResponseDataMessageCreditUsageVO';
import { ResponseDataNodeCollaboratorVO } from '../models/ResponseDataNodeCollaboratorVO';
import { ResponseDataNodeCollaboratorsVo } from '../models/ResponseDataNodeCollaboratorsVo';
import { ResponseDataNodeInfoTreeVo } from '../models/ResponseDataNodeInfoTreeVo';
import { ResponseDataNodeInfoVo } from '../models/ResponseDataNodeInfoVo';
import { ResponseDataNodeInfoWindowVo } from '../models/ResponseDataNodeInfoWindowVo';
import { ResponseDataNodeShareInfoVO } from '../models/ResponseDataNodeShareInfoVO';
import { ResponseDataNodeShareSettingInfoVO } from '../models/ResponseDataNodeShareSettingInfoVO';
import { ResponseDataNotificationStatisticsVo } from '../models/ResponseDataNotificationStatisticsVo';
import { ResponseDataObject } from '../models/ResponseDataObject';
import { ResponseDataOrderDetailVo } from '../models/ResponseDataOrderDetailVo';
import { ResponseDataOrderPaymentVo } from '../models/ResponseDataOrderPaymentVo';
import { ResponseDataOrderPreview } from '../models/ResponseDataOrderPreview';
import { ResponseDataPageInfoAppInfo } from '../models/ResponseDataPageInfoAppInfo';
import { ResponseDataPageInfoAppInstance } from '../models/ResponseDataPageInfoAppInstance';
import { ResponseDataPageInfoAssetsAuditVo } from '../models/ResponseDataPageInfoAssetsAuditVo';
import { ResponseDataPageInfoContentCensorResultVo } from '../models/ResponseDataPageInfoContentCensorResultVo';
import { ResponseDataPageInfoFieldRoleMemberVo } from '../models/ResponseDataPageInfoFieldRoleMemberVo';
import { ResponseDataPageInfoIntegralRecordVO } from '../models/ResponseDataPageInfoIntegralRecordVO';
import { ResponseDataPageInfoMemberPageVo } from '../models/ResponseDataPageInfoMemberPageVo';
import { ResponseDataPageInfoNodeRoleMemberVo } from '../models/ResponseDataPageInfoNodeRoleMemberVo';
import { ResponseDataPageInfoQrCodePageVo } from '../models/ResponseDataPageInfoQrCodePageVo';
import { ResponseDataPageInfoRoleMemberVo } from '../models/ResponseDataPageInfoRoleMemberVo';
import { ResponseDataPageInfoSpaceAuditPageVO } from '../models/ResponseDataPageInfoSpaceAuditPageVO';
import { ResponseDataPageInfoSpaceCapacityPageVO } from '../models/ResponseDataPageInfoSpaceCapacityPageVO';
import { ResponseDataPageInfoSpaceRoleVo } from '../models/ResponseDataPageInfoSpaceRoleVo';
import { ResponseDataPageInfoUnitMemberInfoVo } from '../models/ResponseDataPageInfoUnitMemberInfoVo';
import { ResponseDataPageInfoUnitRoleInfoVo } from '../models/ResponseDataPageInfoUnitRoleInfoVo';
import { ResponseDataPageInfoUnitTeamInfoVo } from '../models/ResponseDataPageInfoUnitTeamInfoVo';
import { ResponseDataPageInfoVCodeActivityPageVo } from '../models/ResponseDataPageInfoVCodeActivityPageVo';
import { ResponseDataPageInfoVCodeCouponPageVo } from '../models/ResponseDataPageInfoVCodeCouponPageVo';
import { ResponseDataPageInfoVCodePageVo } from '../models/ResponseDataPageInfoVCodePageVo';
import { ResponseDataPaginationMessage } from '../models/ResponseDataPaginationMessage';
import { ResponseDataPaymentOrderStatusVo } from '../models/ResponseDataPaymentOrderStatusVo';
import { ResponseDataPureJson } from '../models/ResponseDataPureJson';
import { ResponseDataPureJsonData } from '../models/ResponseDataPureJsonData';
import { ResponseDataQrCodeVo } from '../models/ResponseDataQrCodeVo';
import { ResponseDataRecommendVo } from '../models/ResponseDataRecommendVo';
import { ResponseDataSearchResultVo } from '../models/ResponseDataSearchResultVo';
import { ResponseDataShareBaseInfoVo } from '../models/ResponseDataShareBaseInfoVo';
import { ResponseDataShowcaseVo } from '../models/ResponseDataShowcaseVo';
import { ResponseDataSocialTenantEnvVo } from '../models/ResponseDataSocialTenantEnvVo';
import { ResponseDataSpaceCapacityVO } from '../models/ResponseDataSpaceCapacityVO';
import { ResponseDataSpaceGlobalFeature } from '../models/ResponseDataSpaceGlobalFeature';
import { ResponseDataSpaceInfoVO } from '../models/ResponseDataSpaceInfoVO';
import { ResponseDataSpaceLinkInfoVo } from '../models/ResponseDataSpaceLinkInfoVo';
import { ResponseDataSpaceRoleDetailVo } from '../models/ResponseDataSpaceRoleDetailVo';
import { ResponseDataSpaceSubscribeVo } from '../models/ResponseDataSpaceSubscribeVo';
import { ResponseDataStoreNodeInfoVO } from '../models/ResponseDataStoreNodeInfoVO';
import { ResponseDataString } from '../models/ResponseDataString';
import { ResponseDataSubUnitResultVo } from '../models/ResponseDataSubUnitResultVo';
import { ResponseDataSuggestionVO } from '../models/ResponseDataSuggestionVO';
import { ResponseDataTeamInfoVo } from '../models/ResponseDataTeamInfoVo';
import { ResponseDataTemplateCategoryContentVo } from '../models/ResponseDataTemplateCategoryContentVo';
import { ResponseDataTemplateDirectoryVo } from '../models/ResponseDataTemplateDirectoryVo';
import { ResponseDataTemplateSearchResultVo } from '../models/ResponseDataTemplateSearchResultVo';
import { ResponseDataTenantDetailVO } from '../models/ResponseDataTenantDetailVO';
import { ResponseDataTrainingPredictResult } from '../models/ResponseDataTrainingPredictResult';
import { ResponseDataTrainingStatusVO } from '../models/ResponseDataTrainingStatusVO';
import { ResponseDataUnitMemberInfoVo } from '../models/ResponseDataUnitMemberInfoVo';
import { ResponseDataUnitRoleInfoVo } from '../models/ResponseDataUnitRoleInfoVo';
import { ResponseDataUnitRoleMemberVo } from '../models/ResponseDataUnitRoleMemberVo';
import { ResponseDataUnitSearchResultVo } from '../models/ResponseDataUnitSearchResultVo';
import { ResponseDataUnitTeamInfoVo } from '../models/ResponseDataUnitTeamInfoVo';
import { ResponseDataUploadParseResultVO } from '../models/ResponseDataUploadParseResultVO';
import { ResponseDataUrlAwareContentsVo } from '../models/ResponseDataUrlAwareContentsVo';
import { ResponseDataUserBaseInfoVo } from '../models/ResponseDataUserBaseInfoVo';
import { ResponseDataUserInfoVo } from '../models/ResponseDataUserInfoVo';
import { ResponseDataUserIntegralVo } from '../models/ResponseDataUserIntegralVo';
import { ResponseDataUserProfile } from '../models/ResponseDataUserProfile';
import { ResponseDataUserSpaceLabsFeatureVo } from '../models/ResponseDataUserSpaceLabsFeatureVo';
import { ResponseDataUserSpaceVo } from '../models/ResponseDataUserSpaceVo';
import { ResponseDataVCodeActivityVo } from '../models/ResponseDataVCodeActivityVo';
import { ResponseDataVCodeCouponVo } from '../models/ResponseDataVCodeCouponVo';
import { ResponseDataVoid } from '../models/ResponseDataVoid';
import { ResponseDataWeComBindConfigVo } from '../models/ResponseDataWeComBindConfigVo';
import { ResponseDataWeComBindSpaceVo } from '../models/ResponseDataWeComBindSpaceVo';
import { ResponseDataWeComCheckConfigVo } from '../models/ResponseDataWeComCheckConfigVo';
import { ResponseDataWeComIsvJsSdkAgentConfigVo } from '../models/ResponseDataWeComIsvJsSdkAgentConfigVo';
import { ResponseDataWeComIsvJsSdkConfigVo } from '../models/ResponseDataWeComIsvJsSdkConfigVo';
import { ResponseDataWeComIsvRegisterInstallSelfUrlVo } from '../models/ResponseDataWeComIsvRegisterInstallSelfUrlVo';
import { ResponseDataWeComIsvRegisterInstallWeComVo } from '../models/ResponseDataWeComIsvRegisterInstallWeComVo';
import { ResponseDataWeComIsvUserLoginVo } from '../models/ResponseDataWeComIsvUserLoginVo';
import { ResponseDataWeComUserLoginVo } from '../models/ResponseDataWeComUserLoginVo';
import { ResponseDataWechatAuthorizationEntity } from '../models/ResponseDataWechatAuthorizationEntity';
import { ResponseDataWechatInfoVo } from '../models/ResponseDataWechatInfoVo';
import { ResponseDataWidgetInfoVo } from '../models/ResponseDataWidgetInfoVo';
import { ResponseDataWidgetIssuedGlobalIdVo } from '../models/ResponseDataWidgetIssuedGlobalIdVo';
import { ResponseDataWidgetPack } from '../models/ResponseDataWidgetPack';
import { ResponseDataWidgetPackageInfoVo } from '../models/ResponseDataWidgetPackageInfoVo';
import { ResponseDataWidgetReleaseCreateVo } from '../models/ResponseDataWidgetReleaseCreateVo';
import { ResponseDataWidgetUploadMetaVo } from '../models/ResponseDataWidgetUploadMetaVo';
import { ResponseDataWoaUserLoginVo } from '../models/ResponseDataWoaUserLoginVo';
import { ResponseDataWxJsapiSignature } from '../models/ResponseDataWxJsapiSignature';
import { ResponseDataWxOpenAuthorizerListResult } from '../models/ResponseDataWxOpenAuthorizerListResult';
import { RetrievePwdOpRo } from '../models/RetrievePwdOpRo';
import { RoleBaseInfoDto } from '../models/RoleBaseInfoDto';
import { RoleControlOpenRo } from '../models/RoleControlOpenRo';
import { RoleInfoVo } from '../models/RoleInfoVo';
import { RoleMemberUnitRo } from '../models/RoleMemberUnitRo';
import { RoleMemberVo } from '../models/RoleMemberVo';
import { RoleVo } from '../models/RoleVo';
import { RubbishNodeVo } from '../models/RubbishNodeVo';
import { SearchMemberResultVo } from '../models/SearchMemberResultVo';
import { SearchMemberVo } from '../models/SearchMemberVo';
import { SearchResultVo } from '../models/SearchResultVo';
import { SearchTeamResultVo } from '../models/SearchTeamResultVo';
import { SearchUnitRo } from '../models/SearchUnitRo';
import { SeatUsage } from '../models/SeatUsage';
import { SendMessageParam } from '../models/SendMessageParam';
import { ShareBaseInfoVo } from '../models/ShareBaseInfoVo';
import { ShowcaseVo } from '../models/ShowcaseVo';
import { SmsCodeValidateRo } from '../models/SmsCodeValidateRo';
import { SmsOpRo } from '../models/SmsOpRo';
import { Social } from '../models/Social';
import { SocialTenantEnvVo } from '../models/SocialTenantEnvVo';
import { Space } from '../models/Space';
import { SpaceAssetOpRo } from '../models/SpaceAssetOpRo';
import { SpaceAuditPageVO } from '../models/SpaceAuditPageVO';
import { SpaceCapacityPageVO } from '../models/SpaceCapacityPageVO';
import { SpaceCapacityVO } from '../models/SpaceCapacityVO';
import { SpaceDeleteRo } from '../models/SpaceDeleteRo';
import { SpaceGlobalFeature } from '../models/SpaceGlobalFeature';
import { SpaceInfoVO } from '../models/SpaceInfoVO';
import { SpaceJoinApplyRo } from '../models/SpaceJoinApplyRo';
import { SpaceJoinProcessRo } from '../models/SpaceJoinProcessRo';
import { SpaceLabs } from '../models/SpaceLabs';
import { SpaceLinkInfoVo } from '../models/SpaceLinkInfoVo';
import { SpaceLinkOpRo } from '../models/SpaceLinkOpRo';
import { SpaceLinkVo } from '../models/SpaceLinkVo';
import { SpaceMainAdminChangeOpRo } from '../models/SpaceMainAdminChangeOpRo';
import { SpaceMemberSettingRo } from '../models/SpaceMemberSettingRo';
import { SpaceOpRo } from '../models/SpaceOpRo';
import { SpaceRoleDetailVo } from '../models/SpaceRoleDetailVo';
import { SpaceRoleVo } from '../models/SpaceRoleVo';
import { SpaceSecuritySettingRo } from '../models/SpaceSecuritySettingRo';
import { SpaceShowcaseVo } from '../models/SpaceShowcaseVo';
import { SpaceSocialConfig } from '../models/SpaceSocialConfig';
import { SpaceStatisticsRo } from '../models/SpaceStatisticsRo';
import { SpaceSubscribeVo } from '../models/SpaceSubscribeVo';
import { SpaceUpdateOpRo } from '../models/SpaceUpdateOpRo';
import { SpaceVO } from '../models/SpaceVO';
import { SpaceWorkbenchSettingRo } from '../models/SpaceWorkbenchSettingRo';
import { StoreNodeInfoVO } from '../models/StoreNodeInfoVO';
import { StoreShareNodeRo } from '../models/StoreShareNodeRo';
import { SubUnitResultVo } from '../models/SubUnitResultVo';
import { SuggestionParams } from '../models/SuggestionParams';
import { SuggestionVO } from '../models/SuggestionVO';
import { SyncSocialDingTalkAppRo } from '../models/SyncSocialDingTalkAppRo';
import { TagVo } from '../models/TagVo';
import { TeamAddMemberRo } from '../models/TeamAddMemberRo';
import { TeamInfoVo } from '../models/TeamInfoVo';
import { TeamTreeVo } from '../models/TeamTreeVo';
import { TeamVo } from '../models/TeamVo';
import { Template } from '../models/Template';
import { TemplateCategoryContentVo } from '../models/TemplateCategoryContentVo';
import { TemplateCategoryCreateRo } from '../models/TemplateCategoryCreateRo';
import { TemplateCategoryMenuVo } from '../models/TemplateCategoryMenuVo';
import { TemplateCenterConfigRo } from '../models/TemplateCenterConfigRo';
import { TemplateDirectoryVo } from '../models/TemplateDirectoryVo';
import { TemplateGroupVo } from '../models/TemplateGroupVo';
import { TemplatePublishRo } from '../models/TemplatePublishRo';
import { TemplateSearchResult } from '../models/TemplateSearchResult';
import { TemplateSearchResultVo } from '../models/TemplateSearchResultVo';
import { TemplateUnpublishRo } from '../models/TemplateUnpublishRo';
import { TemplateVo } from '../models/TemplateVo';
import { TenantDetailVO } from '../models/TenantDetailVO';
import { TrainingInfoVO } from '../models/TrainingInfoVO';
import { TrainingPredictParams } from '../models/TrainingPredictParams';
import { TrainingPredictResult } from '../models/TrainingPredictResult';
import { TrainingStatusVO } from '../models/TrainingStatusVO';
import { TriggerSimpleVO } from '../models/TriggerSimpleVO';
import { TriggerTypeCreateRO } from '../models/TriggerTypeCreateRO';
import { TriggerTypeEditRO } from '../models/TriggerTypeEditRO';
import { TriggerVO } from '../models/TriggerVO';
import { UnionEmpExt } from '../models/UnionEmpExt';
import { UnionEmpMapVo } from '../models/UnionEmpMapVo';
import { Unit } from '../models/Unit';
import { UnitInfoVo } from '../models/UnitInfoVo';
import { UnitMemberInfoVo } from '../models/UnitMemberInfoVo';
import { UnitMemberVo } from '../models/UnitMemberVo';
import { UnitRoleInfoVo } from '../models/UnitRoleInfoVo';
import { UnitRoleMemberVo } from '../models/UnitRoleMemberVo';
import { UnitSearchResultVo } from '../models/UnitSearchResultVo';
import { UnitTagVo } from '../models/UnitTagVo';
import { UnitTeamInfoVo } from '../models/UnitTeamInfoVo';
import { UnitTeamVo } from '../models/UnitTeamVo';
import { UnlockRo } from '../models/UnlockRo';
import { UpdateActionRO } from '../models/UpdateActionRO';
import { UpdateMemberOpRo } from '../models/UpdateMemberOpRo';
import { UpdateMemberRo } from '../models/UpdateMemberRo';
import { UpdateMemberTeamRo } from '../models/UpdateMemberTeamRo';
import { UpdateNodeShareSettingRo } from '../models/UpdateNodeShareSettingRo';
import { UpdatePwdOpRo } from '../models/UpdatePwdOpRo';
import { UpdateRobotRO } from '../models/UpdateRobotRO';
import { UpdateRoleRo } from '../models/UpdateRoleRo';
import { UpdateSpaceRoleRo } from '../models/UpdateSpaceRoleRo';
import { UpdateTeamRo } from '../models/UpdateTeamRo';
import { UpdateTriggerRO } from '../models/UpdateTriggerRO';
import { UpdateUnitMemberRo } from '../models/UpdateUnitMemberRo';
import { UpdateUnitRoleRo } from '../models/UpdateUnitRoleRo';
import { UpdateUnitTeamRo } from '../models/UpdateUnitTeamRo';
import { UploadMemberTemplateRo } from '../models/UploadMemberTemplateRo';
import { UploadParseResultVO } from '../models/UploadParseResultVO';
import { UrlAwareContentVo } from '../models/UrlAwareContentVo';
import { UrlAwareContentsVo } from '../models/UrlAwareContentsVo';
import { UrlsWrapperRo } from '../models/UrlsWrapperRo';
import { UserActivityAssignRo } from '../models/UserActivityAssignRo';
import { UserActivityRo } from '../models/UserActivityRo';
import { UserBaseInfoVo } from '../models/UserBaseInfoVo';
import { UserInPausedDto } from '../models/UserInPausedDto';
import { UserInfoVo } from '../models/UserInfoVo';
import { UserIntegralVo } from '../models/UserIntegralVo';
import { UserLabsFeatureRo } from '../models/UserLabsFeatureRo';
import { UserLinkEmailRo } from '../models/UserLinkEmailRo';
import { UserLinkOpRo } from '../models/UserLinkOpRo';
import { UserLinkVo } from '../models/UserLinkVo';
import { UserOpRo } from '../models/UserOpRo';
import { UserProfile } from '../models/UserProfile';
import { UserRole } from '../models/UserRole';
import { UserSimpleVO } from '../models/UserSimpleVO';
import { UserSpaceLabsFeatureVo } from '../models/UserSpaceLabsFeatureVo';
import { UserSpaceVo } from '../models/UserSpaceVo';
import { VCodeActivityPageVo } from '../models/VCodeActivityPageVo';
import { VCodeActivityRo } from '../models/VCodeActivityRo';
import { VCodeActivityVo } from '../models/VCodeActivityVo';
import { VCodeCouponPageVo } from '../models/VCodeCouponPageVo';
import { VCodeCouponRo } from '../models/VCodeCouponRo';
import { VCodeCouponVo } from '../models/VCodeCouponVo';
import { VCodeCreateRo } from '../models/VCodeCreateRo';
import { VCodePageVo } from '../models/VCodePageVo';
import { VCodeUpdateRo } from '../models/VCodeUpdateRo';
import { WeComAgentBindSpaceRo } from '../models/WeComAgentBindSpaceRo';
import { WeComBindConfigVo } from '../models/WeComBindConfigVo';
import { WeComBindSpaceVo } from '../models/WeComBindSpaceVo';
import { WeComCheckConfigRo } from '../models/WeComCheckConfigRo';
import { WeComCheckConfigVo } from '../models/WeComCheckConfigVo';
import { WeComIsvAdminChangeRo } from '../models/WeComIsvAdminChangeRo';
import { WeComIsvInviteUnauthMemberRo } from '../models/WeComIsvInviteUnauthMemberRo';
import { WeComIsvJsSdkAgentConfigVo } from '../models/WeComIsvJsSdkAgentConfigVo';
import { WeComIsvJsSdkConfigVo } from '../models/WeComIsvJsSdkConfigVo';
import { WeComIsvLoginAdminCodeRo } from '../models/WeComIsvLoginAdminCodeRo';
import { WeComIsvLoginAuthCodeRo } from '../models/WeComIsvLoginAuthCodeRo';
import { WeComIsvLoginCodeRo } from '../models/WeComIsvLoginCodeRo';
import { WeComIsvRegisterInstallSelfUrlVo } from '../models/WeComIsvRegisterInstallSelfUrlVo';
import { WeComIsvRegisterInstallWeComVo } from '../models/WeComIsvRegisterInstallWeComVo';
import { WeComIsvUserLoginVo } from '../models/WeComIsvUserLoginVo';
import { WeComUserLoginRo } from '../models/WeComUserLoginRo';
import { WeComUserLoginVo } from '../models/WeComUserLoginVo';
import { WechatAuthorizationEntity } from '../models/WechatAuthorizationEntity';
import { WechatInfoVo } from '../models/WechatInfoVo';
import { WidgetAssetUploadCertificateRO } from '../models/WidgetAssetUploadCertificateRO';
import { WidgetAuditGlobalIdRo } from '../models/WidgetAuditGlobalIdRo';
import { WidgetAuditSubmitDataRo } from '../models/WidgetAuditSubmitDataRo';
import { WidgetCopyRo } from '../models/WidgetCopyRo';
import { WidgetCreateRo } from '../models/WidgetCreateRo';
import { WidgetInfo } from '../models/WidgetInfo';
import { WidgetInfoVo } from '../models/WidgetInfoVo';
import { WidgetIssuedGlobalIdVo } from '../models/WidgetIssuedGlobalIdVo';
import { WidgetPack } from '../models/WidgetPack';
import { WidgetPackageAuthRo } from '../models/WidgetPackageAuthRo';
import { WidgetPackageBanRo } from '../models/WidgetPackageBanRo';
import { WidgetPackageCreateRo } from '../models/WidgetPackageCreateRo';
import { WidgetPackageInfoVo } from '../models/WidgetPackageInfoVo';
import { WidgetPackageReleaseV2Ro } from '../models/WidgetPackageReleaseV2Ro';
import { WidgetPackageRollbackRo } from '../models/WidgetPackageRollbackRo';
import { WidgetPackageSubmitV2Ro } from '../models/WidgetPackageSubmitV2Ro';
import { WidgetPackageUnpublishRo } from '../models/WidgetPackageUnpublishRo';
import { WidgetReleaseCreateVo } from '../models/WidgetReleaseCreateVo';
import { WidgetReleaseListVo } from '../models/WidgetReleaseListVo';
import { WidgetSnapshot } from '../models/WidgetSnapshot';
import { WidgetStoreListExtraInfo } from '../models/WidgetStoreListExtraInfo';
import { WidgetStoreListInfo } from '../models/WidgetStoreListInfo';
import { WidgetStoreListRo } from '../models/WidgetStoreListRo';
import { WidgetTemplatePackageExtraInfo } from '../models/WidgetTemplatePackageExtraInfo';
import { WidgetTemplatePackageInfo } from '../models/WidgetTemplatePackageInfo';
import { WidgetTransferOwnerRo } from '../models/WidgetTransferOwnerRo';
import { WidgetUploadMetaVo } from '../models/WidgetUploadMetaVo';
import { WidgetUploadNotifyRO } from '../models/WidgetUploadNotifyRO';
import { WidgetUploadTokenVo } from '../models/WidgetUploadTokenVo';
import { WoaAppBindSpaceRo } from '../models/WoaAppBindSpaceRo';
import { WoaUserLoginRo } from '../models/WoaUserLoginRo';
import { WoaUserLoginVo } from '../models/WoaUserLoginVo';
import { WxJsapiSignature } from '../models/WxJsapiSignature';
import { WxOpenAuthorizerListResult } from '../models/WxOpenAuthorizerListResult';

import { AIApiRequestFactory, AIApiResponseProcessor} from "../apis/AIApi";
export class ObservableAIApi {
    private requestFactory: AIApiRequestFactory;
    private responseProcessor: AIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AIApiRequestFactory,
        responseProcessor?: AIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AIApiResponseProcessor();
    }

    /**
     * Create Feedback
     * Create Feedback
     * @param feedbackCreateParam
     * @param aiId
     */
    public createFeedback1WithHttpInfo(feedbackCreateParam: FeedbackCreateParam, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedback>> {
        const requestContextPromise = this.requestFactory.createFeedback1(feedbackCreateParam, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createFeedback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Feedback
     * Create Feedback
     * @param feedbackCreateParam
     * @param aiId
     */
    public createFeedback1(feedbackCreateParam: FeedbackCreateParam, aiId: string, _options?: Configuration): Observable<ResponseDataFeedback> {
        return this.createFeedback1WithHttpInfo(feedbackCreateParam, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedback>) => apiResponse.data));
    }

    /**
     * Retrieve Conversation Feedback
     * Retrieve Conversation Feedback
     * @param aiId
     * @param conversationId
     */
    public getConversationFeedback1WithHttpInfo(aiId: string, conversationId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedbackVO>> {
        const requestContextPromise = this.requestFactory.getConversationFeedback1(aiId, conversationId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getConversationFeedback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Conversation Feedback
     * Retrieve Conversation Feedback
     * @param aiId
     * @param conversationId
     */
    public getConversationFeedback1(aiId: string, conversationId: string, _options?: Configuration): Observable<ResponseDataFeedbackVO> {
        return this.getConversationFeedback1WithHttpInfo(aiId, conversationId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedbackVO>) => apiResponse.data));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Credit Usage
     * @param aiId
     */
    public getCreditUsageWithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataMessageCreditUsageVO>> {
        const requestContextPromise = this.requestFactory.getCreditUsage(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCreditUsageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Credit Usage
     * @param aiId
     */
    public getCreditUsage(aiId: string, _options?: Configuration): Observable<ResponseDataMessageCreditUsageVO> {
        return this.getCreditUsageWithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataMessageCreditUsageVO>) => apiResponse.data));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Latest Training Status
     * @param aiId
     */
    public getLastTrainingStatus1WithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTrainingStatusVO>> {
        const requestContextPromise = this.requestFactory.getLastTrainingStatus1(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getLastTrainingStatus1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Latest Training Status
     * @param aiId
     */
    public getLastTrainingStatus1(aiId: string, _options?: Configuration): Observable<ResponseDataTrainingStatusVO> {
        return this.getLastTrainingStatus1WithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTrainingStatusVO>) => apiResponse.data));
    }

    /**
     * Retrieve Conversation Message
     * Retrieve Conversation Message
     * @param aiId
     * @param trainingId
     * @param conversationId
     * @param cursor
     * @param limit
     */
    public getMessagePagination1WithHttpInfo(aiId: string, trainingId?: string, conversationId?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataPaginationMessage>> {
        const requestContextPromise = this.requestFactory.getMessagePagination1(aiId, trainingId, conversationId, cursor, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMessagePagination1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Conversation Message
     * Retrieve Conversation Message
     * @param aiId
     * @param trainingId
     * @param conversationId
     * @param cursor
     * @param limit
     */
    public getMessagePagination1(aiId: string, trainingId?: string, conversationId?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<ResponseDataPaginationMessage> {
        return this.getMessagePagination1WithHttpInfo(aiId, trainingId, conversationId, cursor, limit, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPaginationMessage>) => apiResponse.data));
    }

    /**
     * Retrieve Feedback Pagination
     * Retrieve Feedback Pagination
     * @param aiId
     * @param pageNum
     * @param pageSize
     * @param state
     * @param search
     */
    public getMessagesFeedback1WithHttpInfo(aiId: string, pageNum?: number, pageSize?: number, state?: number, search?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedbackPagination>> {
        const requestContextPromise = this.requestFactory.getMessagesFeedback1(aiId, pageNum, pageSize, state, search, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMessagesFeedback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Feedback Pagination
     * Retrieve Feedback Pagination
     * @param aiId
     * @param pageNum
     * @param pageSize
     * @param state
     * @param search
     */
    public getMessagesFeedback1(aiId: string, pageNum?: number, pageSize?: number, state?: number, search?: string, _options?: Configuration): Observable<ResponseDataFeedbackPagination> {
        return this.getMessagesFeedback1WithHttpInfo(aiId, pageNum, pageSize, state, search, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedbackPagination>) => apiResponse.data));
    }

    /**
     * Get Suggestions
     * Get Suggestions
     * @param suggestionParams
     * @param aiId
     */
    public getSuggestions1WithHttpInfo(suggestionParams: SuggestionParams, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSuggestionVO>> {
        const requestContextPromise = this.requestFactory.getSuggestions1(suggestionParams, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSuggestions1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Suggestions
     * Get Suggestions
     * @param suggestionParams
     * @param aiId
     */
    public getSuggestions1(suggestionParams: SuggestionParams, aiId: string, _options?: Configuration): Observable<ResponseDataSuggestionVO> {
        return this.getSuggestions1WithHttpInfo(suggestionParams, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSuggestionVO>) => apiResponse.data));
    }

    /**
     * Retrieve AI Info by ai id
     * Retrieve AI Info
     * @param aiId
     */
    public retrieve1WithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAiInfoVO>> {
        const requestContextPromise = this.requestFactory.retrieve1(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrieve1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve AI Info by ai id
     * Retrieve AI Info
     * @param aiId
     */
    public retrieve1(aiId: string, _options?: Configuration): Observable<ResponseDataAiInfoVO> {
        return this.retrieve1WithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAiInfoVO>) => apiResponse.data));
    }

    /**
     * Retrieve AI Setting by ai id
     * Retrieve AI Setting
     * @param aiId
     * @param type
     */
    public retrieveSettingWithHttpInfo(aiId: string, type?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPureJson>> {
        const requestContextPromise = this.requestFactory.retrieveSetting(aiId, type, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrieveSettingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve AI Setting by ai id
     * Retrieve AI Setting
     * @param aiId
     * @param type
     */
    public retrieveSetting(aiId: string, type?: string, _options?: Configuration): Observable<ResponseDataPureJson> {
        return this.retrieveSettingWithHttpInfo(aiId, type, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPureJson>) => apiResponse.data));
    }

    /**
     * Retrieve AI training list by ai id
     * Retrieve AI Training List
     * @param aiId
     */
    public retrieveTrainingsWithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTrainingInfoVO>> {
        const requestContextPromise = this.requestFactory.retrieveTrainings(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrieveTrainingsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve AI training list by ai id
     * Retrieve AI Training List
     * @param aiId
     */
    public retrieveTrainings(aiId: string, _options?: Configuration): Observable<ResponseDataListTrainingInfoVO> {
        return this.retrieveTrainingsWithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTrainingInfoVO>) => apiResponse.data));
    }

    /**
     * Send Message
     * Send Message
     * @param sendMessageParam
     * @param aiId
     */
    public sendMessage1WithHttpInfo(sendMessageParam: SendMessageParam, aiId: string, _options?: Configuration): Observable<HttpInfo<Array<any>>> {
        const requestContextPromise = this.requestFactory.sendMessage1(sendMessageParam, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sendMessage1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Send Message
     * Send Message
     * @param sendMessageParam
     * @param aiId
     */
    public sendMessage1(sendMessageParam: SendMessageParam, aiId: string, _options?: Configuration): Observable<Array<any>> {
        return this.sendMessage1WithHttpInfo(sendMessageParam, aiId, _options).pipe(map((apiResponse: HttpInfo<Array<any>>) => apiResponse.data));
    }

    /**
     * Train
     * Train
     * @param aiId
     */
    public train1WithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.train1(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.train1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Train
     * Train
     * @param aiId
     */
    public train1(aiId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.train1WithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Train Predict
     * Train Predict
     * @param trainingPredictParams
     * @param aiId
     */
    public trainPredict1WithHttpInfo(trainingPredictParams: TrainingPredictParams, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTrainingPredictResult>> {
        const requestContextPromise = this.requestFactory.trainPredict1(trainingPredictParams, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.trainPredict1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Train Predict
     * Train Predict
     * @param trainingPredictParams
     * @param aiId
     */
    public trainPredict1(trainingPredictParams: TrainingPredictParams, aiId: string, _options?: Configuration): Observable<ResponseDataTrainingPredictResult> {
        return this.trainPredict1WithHttpInfo(trainingPredictParams, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTrainingPredictResult>) => apiResponse.data));
    }

    /**
     * Update AI Info
     * Update AI Info
     * @param aiUpdateParams
     * @param aiId
     */
    public update1WithHttpInfo(aiUpdateParams: AiUpdateParams, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAiInfoVO>> {
        const requestContextPromise = this.requestFactory.update1(aiUpdateParams, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.update1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Update AI Info
     * Update AI Info
     * @param aiUpdateParams
     * @param aiId
     */
    public update1(aiUpdateParams: AiUpdateParams, aiId: string, _options?: Configuration): Observable<ResponseDataAiInfoVO> {
        return this.update1WithHttpInfo(aiUpdateParams, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAiInfoVO>) => apiResponse.data));
    }

    /**
     * Update Feedback
     * Update Feedback
     * @param feedbackUpdateParam
     * @param aiId
     * @param feedbackId
     */
    public updateFeedback1WithHttpInfo(feedbackUpdateParam: FeedbackUpdateParam, aiId: string, feedbackId: number, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateFeedback1(feedbackUpdateParam, aiId, feedbackId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateFeedback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Update Feedback
     * Update Feedback
     * @param feedbackUpdateParam
     * @param aiId
     * @param feedbackId
     */
    public updateFeedback1(feedbackUpdateParam: FeedbackUpdateParam, aiId: string, feedbackId: number, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateFeedback1WithHttpInfo(feedbackUpdateParam, aiId, feedbackId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AccountCenterModuleUserManagementInterfaceApiRequestFactory, AccountCenterModuleUserManagementInterfaceApiResponseProcessor} from "../apis/AccountCenterModuleUserManagementInterfaceApi";
export class ObservableAccountCenterModuleUserManagementInterfaceApi {
    private requestFactory: AccountCenterModuleUserManagementInterfaceApiRequestFactory;
    private responseProcessor: AccountCenterModuleUserManagementInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AccountCenterModuleUserManagementInterfaceApiRequestFactory,
        responseProcessor?: AccountCenterModuleUserManagementInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AccountCenterModuleUserManagementInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AccountCenterModuleUserManagementInterfaceApiResponseProcessor();
    }

    /**
     * Registered login user applies for account cancellation
     * Apply for cancellation of user account
     */
    public applyForClosingWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.applyForClosing(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.applyForClosingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Registered login user applies for account cancellation
     * Apply for cancellation of user account
     */
    public applyForClosing(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.applyForClosingWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Bind mail and modify mail
     * Bind mail
     * @param emailCodeValidateRo
     */
    public bindEmailWithHttpInfo(emailCodeValidateRo: EmailCodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.bindEmail(emailCodeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Bind mail and modify mail
     * Bind mail
     * @param emailCodeValidateRo
     */
    public bindEmail(emailCodeValidateRo: EmailCodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.bindEmailWithHttpInfo(emailCodeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * User recovery account has been applied for cancellation
     * Apply for account restoration
     */
    public cancelClosingWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.cancelClosing(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.cancelClosingWithHttpInfo(rsp)));
            }));
    }

    /**
     * User recovery account has been applied for cancellation
     * Apply for account restoration
     */
    public cancelClosing(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.cancelClosingWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Unregistered users verify whether the account meets the cancellation conditions
     * Verify whether the account can be cancelled
     */
    public checkForClosingWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.checkForClosing(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.checkForClosingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Unregistered users verify whether the account meets the cancellation conditions
     * Verify whether the account can be cancelled
     */
    public checkForClosing(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.checkForClosingWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete Active Space Cache
     */
    public delActiveSpaceCacheWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delActiveSpaceCache(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delActiveSpaceCacheWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Active Space Cache
     */
    public delActiveSpaceCache(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.delActiveSpaceCacheWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get the enabled experimental functions
     * @param spaceId
     */
    public getEnabledLabFeaturesWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataLabsFeatureVo>> {
        const requestContextPromise = this.requestFactory.getEnabledLabFeatures(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getEnabledLabFeaturesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the enabled experimental functions
     * @param spaceId
     */
    public getEnabledLabFeatures(spaceId: string, _options?: Configuration): Observable<ResponseDataLabsFeatureVo> {
        return this.getEnabledLabFeaturesWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataLabsFeatureVo>) => apiResponse.data));
    }

    /**
     * Users can only associate with invited mail when they have no other mail
     * Associate the invited mail
     * @param userLinkEmailRo
     */
    public linkInviteEmailWithHttpInfo(userLinkEmailRo: UserLinkEmailRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.linkInviteEmail(userLinkEmailRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.linkInviteEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Users can only associate with invited mail when they have no other mail
     * Associate the invited mail
     * @param userLinkEmailRo
     */
    public linkInviteEmail(userLinkEmailRo: UserLinkEmailRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.linkInviteEmailWithHttpInfo(userLinkEmailRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * reset password router
     */
    public resetPasswordWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.resetPassword(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.resetPasswordWithHttpInfo(rsp)));
            }));
    }

    /**
     * reset password router
     */
    public resetPassword(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.resetPasswordWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Retrieve password
     * @param retrievePwdOpRo
     */
    public retrievePwdWithHttpInfo(retrievePwdOpRo: RetrievePwdOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.retrievePwd(retrievePwdOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrievePwdWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve password
     * @param retrievePwdOpRo
     */
    public retrievePwd(retrievePwdOpRo: RetrievePwdOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.retrievePwdWithHttpInfo(retrievePwdOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Bind mail and modify mail
     * Unbind mail
     * @param codeValidateRo
     */
    public unbindEmailWithHttpInfo(codeValidateRo: CodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unbindEmail(codeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unbindEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Bind mail and modify mail
     * Unbind mail
     * @param codeValidateRo
     */
    public unbindEmail(codeValidateRo: CodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unbindEmailWithHttpInfo(codeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Unbind mobile phone
     * @param codeValidateRo
     */
    public unbindPhoneWithHttpInfo(codeValidateRo: CodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unbindPhone(codeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unbindPhoneWithHttpInfo(rsp)));
            }));
    }

    /**
     * Unbind mobile phone
     * @param codeValidateRo
     */
    public unbindPhone(codeValidateRo: CodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unbindPhoneWithHttpInfo(codeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Request parameters cannot be all empty
     * Edit user information
     * @param userOpRo
     */
    public update2WithHttpInfo(userOpRo: UserOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.update2(userOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.update2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Request parameters cannot be all empty
     * Edit user information
     * @param userOpRo
     */
    public update2(userOpRo: UserOpRo, _options?: Configuration): Observable<ResponseDataString> {
        return this.update2WithHttpInfo(userOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Update the usage status of laboratory functions
     * Update the usage status of laboratory functions
     * @param userLabsFeatureRo
     */
    public updateLabsFeatureStatusWithHttpInfo(userLabsFeatureRo: UserLabsFeatureRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateLabsFeatureStatus(userLabsFeatureRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateLabsFeatureStatusWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update the usage status of laboratory functions
     * Update the usage status of laboratory functions
     * @param userLabsFeatureRo
     */
    public updateLabsFeatureStatus(userLabsFeatureRo: UserLabsFeatureRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateLabsFeatureStatusWithHttpInfo(userLabsFeatureRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Scene: 1. Personal setting and password modification; 2. Initialize after login for accounts without password
     * Change Password
     * @param updatePwdOpRo
     */
    public updatePwdWithHttpInfo(updatePwdOpRo: UpdatePwdOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updatePwd(updatePwdOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updatePwdWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scene: 1. Personal setting and password modification; 2. Initialize after login for accounts without password
     * Change Password
     * @param updatePwdOpRo
     */
    public updatePwd(updatePwdOpRo: UpdatePwdOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updatePwdWithHttpInfo(updatePwdOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * get personal information
     * @param spaceId space id
     * @param nodeId node id
     * @param filter whether to filter space related information
     */
    public userInfoWithHttpInfo(spaceId?: string, nodeId?: string, filter?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataUserInfoVo>> {
        const requestContextPromise = this.requestFactory.userInfo(spaceId, nodeId, filter, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * get personal information
     * @param spaceId space id
     * @param nodeId node id
     * @param filter whether to filter space related information
     */
    public userInfo(spaceId?: string, nodeId?: string, filter?: boolean, _options?: Configuration): Observable<ResponseDataUserInfoVo> {
        return this.userInfoWithHttpInfo(spaceId, nodeId, filter, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUserInfoVo>) => apiResponse.data));
    }

    /**
     * Query whether users bind mail
     * Query whether users bind mail
     */
    public validBindEmailWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.validBindEmail(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validBindEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query whether users bind mail
     * Query whether users bind mail
     */
    public validBindEmail(_options?: Configuration): Observable<ResponseDataBoolean> {
        return this.validBindEmailWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * Query whether the user is consistent with the specified mail. It can only be determined if the user has bound the mail
     * Query whether the user is consistent with the specified mail
     * @param checkUserEmailRo
     */
    public validSameEmailWithHttpInfo(checkUserEmailRo: CheckUserEmailRo, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.validSameEmail(checkUserEmailRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validSameEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query whether the user is consistent with the specified mail. It can only be determined if the user has bound the mail
     * Query whether the user is consistent with the specified mail
     * @param checkUserEmailRo
     */
    public validSameEmail(checkUserEmailRo: CheckUserEmailRo, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.validSameEmailWithHttpInfo(checkUserEmailRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * Bind a new phone
     * Bind a new phone
     * @param smsCodeValidateRo
     */
    public verifyPhoneWithHttpInfo(smsCodeValidateRo: SmsCodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.verifyPhone(smsCodeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.verifyPhoneWithHttpInfo(rsp)));
            }));
    }

    /**
     * Bind a new phone
     * Bind a new phone
     * @param smsCodeValidateRo
     */
    public verifyPhone(smsCodeValidateRo: SmsCodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.verifyPhoneWithHttpInfo(smsCodeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AccountLinkManagementInterfaceApiRequestFactory, AccountLinkManagementInterfaceApiResponseProcessor} from "../apis/AccountLinkManagementInterfaceApi";
export class ObservableAccountLinkManagementInterfaceApi {
    private requestFactory: AccountLinkManagementInterfaceApiRequestFactory;
    private responseProcessor: AccountLinkManagementInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AccountLinkManagementInterfaceApiRequestFactory,
        responseProcessor?: AccountLinkManagementInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AccountLinkManagementInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AccountLinkManagementInterfaceApiResponseProcessor();
    }

    /**
     * Associated DingTalk
     * Associated DingTalk
     * @param dingTalkBindOpRo
     */
    public bindDingTalkWithHttpInfo(dingTalkBindOpRo: DingTalkBindOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.bindDingTalk(dingTalkBindOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindDingTalkWithHttpInfo(rsp)));
            }));
    }

    /**
     * Associated DingTalk
     * Associated DingTalk
     * @param dingTalkBindOpRo
     */
    public bindDingTalk(dingTalkBindOpRo: DingTalkBindOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.bindDingTalkWithHttpInfo(dingTalkBindOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Unbind the third-party account
     * @param userLinkOpRo
     */
    public unbindWithHttpInfo(userLinkOpRo: UserLinkOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unbind(userLinkOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unbindWithHttpInfo(rsp)));
            }));
    }

    /**
     * Unbind the third-party account
     * @param userLinkOpRo
     */
    public unbind(userLinkOpRo: UserLinkOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unbindWithHttpInfo(userLinkOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AirAgentAIAgentResourceApiRequestFactory, AirAgentAIAgentResourceApiResponseProcessor} from "../apis/AirAgentAIAgentResourceApi";
export class ObservableAirAgentAIAgentResourceApi {
    private requestFactory: AirAgentAIAgentResourceApiRequestFactory;
    private responseProcessor: AirAgentAIAgentResourceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AirAgentAIAgentResourceApiRequestFactory,
        responseProcessor?: AirAgentAIAgentResourceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AirAgentAIAgentResourceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AirAgentAIAgentResourceApiResponseProcessor();
    }

    /**
     * Create AI Agent
     * @param agentCreateRO
     */
    public create11WithHttpInfo(agentCreateRO: AgentCreateRO, _options?: Configuration): Observable<HttpInfo<ResponseDataAiInfoVO>> {
        const requestContextPromise = this.requestFactory.create11(agentCreateRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create11WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create AI Agent
     * @param agentCreateRO
     */
    public create11(agentCreateRO: AgentCreateRO, _options?: Configuration): Observable<ResponseDataAiInfoVO> {
        return this.create11WithHttpInfo(agentCreateRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAiInfoVO>) => apiResponse.data));
    }

    /**
     * Create Feedback
     * Create Feedback
     * @param feedbackCreateParam
     * @param aiId
     */
    public createFeedbackWithHttpInfo(feedbackCreateParam: FeedbackCreateParam, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedback>> {
        const requestContextPromise = this.requestFactory.createFeedback(feedbackCreateParam, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createFeedbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Feedback
     * Create Feedback
     * @param feedbackCreateParam
     * @param aiId
     */
    public createFeedback(feedbackCreateParam: FeedbackCreateParam, aiId: string, _options?: Configuration): Observable<ResponseDataFeedback> {
        return this.createFeedbackWithHttpInfo(feedbackCreateParam, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedback>) => apiResponse.data));
    }

    /**
     * Delete AI Agent
     * @param agentId agent id
     */
    public delete18WithHttpInfo(agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete18(agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete18WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete AI Agent
     * @param agentId agent id
     */
    public delete18(agentId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete18WithHttpInfo(agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Retrieve Conversation Feedback
     * Retrieve Conversation Feedback
     * @param aiId
     * @param conversationId
     */
    public getConversationFeedbackWithHttpInfo(aiId: string, conversationId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedbackVO>> {
        const requestContextPromise = this.requestFactory.getConversationFeedback(aiId, conversationId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getConversationFeedbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Conversation Feedback
     * Retrieve Conversation Feedback
     * @param aiId
     * @param conversationId
     */
    public getConversationFeedback(aiId: string, conversationId: string, _options?: Configuration): Observable<ResponseDataFeedbackVO> {
        return this.getConversationFeedbackWithHttpInfo(aiId, conversationId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedbackVO>) => apiResponse.data));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Latest Training Status
     * @param aiId
     */
    public getLastTrainingStatusWithHttpInfo(aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTrainingStatusVO>> {
        const requestContextPromise = this.requestFactory.getLastTrainingStatus(aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getLastTrainingStatusWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Latest Training Status
     * Retrieve Latest Training Status
     * @param aiId
     */
    public getLastTrainingStatus(aiId: string, _options?: Configuration): Observable<ResponseDataTrainingStatusVO> {
        return this.getLastTrainingStatusWithHttpInfo(aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTrainingStatusVO>) => apiResponse.data));
    }

    /**
     * Retrieve Conversation Message
     * Retrieve Conversation Message
     * @param aiId
     * @param trainingId
     * @param conversationId
     * @param cursor
     * @param limit
     */
    public getMessagePaginationWithHttpInfo(aiId: string, trainingId?: string, conversationId?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataPaginationMessage>> {
        const requestContextPromise = this.requestFactory.getMessagePagination(aiId, trainingId, conversationId, cursor, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMessagePaginationWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Conversation Message
     * Retrieve Conversation Message
     * @param aiId
     * @param trainingId
     * @param conversationId
     * @param cursor
     * @param limit
     */
    public getMessagePagination(aiId: string, trainingId?: string, conversationId?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<ResponseDataPaginationMessage> {
        return this.getMessagePaginationWithHttpInfo(aiId, trainingId, conversationId, cursor, limit, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPaginationMessage>) => apiResponse.data));
    }

    /**
     * Retrieve Feedback Pagination
     * Retrieve Feedback Pagination
     * @param aiId
     * @param pageNum
     * @param pageSize
     * @param state
     * @param search
     */
    public getMessagesFeedbackWithHttpInfo(aiId: string, pageNum?: number, pageSize?: number, state?: number, search?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeedbackPagination>> {
        const requestContextPromise = this.requestFactory.getMessagesFeedback(aiId, pageNum, pageSize, state, search, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMessagesFeedbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve Feedback Pagination
     * Retrieve Feedback Pagination
     * @param aiId
     * @param pageNum
     * @param pageSize
     * @param state
     * @param search
     */
    public getMessagesFeedback(aiId: string, pageNum?: number, pageSize?: number, state?: number, search?: string, _options?: Configuration): Observable<ResponseDataFeedbackPagination> {
        return this.getMessagesFeedbackWithHttpInfo(aiId, pageNum, pageSize, state, search, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeedbackPagination>) => apiResponse.data));
    }

    /**
     * Get Suggestions
     * Get Suggestions
     * @param suggestionParams
     * @param aiId
     */
    public getSuggestionsWithHttpInfo(suggestionParams: SuggestionParams, aiId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSuggestionVO>> {
        const requestContextPromise = this.requestFactory.getSuggestions(suggestionParams, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSuggestionsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Suggestions
     * Get Suggestions
     * @param suggestionParams
     * @param aiId
     */
    public getSuggestions(suggestionParams: SuggestionParams, aiId: string, _options?: Configuration): Observable<ResponseDataSuggestionVO> {
        return this.getSuggestionsWithHttpInfo(suggestionParams, aiId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSuggestionVO>) => apiResponse.data));
    }

    /**
     * Get AI Agent List
     */
    public list8WithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListAgentVO>> {
        const requestContextPromise = this.requestFactory.list8(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list8WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get AI Agent List
     */
    public list8(_options?: Configuration): Observable<ResponseDataListAgentVO> {
        return this.list8WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListAgentVO>) => apiResponse.data));
    }

    /**
     * Retrieve AI Info
     * Retrieve AI Agent
     * @param agentId
     */
    public retrieveWithHttpInfo(agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAiInfoVO>> {
        const requestContextPromise = this.requestFactory.retrieve(agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrieveWithHttpInfo(rsp)));
            }));
    }

    /**
     * Retrieve AI Info
     * Retrieve AI Agent
     * @param agentId
     */
    public retrieve(agentId: string, _options?: Configuration): Observable<ResponseDataAiInfoVO> {
        return this.retrieveWithHttpInfo(agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAiInfoVO>) => apiResponse.data));
    }

    /**
     * Send Message
     * Send Message
     * @param sendMessageParam
     * @param aiId
     */
    public sendMessageWithHttpInfo(sendMessageParam: SendMessageParam, aiId: string, _options?: Configuration): Observable<HttpInfo<Array<string>>> {
        const requestContextPromise = this.requestFactory.sendMessage(sendMessageParam, aiId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sendMessageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Send Message
     * Send Message
     * @param sendMessageParam
     * @param aiId
     */
    public sendMessage(sendMessageParam: SendMessageParam, aiId: string, _options?: Configuration): Observable<Array<string>> {
        return this.sendMessageWithHttpInfo(sendMessageParam, aiId, _options).pipe(map((apiResponse: HttpInfo<Array<string>>) => apiResponse.data));
    }

    /**
     * Train AI Agent
     * @param agentId
     */
    public trainWithHttpInfo(agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.train(agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.trainWithHttpInfo(rsp)));
            }));
    }

    /**
     * Train AI Agent
     * @param agentId
     */
    public train(agentId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.trainWithHttpInfo(agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Train Predict
     * Train Predict
     * @param trainingPredictParams
     * @param agentId
     */
    public trainPredictWithHttpInfo(trainingPredictParams: TrainingPredictParams, agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTrainingPredictResult>> {
        const requestContextPromise = this.requestFactory.trainPredict(trainingPredictParams, agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.trainPredictWithHttpInfo(rsp)));
            }));
    }

    /**
     * Train Predict
     * Train Predict
     * @param trainingPredictParams
     * @param agentId
     */
    public trainPredict(trainingPredictParams: TrainingPredictParams, agentId: string, _options?: Configuration): Observable<ResponseDataTrainingPredictResult> {
        return this.trainPredictWithHttpInfo(trainingPredictParams, agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTrainingPredictResult>) => apiResponse.data));
    }

    /**
     * Update AI Info
     * Update AI Agent
     * @param agentUpdateParams
     * @param agentId
     */
    public updateWithHttpInfo(agentUpdateParams: AgentUpdateParams, agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAiInfoVO>> {
        const requestContextPromise = this.requestFactory.update(agentUpdateParams, agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update AI Info
     * Update AI Agent
     * @param agentUpdateParams
     * @param agentId
     */
    public update(agentUpdateParams: AgentUpdateParams, agentId: string, _options?: Configuration): Observable<ResponseDataAiInfoVO> {
        return this.updateWithHttpInfo(agentUpdateParams, agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAiInfoVO>) => apiResponse.data));
    }

    /**
     * Update Feedback
     * Update Feedback
     * @param feedbackUpdateParam
     * @param aiId
     * @param feedbackId
     */
    public updateFeedbackWithHttpInfo(feedbackUpdateParam: FeedbackUpdateParam, aiId: string, feedbackId: number, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateFeedback(feedbackUpdateParam, aiId, feedbackId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateFeedbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update Feedback
     * Update Feedback
     * @param feedbackUpdateParam
     * @param aiId
     * @param feedbackId
     */
    public updateFeedback(feedbackUpdateParam: FeedbackUpdateParam, aiId: string, feedbackId: number, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateFeedbackWithHttpInfo(feedbackUpdateParam, aiId, feedbackId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AirAgentAuthResourceApiRequestFactory, AirAgentAuthResourceApiResponseProcessor} from "../apis/AirAgentAuthResourceApi";
export class ObservableAirAgentAuthResourceApi {
    private requestFactory: AirAgentAuthResourceApiRequestFactory;
    private responseProcessor: AirAgentAuthResourceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AirAgentAuthResourceApiRequestFactory,
        responseProcessor?: AirAgentAuthResourceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AirAgentAuthResourceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AirAgentAuthResourceApiResponseProcessor();
    }

    /**
     * @param code
     * @param error
     * @param errorDescription
     */
    public callback5WithHttpInfo(code?: string, error?: string, errorDescription?: string, _options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.callback5(code, error, errorDescription, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callback5WithHttpInfo(rsp)));
            }));
    }

    /**
     * @param code
     * @param error
     * @param errorDescription
     */
    public callback5(code?: string, error?: string, errorDescription?: string, _options?: Configuration): Observable<RedirectView> {
        return this.callback5WithHttpInfo(code, error, errorDescription, _options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

    /**
     * @param message
     */
    public login4WithHttpInfo(message?: string, _options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.login4(message, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.login4WithHttpInfo(rsp)));
            }));
    }

    /**
     * @param message
     */
    public login4(message?: string, _options?: Configuration): Observable<RedirectView> {
        return this.login4WithHttpInfo(message, _options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

    /**
     * logout current user
     * Logout
     */
    public logout2WithHttpInfo(_options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.logout2(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.logout2WithHttpInfo(rsp)));
            }));
    }

    /**
     * logout current user
     * Logout
     */
    public logout2(_options?: Configuration): Observable<RedirectView> {
        return this.logout2WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

    /**
     * logout current user
     * Logout
     */
    public logout3WithHttpInfo(_options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.logout3(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.logout3WithHttpInfo(rsp)));
            }));
    }

    /**
     * logout current user
     * Logout
     */
    public logout3(_options?: Configuration): Observable<RedirectView> {
        return this.logout3WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

}

import { AirAgentUserResourceApiRequestFactory, AirAgentUserResourceApiResponseProcessor} from "../apis/AirAgentUserResourceApi";
export class ObservableAirAgentUserResourceApi {
    private requestFactory: AirAgentUserResourceApiRequestFactory;
    private responseProcessor: AirAgentUserResourceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AirAgentUserResourceApiRequestFactory,
        responseProcessor?: AirAgentUserResourceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AirAgentUserResourceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AirAgentUserResourceApiResponseProcessor();
    }

    /**
     * Get User Profile
     */
    public getUserProfileWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataUserProfile>> {
        const requestContextPromise = this.requestFactory.getUserProfile(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getUserProfileWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get User Profile
     */
    public getUserProfile(_options?: Configuration): Observable<ResponseDataUserProfile> {
        return this.getUserProfileWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataUserProfile>) => apiResponse.data));
    }

}

import { AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiRequestFactory, AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiResponseProcessor} from "../apis/AppStoreRelevantServiceInterfacesOfTheApplicationStoreApi";
export class ObservableAppStoreRelevantServiceInterfacesOfTheApplicationStoreApi {
    private requestFactory: AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiRequestFactory;
    private responseProcessor: AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiRequestFactory,
        responseProcessor?: AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AppStoreRelevantServiceInterfacesOfTheApplicationStoreApiResponseProcessor();
    }

    /**
     * Pagination query. If no query parameter is transferred, the default query will be used
     * Query application list
     * @param pageIndex Page Index
     * @param pageSize Quantity per page
     * @param orderBy Sort field
     * @param sortBy Collation,asc&#x3D;positive sequence,desc&#x3D;reverse order
     */
    public fetchAppStoreAppsWithHttpInfo(pageIndex?: string, pageSize?: string, orderBy?: string, sortBy?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoAppInfo>> {
        const requestContextPromise = this.requestFactory.fetchAppStoreApps(pageIndex, pageSize, orderBy, sortBy, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.fetchAppStoreAppsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Pagination query. If no query parameter is transferred, the default query will be used
     * Query application list
     * @param pageIndex Page Index
     * @param pageSize Quantity per page
     * @param orderBy Sort field
     * @param sortBy Collation,asc&#x3D;positive sequence,desc&#x3D;reverse order
     */
    public fetchAppStoreApps(pageIndex?: string, pageSize?: string, orderBy?: string, sortBy?: string, _options?: Configuration): Observable<ResponseDataPageInfoAppInfo> {
        return this.fetchAppStoreAppsWithHttpInfo(pageIndex, pageSize, orderBy, sortBy, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoAppInfo>) => apiResponse.data));
    }

}

import { ApplicationManagementApplicationManagementRelatedServiceInterfaceApiRequestFactory, ApplicationManagementApplicationManagementRelatedServiceInterfaceApiResponseProcessor} from "../apis/ApplicationManagementApplicationManagementRelatedServiceInterfaceApi";
export class ObservableApplicationManagementApplicationManagementRelatedServiceInterfaceApi {
    private requestFactory: ApplicationManagementApplicationManagementRelatedServiceInterfaceApiRequestFactory;
    private responseProcessor: ApplicationManagementApplicationManagementRelatedServiceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplicationManagementApplicationManagementRelatedServiceInterfaceApiRequestFactory,
        responseProcessor?: ApplicationManagementApplicationManagementRelatedServiceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ApplicationManagementApplicationManagementRelatedServiceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ApplicationManagementApplicationManagementRelatedServiceInterfaceApiResponseProcessor();
    }

    /**
     * Opening an application instance
     * Create an application instance
     * @param createAppInstance
     */
    public createAppInstanceWithHttpInfo(createAppInstance: CreateAppInstance, _options?: Configuration): Observable<HttpInfo<ResponseDataAppInstance>> {
        const requestContextPromise = this.requestFactory.createAppInstance(createAppInstance, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createAppInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Opening an application instance
     * Create an application instance
     * @param createAppInstance
     */
    public createAppInstance(createAppInstance: CreateAppInstance, _options?: Configuration): Observable<ResponseDataAppInstance> {
        return this.createAppInstanceWithHttpInfo(createAppInstance, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAppInstance>) => apiResponse.data));
    }

    /**
     * The space actively deletes applications
     * Delete app
     * @param appInstanceId Application instance ID
     */
    public delete17WithHttpInfo(appInstanceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete17(appInstanceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete17WithHttpInfo(rsp)));
            }));
    }

    /**
     * The space actively deletes applications
     * Delete app
     * @param appInstanceId Application instance ID
     */
    public delete17(appInstanceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete17WithHttpInfo(appInstanceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * At present, the interface is full query, and the paging query function will be provided later, so you don\'t need to pass paging parameters
     * Query the application instance list
     * @param spaceId Space ID
     * @param pageIndex Page Index
     * @param pageSize Quantity per page
     * @param orderBy Sort field
     * @param sortBy Collation,asc&#x3D;positive sequence,desc&#x3D;Reverse order
     */
    public fetchAppInstancesWithHttpInfo(spaceId: string, pageIndex?: string, pageSize?: string, orderBy?: string, sortBy?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoAppInstance>> {
        const requestContextPromise = this.requestFactory.fetchAppInstances(spaceId, pageIndex, pageSize, orderBy, sortBy, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.fetchAppInstancesWithHttpInfo(rsp)));
            }));
    }

    /**
     * At present, the interface is full query, and the paging query function will be provided later, so you don\'t need to pass paging parameters
     * Query the application instance list
     * @param spaceId Space ID
     * @param pageIndex Page Index
     * @param pageSize Quantity per page
     * @param orderBy Sort field
     * @param sortBy Collation,asc&#x3D;positive sequence,desc&#x3D;Reverse order
     */
    public fetchAppInstances(spaceId: string, pageIndex?: string, pageSize?: string, orderBy?: string, sortBy?: string, _options?: Configuration): Observable<ResponseDataPageInfoAppInstance> {
        return this.fetchAppInstancesWithHttpInfo(spaceId, pageIndex, pageSize, orderBy, sortBy, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoAppInstance>) => apiResponse.data));
    }

    /**
     * Get the configuration according to the application instance ID
     * Get the configuration of a single application instance
     * @param appInstanceId Application instance ID
     */
    public getAppInstanceWithHttpInfo(appInstanceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAppInstance>> {
        const requestContextPromise = this.requestFactory.getAppInstance(appInstanceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAppInstanceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the configuration according to the application instance ID
     * Get the configuration of a single application instance
     * @param appInstanceId Application instance ID
     */
    public getAppInstance(appInstanceId: string, _options?: Configuration): Observable<ResponseDataAppInstance> {
        return this.getAppInstanceWithHttpInfo(appInstanceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAppInstance>) => apiResponse.data));
    }

}

import { ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiRequestFactory, ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiResponseProcessor} from "../apis/ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApi";
export class ObservableApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApi {
    private requestFactory: ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiRequestFactory;
    private responseProcessor: ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiRequestFactory,
        responseProcessor?: ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ApplicationManagementLarkSelfBuiltApplicationConfigurationInterfaceApiResponseProcessor();
    }

    /**
     * Change the event configuration of an application instance
     * Update Event Configuration
     * @param feishuAppEventConfigRo
     * @param appInstanceId Application instance ID
     */
    public eventConfigWithHttpInfo(feishuAppEventConfigRo: FeishuAppEventConfigRo, appInstanceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAppInstance>> {
        const requestContextPromise = this.requestFactory.eventConfig(feishuAppEventConfigRo, appInstanceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.eventConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * Change the event configuration of an application instance
     * Update Event Configuration
     * @param feishuAppEventConfigRo
     * @param appInstanceId Application instance ID
     */
    public eventConfig(feishuAppEventConfigRo: FeishuAppEventConfigRo, appInstanceId: string, _options?: Configuration): Observable<ResponseDataAppInstance> {
        return this.eventConfigWithHttpInfo(feishuAppEventConfigRo, appInstanceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAppInstance>) => apiResponse.data));
    }

    /**
     * Update the basic configuration of the application instance
     * Update basic configuration
     * @param feishuAppConfigRo
     * @param appInstanceId Application instance ID
     */
    public initConfigWithHttpInfo(feishuAppConfigRo: FeishuAppConfigRo, appInstanceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAppInstance>> {
        const requestContextPromise = this.requestFactory.initConfig(feishuAppConfigRo, appInstanceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.initConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update the basic configuration of the application instance
     * Update basic configuration
     * @param feishuAppConfigRo
     * @param appInstanceId Application instance ID
     */
    public initConfig(feishuAppConfigRo: FeishuAppConfigRo, appInstanceId: string, _options?: Configuration): Observable<ResponseDataAppInstance> {
        return this.initConfigWithHttpInfo(feishuAppConfigRo, appInstanceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAppInstance>) => apiResponse.data));
    }

}

import { ApplicationMarketApplicationAPIApiRequestFactory, ApplicationMarketApplicationAPIApiResponseProcessor} from "../apis/ApplicationMarketApplicationAPIApi";
export class ObservableApplicationMarketApplicationAPIApi {
    private requestFactory: ApplicationMarketApplicationAPIApiRequestFactory;
    private responseProcessor: ApplicationMarketApplicationAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplicationMarketApplicationAPIApiRequestFactory,
        responseProcessor?: ApplicationMarketApplicationAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ApplicationMarketApplicationAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ApplicationMarketApplicationAPIApiResponseProcessor();
    }

    /**
     * Block Application
     * @param spaceId
     * @param appId
     */
    public blockSpaceAppWithHttpInfo(spaceId: string, appId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.blockSpaceApp(spaceId, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.blockSpaceAppWithHttpInfo(rsp)));
            }));
    }

    /**
     * Block Application
     * @param spaceId
     * @param appId
     */
    public blockSpaceApp(spaceId: string, appId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.blockSpaceAppWithHttpInfo(spaceId, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Query Built-in Integrated Applications
     * @param spaceId
     */
    public getSpaceAppListWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListMarketplaceSpaceAppVo>> {
        const requestContextPromise = this.requestFactory.getSpaceAppList(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceAppListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query Built-in Integrated Applications
     * @param spaceId
     */
    public getSpaceAppList(spaceId: string, _options?: Configuration): Observable<ResponseDataListMarketplaceSpaceAppVo> {
        return this.getSpaceAppListWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListMarketplaceSpaceAppVo>) => apiResponse.data));
    }

    /**
     * Open Application
     * @param spaceId
     * @param appId
     */
    public openSpaceAppWithHttpInfo(spaceId: string, appId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.openSpaceApp(spaceId, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.openSpaceAppWithHttpInfo(rsp)));
            }));
    }

    /**
     * Open Application
     * @param spaceId
     * @param appId
     */
    public openSpaceApp(spaceId: string, appId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.openSpaceAppWithHttpInfo(spaceId, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { Auth0ControllerApiRequestFactory, Auth0ControllerApiResponseProcessor} from "../apis/Auth0ControllerApi";
export class ObservableAuth0ControllerApi {
    private requestFactory: Auth0ControllerApiRequestFactory;
    private responseProcessor: Auth0ControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: Auth0ControllerApiRequestFactory,
        responseProcessor?: Auth0ControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new Auth0ControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new Auth0ControllerApiResponseProcessor();
    }

    /**
     * @param code
     * @param error
     * @param errorDescription
     */
    public callback4WithHttpInfo(code?: string, error?: string, errorDescription?: string, _options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.callback4(code, error, errorDescription, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callback4WithHttpInfo(rsp)));
            }));
    }

    /**
     * @param code
     * @param error
     * @param errorDescription
     */
    public callback4(code?: string, error?: string, errorDescription?: string, _options?: Configuration): Observable<RedirectView> {
        return this.callback4WithHttpInfo(code, error, errorDescription, _options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

    /**
     * @param email
     * @param success
     */
    public invitationCallbackWithHttpInfo(email: string, success: boolean, _options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.invitationCallback(email, success, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.invitationCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param email
     * @param success
     */
    public invitationCallback(email: string, success: boolean, _options?: Configuration): Observable<RedirectView> {
        return this.invitationCallbackWithHttpInfo(email, success, _options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

    /**
     * @param message
     */
    public login3WithHttpInfo(message?: string, _options?: Configuration): Observable<HttpInfo<RedirectView>> {
        const requestContextPromise = this.requestFactory.login3(message, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.login3WithHttpInfo(rsp)));
            }));
    }

    /**
     * @param message
     */
    public login3(message?: string, _options?: Configuration): Observable<RedirectView> {
        return this.login3WithHttpInfo(message, _options).pipe(map((apiResponse: HttpInfo<RedirectView>) => apiResponse.data));
    }

}

import { AuthorizationRelatedInterfaceApiRequestFactory, AuthorizationRelatedInterfaceApiResponseProcessor} from "../apis/AuthorizationRelatedInterfaceApi";
export class ObservableAuthorizationRelatedInterfaceApi {
    private requestFactory: AuthorizationRelatedInterfaceApiRequestFactory;
    private responseProcessor: AuthorizationRelatedInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AuthorizationRelatedInterfaceApiRequestFactory,
        responseProcessor?: AuthorizationRelatedInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AuthorizationRelatedInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AuthorizationRelatedInterfaceApiResponseProcessor();
    }

    /**
     * description:verifyType，available values: password sms_code email_code
     * login
     * @param loginRo
     */
    public loginWithHttpInfo(loginRo: LoginRo, _options?: Configuration): Observable<HttpInfo<ResponseDataLoginResultVO>> {
        const requestContextPromise = this.requestFactory.login(loginRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.loginWithHttpInfo(rsp)));
            }));
    }

    /**
     * description:verifyType，available values: password sms_code email_code
     * login
     * @param loginRo
     */
    public login(loginRo: LoginRo, _options?: Configuration): Observable<ResponseDataLoginResultVO> {
        return this.loginWithHttpInfo(loginRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataLoginResultVO>) => apiResponse.data));
    }

    /**
     * log out of current user
     * sign out
     */
    public logoutWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataLogoutVO>> {
        const requestContextPromise = this.requestFactory.logout(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.logoutWithHttpInfo(rsp)));
            }));
    }

    /**
     * log out of current user
     * sign out
     */
    public logout(_options?: Configuration): Observable<ResponseDataLogoutVO> {
        return this.logoutWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataLogoutVO>) => apiResponse.data));
    }

    /**
     * log out of current user
     * sign out
     */
    public logout1WithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataLogoutVO>> {
        const requestContextPromise = this.requestFactory.logout1(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.logout1WithHttpInfo(rsp)));
            }));
    }

    /**
     * log out of current user
     * sign out
     */
    public logout1(_options?: Configuration): Observable<ResponseDataLogoutVO> {
        return this.logout1WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataLogoutVO>) => apiResponse.data));
    }

    /**
     * serving for community edition
     * register
     * @param registerRO
     */
    public registerWithHttpInfo(registerRO: RegisterRO, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.register(registerRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.registerWithHttpInfo(rsp)));
            }));
    }

    /**
     * serving for community edition
     * register
     * @param registerRO
     */
    public register(registerRO: RegisterRO, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.registerWithHttpInfo(registerRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AutoNaviInterfaceApiRequestFactory, AutoNaviInterfaceApiResponseProcessor} from "../apis/AutoNaviInterfaceApi";
export class ObservableAutoNaviInterfaceApi {
    private requestFactory: AutoNaviInterfaceApiRequestFactory;
    private responseProcessor: AutoNaviInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutoNaviInterfaceApiRequestFactory,
        responseProcessor?: AutoNaviInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutoNaviInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutoNaviInterfaceApiResponseProcessor();
    }

    /**
     */
    public proxyWithHttpInfo(_options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.proxy(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.proxyWithHttpInfo(rsp)));
            }));
    }

    /**
     */
    public proxy(_options?: Configuration): Observable<void> {
        return this.proxyWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}

import { AutomationApiRequestFactory, AutomationApiResponseProcessor} from "../apis/AutomationApi";
export class ObservableAutomationApi {
    private requestFactory: AutomationApiRequestFactory;
    private responseProcessor: AutomationApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutomationApiRequestFactory,
        responseProcessor?: AutomationApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutomationApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutomationApiResponseProcessor();
    }

    /**
     * Create automation action
     * @param createActionRO
     * @param resourceId node id
     * @param shareId share id
     */
    public createActionWithHttpInfo(createActionRO: CreateActionRO, resourceId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListActionVO>> {
        const requestContextPromise = this.requestFactory.createAction(createActionRO, resourceId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createActionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create automation action
     * @param createActionRO
     * @param resourceId node id
     * @param shareId share id
     */
    public createAction(createActionRO: CreateActionRO, resourceId: string, shareId: string, _options?: Configuration): Observable<ResponseDataListActionVO> {
        return this.createActionWithHttpInfo(createActionRO, resourceId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListActionVO>) => apiResponse.data));
    }

    /**
     * Create automation robot trigger
     * @param createTriggerRO
     * @param resourceId node id
     * @param shareId share id
     */
    public createTriggerWithHttpInfo(createTriggerRO: CreateTriggerRO, resourceId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTriggerVO>> {
        const requestContextPromise = this.requestFactory.createTrigger(createTriggerRO, resourceId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createTriggerWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create automation robot trigger
     * @param createTriggerRO
     * @param resourceId node id
     * @param shareId share id
     */
    public createTrigger(createTriggerRO: CreateTriggerRO, resourceId: string, shareId: string, _options?: Configuration): Observable<ResponseDataListTriggerVO> {
        return this.createTriggerWithHttpInfo(createTriggerRO, resourceId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTriggerVO>) => apiResponse.data));
    }

    /**
     * Delete automation action
     * @param resourceId node id
     * @param actionId action id
     * @param robotId robot id
     */
    public deleteActionWithHttpInfo(resourceId: string, actionId: string, robotId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteAction(resourceId, actionId, robotId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteActionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete automation action
     * @param resourceId node id
     * @param actionId action id
     * @param robotId robot id
     */
    public deleteAction(resourceId: string, actionId: string, robotId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteActionWithHttpInfo(resourceId, actionId, robotId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete automation robot
     * @param resourceId node id
     * @param robotId robot id
     */
    public deleteRobotWithHttpInfo(resourceId: string, robotId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteRobot(resourceId, robotId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteRobotWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete automation robot
     * @param resourceId node id
     * @param robotId robot id
     */
    public deleteRobot(resourceId: string, robotId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteRobotWithHttpInfo(resourceId, robotId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete automation trigger
     * @param resourceId node id
     * @param triggerId trigger id
     * @param robotId robot id
     */
    public deleteTriggerWithHttpInfo(resourceId: string, triggerId: string, robotId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteTrigger(resourceId, triggerId, robotId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteTriggerWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete automation trigger
     * @param resourceId node id
     * @param triggerId trigger id
     * @param robotId robot id
     */
    public deleteTrigger(resourceId: string, triggerId: string, robotId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteTriggerWithHttpInfo(resourceId, triggerId, robotId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get node automation detail.
     * @param resourceId node id
     * @param robotId robot id
     * @param shareId share id
     */
    public getNodeRobotWithHttpInfo(resourceId: string, robotId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAutomationVO>> {
        const requestContextPromise = this.requestFactory.getNodeRobot(resourceId, robotId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getNodeRobotWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get node automation detail.
     * @param resourceId node id
     * @param robotId robot id
     * @param shareId share id
     */
    public getNodeRobot(resourceId: string, robotId: string, shareId: string, _options?: Configuration): Observable<ResponseDataAutomationVO> {
        return this.getNodeRobotWithHttpInfo(resourceId, robotId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAutomationVO>) => apiResponse.data));
    }

    /**
     * Get automation robots
     * @param resourceId node id
     * @param shareId share id
     */
    public getResourceRobotsWithHttpInfo(resourceId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListAutomationSimpleVO>> {
        const requestContextPromise = this.requestFactory.getResourceRobots(resourceId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getResourceRobotsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get automation robots
     * @param resourceId node id
     * @param shareId share id
     */
    public getResourceRobots(resourceId: string, shareId: string, _options?: Configuration): Observable<ResponseDataListAutomationSimpleVO> {
        return this.getResourceRobotsWithHttpInfo(resourceId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAutomationSimpleVO>) => apiResponse.data));
    }

    /**
     * Get automation run history
     * @param pageNum Current page number, default: 1
     * @param shareId share id
     * @param resourceId node id
     * @param robotId robot id
     * @param pageSize Page size, default: 20
     */
    public getRunHistoryWithHttpInfo(pageNum: number, shareId: string, resourceId: string, robotId: string, pageSize?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListAutomationTaskSimpleVO>> {
        const requestContextPromise = this.requestFactory.getRunHistory(pageNum, shareId, resourceId, robotId, pageSize, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRunHistoryWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get automation run history
     * @param pageNum Current page number, default: 1
     * @param shareId share id
     * @param resourceId node id
     * @param robotId robot id
     * @param pageSize Page size, default: 20
     */
    public getRunHistory(pageNum: number, shareId: string, resourceId: string, robotId: string, pageSize?: number, _options?: Configuration): Observable<ResponseDataListAutomationTaskSimpleVO> {
        return this.getRunHistoryWithHttpInfo(pageNum, shareId, resourceId, robotId, pageSize, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAutomationTaskSimpleVO>) => apiResponse.data));
    }

    /**
     * Update automation info.
     * @param updateRobotRO
     * @param resourceId node id
     * @param robotId robot id
     * @param shareId share id
     */
    public modifyRobotWithHttpInfo(updateRobotRO: UpdateRobotRO, resourceId: string, robotId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.modifyRobot(updateRobotRO, resourceId, robotId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.modifyRobotWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update automation info.
     * @param updateRobotRO
     * @param resourceId node id
     * @param robotId robot id
     * @param shareId share id
     */
    public modifyRobot(updateRobotRO: UpdateRobotRO, resourceId: string, robotId: string, shareId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.modifyRobotWithHttpInfo(updateRobotRO, resourceId, robotId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update automation action
     * @param updateActionRO
     * @param resourceId node id
     * @param actionId action id
     * @param shareId share id
     */
    public updateActionWithHttpInfo(updateActionRO: UpdateActionRO, resourceId: string, actionId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListActionVO>> {
        const requestContextPromise = this.requestFactory.updateAction(updateActionRO, resourceId, actionId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateActionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update automation action
     * @param updateActionRO
     * @param resourceId node id
     * @param actionId action id
     * @param shareId share id
     */
    public updateAction(updateActionRO: UpdateActionRO, resourceId: string, actionId: string, shareId: string, _options?: Configuration): Observable<ResponseDataListActionVO> {
        return this.updateActionWithHttpInfo(updateActionRO, resourceId, actionId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListActionVO>) => apiResponse.data));
    }

    /**
     * Update automation robot trigger
     * @param updateTriggerRO
     * @param resourceId node id
     * @param triggerId trigger id
     * @param shareId share id
     */
    public updateTriggerWithHttpInfo(updateTriggerRO: UpdateTriggerRO, resourceId: string, triggerId: string, shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTriggerVO>> {
        const requestContextPromise = this.requestFactory.updateTrigger(updateTriggerRO, resourceId, triggerId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateTriggerWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update automation robot trigger
     * @param updateTriggerRO
     * @param resourceId node id
     * @param triggerId trigger id
     * @param shareId share id
     */
    public updateTrigger(updateTriggerRO: UpdateTriggerRO, resourceId: string, triggerId: string, shareId: string, _options?: Configuration): Observable<ResponseDataListTriggerVO> {
        return this.updateTriggerWithHttpInfo(updateTriggerRO, resourceId, triggerId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTriggerVO>) => apiResponse.data));
    }

}

import { AutomationAPIApiRequestFactory, AutomationAPIApiResponseProcessor} from "../apis/AutomationAPIApi";
export class ObservableAutomationAPIApi {
    private requestFactory: AutomationAPIApiRequestFactory;
    private responseProcessor: AutomationAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutomationAPIApiRequestFactory,
        responseProcessor?: AutomationAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutomationAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutomationAPIApiResponseProcessor();
    }

    /**
     * Create Service
     * @param automationServiceCreateRO
     */
    public create9WithHttpInfo(automationServiceCreateRO: AutomationServiceCreateRO, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.create9(automationServiceCreateRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create9WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Service
     * @param automationServiceCreateRO
     */
    public create9(automationServiceCreateRO: AutomationServiceCreateRO, _options?: Configuration): Observable<ResponseDataString> {
        return this.create9WithHttpInfo(automationServiceCreateRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Delete Service
     * @param serviceId
     */
    public delete12WithHttpInfo(serviceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete12(serviceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete12WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Service
     * @param serviceId
     */
    public delete12(serviceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete12WithHttpInfo(serviceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit Service
     * @param automationServiceEditRO
     * @param serviceId
     */
    public edit4WithHttpInfo(automationServiceEditRO: AutomationServiceEditRO, serviceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit4(automationServiceEditRO, serviceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.edit4WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit Service
     * @param automationServiceEditRO
     * @param serviceId
     */
    public edit4(automationServiceEditRO: AutomationServiceEditRO, serviceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.edit4WithHttpInfo(automationServiceEditRO, serviceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AutomationActionTypeAPIApiRequestFactory, AutomationActionTypeAPIApiResponseProcessor} from "../apis/AutomationActionTypeAPIApi";
export class ObservableAutomationActionTypeAPIApi {
    private requestFactory: AutomationActionTypeAPIApiRequestFactory;
    private responseProcessor: AutomationActionTypeAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutomationActionTypeAPIApiRequestFactory,
        responseProcessor?: AutomationActionTypeAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutomationActionTypeAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutomationActionTypeAPIApiResponseProcessor();
    }

    /**
     * Create Action Type
     * @param actionTypeCreateRO
     */
    public create10WithHttpInfo(actionTypeCreateRO: ActionTypeCreateRO, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.create10(actionTypeCreateRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create10WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Action Type
     * @param actionTypeCreateRO
     */
    public create10(actionTypeCreateRO: ActionTypeCreateRO, _options?: Configuration): Observable<ResponseDataString> {
        return this.create10WithHttpInfo(actionTypeCreateRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Delete Action Type
     * @param actionTypeId
     */
    public delete13WithHttpInfo(actionTypeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete13(actionTypeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete13WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Action Type
     * @param actionTypeId
     */
    public delete13(actionTypeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete13WithHttpInfo(actionTypeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit Action Type
     * @param actionTypeEditRO
     * @param actionTypeId
     */
    public edit5WithHttpInfo(actionTypeEditRO: ActionTypeEditRO, actionTypeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit5(actionTypeEditRO, actionTypeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.edit5WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit Action Type
     * @param actionTypeEditRO
     * @param actionTypeId
     */
    public edit5(actionTypeEditRO: ActionTypeEditRO, actionTypeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.edit5WithHttpInfo(actionTypeEditRO, actionTypeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { AutomationOpenApiControllerApiRequestFactory, AutomationOpenApiControllerApiResponseProcessor} from "../apis/AutomationOpenApiControllerApi";
export class ObservableAutomationOpenApiControllerApi {
    private requestFactory: AutomationOpenApiControllerApiRequestFactory;
    private responseProcessor: AutomationOpenApiControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutomationOpenApiControllerApiRequestFactory,
        responseProcessor?: AutomationOpenApiControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutomationOpenApiControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutomationOpenApiControllerApiResponseProcessor();
    }

    /**
     * @param automationApiTriggerCreateRo
     * @param xServiceToken
     */
    public createOrUpdateTriggerWithHttpInfo(automationApiTriggerCreateRo: AutomationApiTriggerCreateRo, xServiceToken?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAutomationTriggerCreateVo>> {
        const requestContextPromise = this.requestFactory.createOrUpdateTrigger(automationApiTriggerCreateRo, xServiceToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createOrUpdateTriggerWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param automationApiTriggerCreateRo
     * @param xServiceToken
     */
    public createOrUpdateTrigger(automationApiTriggerCreateRo: AutomationApiTriggerCreateRo, xServiceToken?: string, _options?: Configuration): Observable<ResponseDataAutomationTriggerCreateVo> {
        return this.createOrUpdateTriggerWithHttpInfo(automationApiTriggerCreateRo, xServiceToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAutomationTriggerCreateVo>) => apiResponse.data));
    }

    /**
     * @param datasheetId
     * @param robotIds
     */
    public deleteTrigger1WithHttpInfo(datasheetId: string, robotIds: Array<string>, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.deleteTrigger1(datasheetId, robotIds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteTrigger1WithHttpInfo(rsp)));
            }));
    }

    /**
     * @param datasheetId
     * @param robotIds
     */
    public deleteTrigger1(datasheetId: string, robotIds: Array<string>, _options?: Configuration): Observable<ResponseDataString> {
        return this.deleteTrigger1WithHttpInfo(datasheetId, robotIds, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { AutomationTriggerTypeAPIApiRequestFactory, AutomationTriggerTypeAPIApiResponseProcessor} from "../apis/AutomationTriggerTypeAPIApi";
export class ObservableAutomationTriggerTypeAPIApi {
    private requestFactory: AutomationTriggerTypeAPIApiRequestFactory;
    private responseProcessor: AutomationTriggerTypeAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AutomationTriggerTypeAPIApiRequestFactory,
        responseProcessor?: AutomationTriggerTypeAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AutomationTriggerTypeAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AutomationTriggerTypeAPIApiResponseProcessor();
    }

    /**
     * Create Trigger Type
     * @param triggerTypeCreateRO
     */
    public create8WithHttpInfo(triggerTypeCreateRO: TriggerTypeCreateRO, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.create8(triggerTypeCreateRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create8WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Trigger Type
     * @param triggerTypeCreateRO
     */
    public create8(triggerTypeCreateRO: TriggerTypeCreateRO, _options?: Configuration): Observable<ResponseDataString> {
        return this.create8WithHttpInfo(triggerTypeCreateRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Delete Trigger Type
     * @param triggerTypeId
     */
    public delete11WithHttpInfo(triggerTypeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete11(triggerTypeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete11WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Trigger Type
     * @param triggerTypeId
     */
    public delete11(triggerTypeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete11WithHttpInfo(triggerTypeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit Trigger Type
     * @param triggerTypeEditRO
     * @param triggerTypeId
     */
    public edit3WithHttpInfo(triggerTypeEditRO: TriggerTypeEditRO, triggerTypeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit3(triggerTypeEditRO, triggerTypeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.edit3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit Trigger Type
     * @param triggerTypeEditRO
     * @param triggerTypeId
     */
    public edit3(triggerTypeEditRO: TriggerTypeEditRO, triggerTypeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.edit3WithHttpInfo(triggerTypeEditRO, triggerTypeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { BasicModuleAccessoryCallbackInterfaceApiRequestFactory, BasicModuleAccessoryCallbackInterfaceApiResponseProcessor} from "../apis/BasicModuleAccessoryCallbackInterfaceApi";
export class ObservableBasicModuleAccessoryCallbackInterfaceApi {
    private requestFactory: BasicModuleAccessoryCallbackInterfaceApiRequestFactory;
    private responseProcessor: BasicModuleAccessoryCallbackInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BasicModuleAccessoryCallbackInterfaceApiRequestFactory,
        responseProcessor?: BasicModuleAccessoryCallbackInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BasicModuleAccessoryCallbackInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BasicModuleAccessoryCallbackInterfaceApiResponseProcessor();
    }

    /**
     * After S3 completes the client upload, it actively reaches the notification server
     * Resource upload completion notification callback
     * @param assetUploadNotifyRO
     */
    public notifyCallbackWithHttpInfo(assetUploadNotifyRO: AssetUploadNotifyRO, _options?: Configuration): Observable<HttpInfo<ResponseDataListAssetUploadResult>> {
        const requestContextPromise = this.requestFactory.notifyCallback(assetUploadNotifyRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.notifyCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * After S3 completes the client upload, it actively reaches the notification server
     * Resource upload completion notification callback
     * @param assetUploadNotifyRO
     */
    public notifyCallback(assetUploadNotifyRO: AssetUploadNotifyRO, _options?: Configuration): Observable<ResponseDataListAssetUploadResult> {
        return this.notifyCallbackWithHttpInfo(assetUploadNotifyRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAssetUploadResult>) => apiResponse.data));
    }

    /**
     * widget upload callback
     * @param widgetUploadNotifyRO
     */
    public widgetCallbackWithHttpInfo(widgetUploadNotifyRO: WidgetUploadNotifyRO, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.widgetCallback(widgetUploadNotifyRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.widgetCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget upload callback
     * @param widgetUploadNotifyRO
     */
    public widgetCallback(widgetUploadNotifyRO: WidgetUploadNotifyRO, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.widgetCallbackWithHttpInfo(widgetUploadNotifyRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { BasicModuleAttachmentInterfaceApiRequestFactory, BasicModuleAttachmentInterfaceApiResponseProcessor} from "../apis/BasicModuleAttachmentInterfaceApi";
export class ObservableBasicModuleAttachmentInterfaceApi {
    private requestFactory: BasicModuleAttachmentInterfaceApiRequestFactory;
    private responseProcessor: BasicModuleAttachmentInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BasicModuleAttachmentInterfaceApiRequestFactory,
        responseProcessor?: BasicModuleAttachmentInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BasicModuleAttachmentInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BasicModuleAttachmentInterfaceApiResponseProcessor();
    }

    /**
     * The same attachment needs to pass the token repeatedly
     * Changes in the number of references to space attachment resources
     * @param spaceAssetOpRo
     */
    public citeWithHttpInfo(spaceAssetOpRo: SpaceAssetOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.cite(spaceAssetOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.citeWithHttpInfo(rsp)));
            }));
    }

    /**
     * The same attachment needs to pass the token repeatedly
     * Changes in the number of references to space attachment resources
     * @param spaceAssetOpRo
     */
    public cite(spaceAssetOpRo: SpaceAssetOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.citeWithHttpInfo(spaceAssetOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Paging query pictures that need manual review
     * @param page
     * @param pageObjectParams Page params
     */
    public readReviewsWithHttpInfo(page: Page, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoAssetsAuditVo>> {
        const requestContextPromise = this.requestFactory.readReviews(page, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readReviewsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Paging query pictures that need manual review
     * @param page
     * @param pageObjectParams Page params
     */
    public readReviews(page: Page, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoAssetsAuditVo> {
        return this.readReviewsWithHttpInfo(page, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoAssetsAuditVo>) => apiResponse.data));
    }

    /**
     * Submit the image review results, enter the reviewer\'s name when submitting
     * Submit image review results
     * @param assetsAuditRo
     */
    public submitAuditResultWithHttpInfo(assetsAuditRo: AssetsAuditRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.submitAuditResult(assetsAuditRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.submitAuditResultWithHttpInfo(rsp)));
            }));
    }

    /**
     * Submit the image review results, enter the reviewer\'s name when submitting
     * Submit image review results
     * @param assetsAuditRo
     */
    public submitAuditResult(assetsAuditRo: AssetsAuditRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.submitAuditResultWithHttpInfo(assetsAuditRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Upload resource files, any file type is unlimited
     * Upload resources
     * @param attachOpRo
     */
    public uploadWithHttpInfo(attachOpRo?: AttachOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataAssetUploadResult>> {
        const requestContextPromise = this.requestFactory.upload(attachOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.uploadWithHttpInfo(rsp)));
            }));
    }

    /**
     * Upload resource files, any file type is unlimited
     * Upload resources
     * @param attachOpRo
     */
    public upload(attachOpRo?: AttachOpRo, _options?: Configuration): Observable<ResponseDataAssetUploadResult> {
        return this.uploadWithHttpInfo(attachOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAssetUploadResult>) => apiResponse.data));
    }

    /**
     * Image URL upload interface
     * @param attachUrlOpRo
     */
    public urlUploadWithHttpInfo(attachUrlOpRo?: AttachUrlOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataAssetUploadResult>> {
        const requestContextPromise = this.requestFactory.urlUpload(attachUrlOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.urlUploadWithHttpInfo(rsp)));
            }));
    }

    /**
     * Image URL upload interface
     * @param attachUrlOpRo
     */
    public urlUpload(attachUrlOpRo?: AttachUrlOpRo, _options?: Configuration): Observable<ResponseDataAssetUploadResult> {
        return this.urlUploadWithHttpInfo(attachUrlOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAssetUploadResult>) => apiResponse.data));
    }

}

import { BasicModuleVerifyActionModuleInterfaceApiRequestFactory, BasicModuleVerifyActionModuleInterfaceApiResponseProcessor} from "../apis/BasicModuleVerifyActionModuleInterfaceApi";
export class ObservableBasicModuleVerifyActionModuleInterfaceApi {
    private requestFactory: BasicModuleVerifyActionModuleInterfaceApiRequestFactory;
    private responseProcessor: BasicModuleVerifyActionModuleInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BasicModuleVerifyActionModuleInterfaceApiRequestFactory,
        responseProcessor?: BasicModuleVerifyActionModuleInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BasicModuleVerifyActionModuleInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BasicModuleVerifyActionModuleInterfaceApiResponseProcessor();
    }

    /**
     * Invitation link token verification, the relevant invitation information can be obtained after the verification is successful
     * Invitation temporary code verification
     * @param inviteValidRo
     */
    public inviteTokenValidWithHttpInfo(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<HttpInfo<ResponseDataInviteInfoVo>> {
        const requestContextPromise = this.requestFactory.inviteTokenValid(inviteValidRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inviteTokenValidWithHttpInfo(rsp)));
            }));
    }

    /**
     * Invitation link token verification, the relevant invitation information can be obtained after the verification is successful
     * Invitation temporary code verification
     * @param inviteValidRo
     */
    public inviteTokenValid(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<ResponseDataInviteInfoVo> {
        return this.inviteTokenValidWithHttpInfo(inviteValidRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInviteInfoVo>) => apiResponse.data));
    }

    /**
     * Email verification code; 1:Email binding, 2: Email registration, 3: General verification
     * Send email verification code
     * @param emailOpRo
     */
    public mailWithHttpInfo(emailOpRo: EmailOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.mail(emailOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.mailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Email verification code; 1:Email binding, 2: Email registration, 3: General verification
     * Send email verification code
     * @param emailOpRo
     */
    public mail(emailOpRo: EmailOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.mailWithHttpInfo(emailOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * SMS type; 1: Registration, 2:Login, 3: Modify login password, 4: DingTalk binding, 5: Bind mobile phone, 6: (Remove replacement) mobile phone binding 7: Modify mailbox binding, 8: Delete space, 9: Replace main administrator 10: General verification, 11: Change developer configuration, 12: Bind third-party platform account
     * Send SMS verification code
     * @param smsOpRo
     */
    public sendWithHttpInfo(smsOpRo: SmsOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.send(smsOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.sendWithHttpInfo(rsp)));
            }));
    }

    /**
     * SMS type; 1: Registration, 2:Login, 3: Modify login password, 4: DingTalk binding, 5: Bind mobile phone, 6: (Remove replacement) mobile phone binding 7: Modify mailbox binding, 8: Delete space, 9: Replace main administrator 10: General verification, 11: Change developer configuration, 12: Bind third-party platform account
     * Send SMS verification code
     * @param smsOpRo
     */
    public send(smsOpRo: SmsOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.sendWithHttpInfo(smsOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Usage scenario: Verify identity before changing email address when no mobile phone, change the main administrator
     * Email verification code verification
     * @param emailCodeValidateRo
     */
    public validateEmailWithHttpInfo(emailCodeValidateRo: EmailCodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.validateEmail(emailCodeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validateEmailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Usage scenario: Verify identity before changing email address when no mobile phone, change the main administrator
     * Email verification code verification
     * @param emailCodeValidateRo
     */
    public validateEmail(emailCodeValidateRo: EmailCodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.validateEmailWithHttpInfo(emailCodeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Usage scenarios: DingTalk binding, identity verification before changing the mobile phone mailbox, changing the main administrator
     * Mobile verification code verification
     * @param smsCodeValidateRo
     */
    public verifyPhone1WithHttpInfo(smsCodeValidateRo: SmsCodeValidateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.verifyPhone1(smsCodeValidateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.verifyPhone1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Usage scenarios: DingTalk binding, identity verification before changing the mobile phone mailbox, changing the main administrator
     * Mobile verification code verification
     * @param smsCodeValidateRo
     */
    public verifyPhone1(smsCodeValidateRo: SmsCodeValidateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.verifyPhone1WithHttpInfo(smsCodeValidateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { BasicsAttachmentUploadTokenInterfaceApiRequestFactory, BasicsAttachmentUploadTokenInterfaceApiResponseProcessor} from "../apis/BasicsAttachmentUploadTokenInterfaceApi";
export class ObservableBasicsAttachmentUploadTokenInterfaceApi {
    private requestFactory: BasicsAttachmentUploadTokenInterfaceApiRequestFactory;
    private responseProcessor: BasicsAttachmentUploadTokenInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BasicsAttachmentUploadTokenInterfaceApiRequestFactory,
        responseProcessor?: BasicsAttachmentUploadTokenInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BasicsAttachmentUploadTokenInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BasicsAttachmentUploadTokenInterfaceApiResponseProcessor();
    }

    /**
     * Get upload presigned URL
     * @param assetUploadCertificateRO
     */
    public generatePreSignedUrlWithHttpInfo(assetUploadCertificateRO: AssetUploadCertificateRO, _options?: Configuration): Observable<HttpInfo<ResponseDataListAssetUploadCertificateVO>> {
        const requestContextPromise = this.requestFactory.generatePreSignedUrl(assetUploadCertificateRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.generatePreSignedUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get upload presigned URL
     * @param assetUploadCertificateRO
     */
    public generatePreSignedUrl(assetUploadCertificateRO: AssetUploadCertificateRO, _options?: Configuration): Observable<ResponseDataListAssetUploadCertificateVO> {
        return this.generatePreSignedUrlWithHttpInfo(assetUploadCertificateRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAssetUploadCertificateVO>) => apiResponse.data));
    }

    /**
     * Get asset signature url
     * @param token
     */
    public getSignatureUrlWithHttpInfo(token: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.getSignatureUrl(token, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSignatureUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get asset signature url
     * @param token
     */
    public getSignatureUrl(token: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.getSignatureUrlWithHttpInfo(token, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Batch get asset signature url
     * @param assetUrlSignatureRo
     */
    public getSignatureUrlsWithHttpInfo(assetUrlSignatureRo: AssetUrlSignatureRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListAssetUrlSignatureVo>> {
        const requestContextPromise = this.requestFactory.getSignatureUrls(assetUrlSignatureRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSignatureUrlsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch get asset signature url
     * @param assetUrlSignatureRo
     */
    public getSignatureUrls(assetUrlSignatureRo: AssetUrlSignatureRo, _options?: Configuration): Observable<ResponseDataListAssetUrlSignatureVo> {
        return this.getSignatureUrlsWithHttpInfo(assetUrlSignatureRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAssetUrlSignatureVo>) => apiResponse.data));
    }

}

import { BillingCapacityApiApiRequestFactory, BillingCapacityApiApiResponseProcessor} from "../apis/BillingCapacityApiApi";
export class ObservableBillingCapacityApiApi {
    private requestFactory: BillingCapacityApiApiRequestFactory;
    private responseProcessor: BillingCapacityApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BillingCapacityApiApiRequestFactory,
        responseProcessor?: BillingCapacityApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BillingCapacityApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BillingCapacityApiApiResponseProcessor();
    }

    /**
     * Get space capacity detail info
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams paging parameter
     * @param isExpire Whether the attachment capacity has expired. By default, it has not expired
     */
    public getCapacityDetailWithHttpInfo(page: Page, xSpaceId: string, pageObjectParams: string, isExpire?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoSpaceCapacityPageVO>> {
        const requestContextPromise = this.requestFactory.getCapacityDetail(page, xSpaceId, pageObjectParams, isExpire, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCapacityDetailWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get space capacity detail info
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams paging parameter
     * @param isExpire Whether the attachment capacity has expired. By default, it has not expired
     */
    public getCapacityDetail(page: Page, xSpaceId: string, pageObjectParams: string, isExpire?: boolean, _options?: Configuration): Observable<ResponseDataPageInfoSpaceCapacityPageVO> {
        return this.getCapacityDetailWithHttpInfo(page, xSpaceId, pageObjectParams, isExpire, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoSpaceCapacityPageVO>) => apiResponse.data));
    }

}

import { BillingControllerApiRequestFactory, BillingControllerApiResponseProcessor} from "../apis/BillingControllerApi";
export class ObservableBillingControllerApi {
    private requestFactory: BillingControllerApiRequestFactory;
    private responseProcessor: BillingControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BillingControllerApiRequestFactory,
        responseProcessor?: BillingControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BillingControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BillingControllerApiResponseProcessor();
    }

    /**
     * @param spaceId
     * @param subscriptionId
     */
    public cancelSubscriptionWithHttpInfo(spaceId: string, subscriptionId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingSessionVO>> {
        const requestContextPromise = this.requestFactory.cancelSubscription(spaceId, subscriptionId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.cancelSubscriptionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     * @param subscriptionId
     */
    public cancelSubscription(spaceId: string, subscriptionId: string, _options?: Configuration): Observable<ResponseDataBillingSessionVO> {
        return this.cancelSubscriptionWithHttpInfo(spaceId, subscriptionId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingSessionVO>) => apiResponse.data));
    }

    /**
     * @param spaceId
     */
    public changePaymentMethodWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingSessionVO>> {
        const requestContextPromise = this.requestFactory.changePaymentMethod(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.changePaymentMethodWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     */
    public changePaymentMethod(spaceId: string, _options?: Configuration): Observable<ResponseDataBillingSessionVO> {
        return this.changePaymentMethodWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingSessionVO>) => apiResponse.data));
    }

    /**
     * @param spaceId
     */
    public customerPortalUrlWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingSessionVO>> {
        const requestContextPromise = this.requestFactory.customerPortalUrl(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.customerPortalUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     */
    public customerPortalUrl(spaceId: string, _options?: Configuration): Observable<ResponseDataBillingSessionVO> {
        return this.customerPortalUrlWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingSessionVO>) => apiResponse.data));
    }

    /**
     * @param spaceId
     * @param startingAfter
     * @param endingBefore
     * @param limit
     */
    public getInvoicesWithHttpInfo(spaceId: string, startingAfter?: string, endingBefore?: string, limit?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataCustomerInvoices>> {
        const requestContextPromise = this.requestFactory.getInvoices(spaceId, startingAfter, endingBefore, limit, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getInvoicesWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     * @param startingAfter
     * @param endingBefore
     * @param limit
     */
    public getInvoices(spaceId: string, startingAfter?: string, endingBefore?: string, limit?: number, _options?: Configuration): Observable<ResponseDataCustomerInvoices> {
        return this.getInvoicesWithHttpInfo(spaceId, startingAfter, endingBefore, limit, _options).pipe(map((apiResponse: HttpInfo<ResponseDataCustomerInvoices>) => apiResponse.data));
    }

    /**
     * @param spaceId
     */
    public getSubscriptionsWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingInfo>> {
        const requestContextPromise = this.requestFactory.getSubscriptions(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSubscriptionsWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     */
    public getSubscriptions(spaceId: string, _options?: Configuration): Observable<ResponseDataBillingInfo> {
        return this.getSubscriptionsWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingInfo>) => apiResponse.data));
    }

    /**
     * @param spaceId
     * @param subscriptionId
     * @param action
     */
    public updateSubscriptionWithHttpInfo(spaceId: string, subscriptionId: string, action?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingSessionVO>> {
        const requestContextPromise = this.requestFactory.updateSubscription(spaceId, subscriptionId, action, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateSubscriptionWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     * @param subscriptionId
     * @param action
     */
    public updateSubscription(spaceId: string, subscriptionId: string, action?: string, _options?: Configuration): Observable<ResponseDataBillingSessionVO> {
        return this.updateSubscriptionWithHttpInfo(spaceId, subscriptionId, action, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingSessionVO>) => apiResponse.data));
    }

    /**
     * @param spaceId
     * @param subscriptionId
     * @param priceId
     */
    public updateSubscriptionConfirmWithHttpInfo(spaceId: string, subscriptionId: string, priceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBillingSessionVO>> {
        const requestContextPromise = this.requestFactory.updateSubscriptionConfirm(spaceId, subscriptionId, priceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateSubscriptionConfirmWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param spaceId
     * @param subscriptionId
     * @param priceId
     */
    public updateSubscriptionConfirm(spaceId: string, subscriptionId: string, priceId: string, _options?: Configuration): Observable<ResponseDataBillingSessionVO> {
        return this.updateSubscriptionConfirmWithHttpInfo(spaceId, subscriptionId, priceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBillingSessionVO>) => apiResponse.data));
    }

}

import { BillingEventApiApiRequestFactory, BillingEventApiApiResponseProcessor} from "../apis/BillingEventApiApi";
export class ObservableBillingEventApiApi {
    private requestFactory: BillingEventApiApiRequestFactory;
    private responseProcessor: BillingEventApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BillingEventApiApiRequestFactory,
        responseProcessor?: BillingEventApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BillingEventApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BillingEventApiApiResponseProcessor();
    }

    /**
     * fetch event list
     */
    public fetchEventListWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataEventVO>> {
        const requestContextPromise = this.requestFactory.fetchEventList(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.fetchEventListWithHttpInfo(rsp)));
            }));
    }

    /**
     * fetch event list
     */
    public fetchEventList(_options?: Configuration): Observable<ResponseDataEventVO> {
        return this.fetchEventListWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataEventVO>) => apiResponse.data));
    }

}

import { BillingOrderAPIApiRequestFactory, BillingOrderAPIApiResponseProcessor} from "../apis/BillingOrderAPIApi";
export class ObservableBillingOrderAPIApi {
    private requestFactory: BillingOrderAPIApiRequestFactory;
    private responseProcessor: BillingOrderAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BillingOrderAPIApiRequestFactory,
        responseProcessor?: BillingOrderAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BillingOrderAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BillingOrderAPIApiResponseProcessor();
    }

    /**
     * check order paid status when client polling is longer
     * Check Order Payment Status
     * @param orderId order id
     */
    public checkOrderPaidStatusWithHttpInfo(orderId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPaymentOrderStatusVo>> {
        const requestContextPromise = this.requestFactory.checkOrderPaidStatus(orderId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.checkOrderPaidStatusWithHttpInfo(rsp)));
            }));
    }

    /**
     * check order paid status when client polling is longer
     * Check Order Payment Status
     * @param orderId order id
     */
    public checkOrderPaidStatus(orderId: string, _options?: Configuration): Observable<ResponseDataPaymentOrderStatusVo> {
        return this.checkOrderPaidStatusWithHttpInfo(orderId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPaymentOrderStatusVo>) => apiResponse.data));
    }

    /**
     * Create Order
     * @param createOrderRo
     */
    public createOrderWithHttpInfo(createOrderRo: CreateOrderRo, _options?: Configuration): Observable<HttpInfo<ResponseDataOrderDetailVo>> {
        const requestContextPromise = this.requestFactory.createOrder(createOrderRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createOrderWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Order
     * @param createOrderRo
     */
    public createOrder(createOrderRo: CreateOrderRo, _options?: Configuration): Observable<ResponseDataOrderDetailVo> {
        return this.createOrderWithHttpInfo(createOrderRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataOrderDetailVo>) => apiResponse.data));
    }

    /**
     * Create Payment Order
     * @param payOrderRo
     * @param orderId order id
     */
    public createOrderPaymentWithHttpInfo(payOrderRo: PayOrderRo, orderId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataOrderPaymentVo>> {
        const requestContextPromise = this.requestFactory.createOrderPayment(payOrderRo, orderId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createOrderPaymentWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Payment Order
     * @param payOrderRo
     * @param orderId order id
     */
    public createOrderPayment(payOrderRo: PayOrderRo, orderId: string, _options?: Configuration): Observable<ResponseDataOrderPaymentVo> {
        return this.createOrderPaymentWithHttpInfo(payOrderRo, orderId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataOrderPaymentVo>) => apiResponse.data));
    }

    /**
     * fetch order detail by id
     * Get Order Details
     * @param orderId
     */
    public fetchOrderByIdWithHttpInfo(orderId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataOrderDetailVo>> {
        const requestContextPromise = this.requestFactory.fetchOrderById(orderId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.fetchOrderByIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * fetch order detail by id
     * Get Order Details
     * @param orderId
     */
    public fetchOrderById(orderId: string, _options?: Configuration): Observable<ResponseDataOrderDetailVo> {
        return this.fetchOrderByIdWithHttpInfo(orderId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataOrderDetailVo>) => apiResponse.data));
    }

    /**
     * According to the subscription change type (new subscription, subscription renewal, subscription change, subscription cancellation), preview the orders to be generated by the system in the future
     * Test run order
     * @param dryRunOrderArgs
     */
    public generateDryRunOrderWithHttpInfo(dryRunOrderArgs: DryRunOrderArgs, _options?: Configuration): Observable<HttpInfo<ResponseDataOrderPreview>> {
        const requestContextPromise = this.requestFactory.generateDryRunOrder(dryRunOrderArgs, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.generateDryRunOrderWithHttpInfo(rsp)));
            }));
    }

    /**
     * According to the subscription change type (new subscription, subscription renewal, subscription change, subscription cancellation), preview the orders to be generated by the system in the future
     * Test run order
     * @param dryRunOrderArgs
     */
    public generateDryRunOrder(dryRunOrderArgs: DryRunOrderArgs, _options?: Configuration): Observable<ResponseDataOrderPreview> {
        return this.generateDryRunOrderWithHttpInfo(dryRunOrderArgs, _options).pipe(map((apiResponse: HttpInfo<ResponseDataOrderPreview>) => apiResponse.data));
    }

    /**
     * get order paid status when client polling
     * Get Order Payment Status
     * @param orderId order id
     */
    public getOrderPaidStatusWithHttpInfo(orderId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPaymentOrderStatusVo>> {
        const requestContextPromise = this.requestFactory.getOrderPaidStatus(orderId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getOrderPaidStatusWithHttpInfo(rsp)));
            }));
    }

    /**
     * get order paid status when client polling
     * Get Order Payment Status
     * @param orderId order id
     */
    public getOrderPaidStatus(orderId: string, _options?: Configuration): Observable<ResponseDataPaymentOrderStatusVo> {
        return this.getOrderPaidStatusWithHttpInfo(orderId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPaymentOrderStatusVo>) => apiResponse.data));
    }

}

import { CheckoutControllerApiRequestFactory, CheckoutControllerApiResponseProcessor} from "../apis/CheckoutControllerApi";
export class ObservableCheckoutControllerApi {
    private requestFactory: CheckoutControllerApiRequestFactory;
    private responseProcessor: CheckoutControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CheckoutControllerApiRequestFactory,
        responseProcessor?: CheckoutControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CheckoutControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CheckoutControllerApiResponseProcessor();
    }

    /**
     * @param checkoutCreation
     */
    public createCheckoutWithHttpInfo(checkoutCreation: CheckoutCreation, _options?: Configuration): Observable<HttpInfo<CheckoutCreationVO>> {
        const requestContextPromise = this.requestFactory.createCheckout(checkoutCreation, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createCheckoutWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param checkoutCreation
     */
    public createCheckout(checkoutCreation: CheckoutCreation, _options?: Configuration): Observable<CheckoutCreationVO> {
        return this.createCheckoutWithHttpInfo(checkoutCreation, _options).pipe(map((apiResponse: HttpInfo<CheckoutCreationVO>) => apiResponse.data));
    }

}

import { CliAuthorizationAPIApiRequestFactory, CliAuthorizationAPIApiResponseProcessor} from "../apis/CliAuthorizationAPIApi";
export class ObservableCliAuthorizationAPIApi {
    private requestFactory: CliAuthorizationAPIApiRequestFactory;
    private responseProcessor: CliAuthorizationAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CliAuthorizationAPIApiRequestFactory,
        responseProcessor?: CliAuthorizationAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CliAuthorizationAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CliAuthorizationAPIApiResponseProcessor();
    }

    /**
     * Login authorization, using the developer\'s Api Key.
     * @param apiKey
     */
    public authLoginWithHttpInfo(apiKey: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDevelopUserVo>> {
        const requestContextPromise = this.requestFactory.authLogin(apiKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.authLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Login authorization, using the developer\'s Api Key.
     * @param apiKey
     */
    public authLogin(apiKey: string, _options?: Configuration): Observable<ResponseDataDevelopUserVo> {
        return this.authLoginWithHttpInfo(apiKey, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDevelopUserVo>) => apiResponse.data));
    }

    /**
     * Query using Graph QL
     * GraphQL Query
     * @param developerToken developer token
     */
    public graphqlWithHttpInfo(developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.graphql(developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.graphqlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query using Graph QL
     * GraphQL Query
     * @param developerToken developer token
     */
    public graphql(developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.graphqlWithHttpInfo(developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Create a new cloud application in the specified space.
     * New Cloud application
     * @param spaceId
     * @param developerToken developer token
     */
    public newAppletWithHttpInfo(spaceId: string, developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.newApplet(spaceId, developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.newAppletWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create a new cloud application in the specified space.
     * New Cloud application
     * @param spaceId
     * @param developerToken developer token
     */
    public newApplet(spaceId: string, developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.newAppletWithHttpInfo(spaceId, developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * The developer token is passed for login. The network verifies whether the token is valid. The user name is returned and cached locally.   Generally speaking, this API is not used by vika-cli, but for Web side web page operations.
     * Create Developer Token
     * @param userSessionToken Normal login Session Token of the user.
     */
    public newTokenWithHttpInfo(userSessionToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDeveloperVo>> {
        const requestContextPromise = this.requestFactory.newToken(userSessionToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.newTokenWithHttpInfo(rsp)));
            }));
    }

    /**
     * The developer token is passed for login. The network verifies whether the token is valid. The user name is returned and cached locally.   Generally speaking, this API is not used by vika-cli, but for Web side web page operations.
     * Create Developer Token
     * @param userSessionToken Normal login Session Token of the user.
     */
    public newToken(userSessionToken: string, _options?: Configuration): Observable<ResponseDataDeveloperVo> {
        return this.newTokenWithHttpInfo(userSessionToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDeveloperVo>) => apiResponse.data));
    }

    /**
     * Creates a cloud hook in the specified applet.
     * Creating a Cloud Hook
     * @param developerToken developer token
     */
    public newWebhookWithHttpInfo(developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.newWebhook(developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.newWebhookWithHttpInfo(rsp)));
            }));
    }

    /**
     * Creates a cloud hook in the specified applet.
     * Creating a Cloud Hook
     * @param developerToken developer token
     */
    public newWebhook(developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.newWebhookWithHttpInfo(developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Specifies that the applet is published to the marketplace.
     * Publish cloud applications
     * @param developerToken developer token
     */
    public publishAppletWithHttpInfo(developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.publishApplet(developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.publishAppletWithHttpInfo(rsp)));
            }));
    }

    /**
     * Specifies that the applet is published to the marketplace.
     * Publish cloud applications
     * @param developerToken developer token
     */
    public publishApplet(developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.publishAppletWithHttpInfo(developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Lists all cloud applications in the specified space.
     * Listing cloud applications
     * @param spaceId
     * @param developerToken developer token
     * @param xSpaceId space id
     */
    public showAppletsWithHttpInfo(spaceId: string, developerToken: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.showApplets(spaceId, developerToken, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showAppletsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Lists all cloud applications in the specified space.
     * Listing cloud applications
     * @param spaceId
     * @param developerToken developer token
     * @param xSpaceId space id
     */
    public showApplets(spaceId: string, developerToken: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.showAppletsWithHttpInfo(spaceId, developerToken, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * List the space owned by the user.
     * space list
     */
    public showSpacesWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListSpaceShowcaseVo>> {
        const requestContextPromise = this.requestFactory.showSpaces(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showSpacesWithHttpInfo(rsp)));
            }));
    }

    /**
     * List the space owned by the user.
     * space list
     */
    public showSpaces(_options?: Configuration): Observable<ResponseDataListSpaceShowcaseVo> {
        return this.showSpacesWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListSpaceShowcaseVo>) => apiResponse.data));
    }

    /**
     * Lists all cloud hooks in the specified applet.
     * Listing cloud hooks
     * @param appletId
     * @param developerToken developer token
     */
    public showWebhooksWithHttpInfo(appletId: string, developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.showWebhooks(appletId, developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showWebhooksWithHttpInfo(rsp)));
            }));
    }

    /**
     * Lists all cloud hooks in the specified applet.
     * Listing cloud hooks
     * @param appletId
     * @param developerToken developer token
     */
    public showWebhooks(appletId: string, developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.showWebhooksWithHttpInfo(appletId, developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Specifies the applet upload plug-in.
     * Upload plug-ins
     * @param developerToken developer token
     */
    public uploadPluginWithHttpInfo(developerToken: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.uploadPlugin(developerToken, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.uploadPluginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Specifies the applet upload plug-in.
     * Upload plug-ins
     * @param developerToken developer token
     */
    public uploadPlugin(developerToken: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.uploadPluginWithHttpInfo(developerToken, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { CliOfficeBanAPIApiRequestFactory, CliOfficeBanAPIApiResponseProcessor} from "../apis/CliOfficeBanAPIApi";
export class ObservableCliOfficeBanAPIApi {
    private requestFactory: CliOfficeBanAPIApiRequestFactory;
    private responseProcessor: CliOfficeBanAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CliOfficeBanAPIApiRequestFactory,
        responseProcessor?: CliOfficeBanAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CliOfficeBanAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CliOfficeBanAPIApiResponseProcessor();
    }

    /**
     * limit function.
     * Ban space
     * @param spaceId
     */
    public banSpaceWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.banSpace(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.banSpaceWithHttpInfo(rsp)));
            }));
    }

    /**
     * limit function.
     * Ban space
     * @param spaceId
     */
    public banSpace(spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.banSpaceWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Restrict login and force logout.
     * Ban account
     * @param userId
     */
    public banUserWithHttpInfo(userId: number, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.banUser(userId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.banUserWithHttpInfo(rsp)));
            }));
    }

    /**
     * Restrict login and force logout.
     * Ban account
     * @param userId
     */
    public banUser(userId: number, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.banUserWithHttpInfo(userId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { CliOfficeGMAPIApiRequestFactory, CliOfficeGMAPIApiResponseProcessor} from "../apis/CliOfficeGMAPIApi";
export class ObservableCliOfficeGMAPIApi {
    private requestFactory: CliOfficeGMAPIApiRequestFactory;
    private responseProcessor: CliOfficeGMAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: CliOfficeGMAPIApiRequestFactory,
        responseProcessor?: CliOfficeGMAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new CliOfficeGMAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new CliOfficeGMAPIApiResponseProcessor();
    }

    /**
     * Activity Integral Reward
     */
    public activityRewardWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.activityReward(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.activityRewardWithHttpInfo(rsp)));
            }));
    }

    /**
     * Activity Integral Reward
     */
    public activityReward(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.activityRewardWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Adding system notification.
     * Create a player notification
     * @param notificationCreateRo
     */
    public addPlayerNotifyWithHttpInfo(notificationCreateRo: NotificationCreateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.addPlayerNotify(notificationCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.addPlayerNotifyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Adding system notification.
     * Create a player notification
     * @param notificationCreateRo
     */
    public addPlayerNotify(notificationCreateRo: NotificationCreateRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.addPlayerNotifyWithHttpInfo(notificationCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Open laboratory feature for applicants
     * @param gmApplyFeatureRo
     */
    public applyLabsFeatureWithHttpInfo(gmApplyFeatureRo: GmApplyFeatureRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.applyLabsFeature(gmApplyFeatureRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.applyLabsFeatureWithHttpInfo(rsp)));
            }));
    }

    /**
     * Open laboratory feature for applicants
     * @param gmApplyFeatureRo
     */
    public applyLabsFeature(gmApplyFeatureRo: GmApplyFeatureRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.applyLabsFeatureWithHttpInfo(gmApplyFeatureRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Specifies the active state of the user
     * @param userActivityAssignRo
     */
    public assignActivityWithHttpInfo(userActivityAssignRo: UserActivityAssignRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.assignActivity(userActivityAssignRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.assignActivityWithHttpInfo(rsp)));
            }));
    }

    /**
     * Specifies the active state of the user
     * @param userActivityAssignRo
     */
    public assignActivity(userActivityAssignRo: UserActivityAssignRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.assignActivityWithHttpInfo(userActivityAssignRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Close paused account
     * @param uuid
     */
    public closeAccountDirectlyWithHttpInfo(uuid: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.closeAccountDirectly(uuid, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.closeAccountDirectlyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Close paused account
     * @param uuid
     */
    public closeAccountDirectly(uuid: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.closeAccountDirectlyWithHttpInfo(uuid, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update Template Center Config
     * @param templateCenterConfigRo
     */
    public configWithHttpInfo(templateCenterConfigRo: TemplateCenterConfigRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.config(templateCenterConfigRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.configWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update Template Center Config
     * @param templateCenterConfigRo
     */
    public config(templateCenterConfigRo: TemplateCenterConfigRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.configWithHttpInfo(templateCenterConfigRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Create laboratory feature
     * @param gmLabsFeatureCreatorRo
     */
    public createLabsFeatureWithHttpInfo(gmLabsFeatureCreatorRo: GmLabsFeatureCreatorRo, _options?: Configuration): Observable<HttpInfo<ResponseDataGmLabFeatureVo>> {
        const requestContextPromise = this.requestFactory.createLabsFeature(gmLabsFeatureCreatorRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createLabsFeatureWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create laboratory feature
     * @param gmLabsFeatureCreatorRo
     */
    public createLabsFeature(gmLabsFeatureCreatorRo: GmLabsFeatureCreatorRo, _options?: Configuration): Observable<ResponseDataGmLabFeatureVo> {
        return this.createLabsFeatureWithHttpInfo(gmLabsFeatureCreatorRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataGmLabFeatureVo>) => apiResponse.data));
    }

    /**
     * create a user by username and password.
     * Create user(Irregular vest number, used for testing)
     * @param hqAddUserRo
     */
    public createUserWithHttpInfo(hqAddUserRo: HqAddUserRo, _options?: Configuration): Observable<HttpInfo<ResponseDataHqAddUserVo>> {
        const requestContextPromise = this.requestFactory.createUser(hqAddUserRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createUserWithHttpInfo(rsp)));
            }));
    }

    /**
     * create a user by username and password.
     * Create user(Irregular vest number, used for testing)
     * @param hqAddUserRo
     */
    public createUser(hqAddUserRo: HqAddUserRo, _options?: Configuration): Observable<ResponseDataHqAddUserVo> {
        return this.createUserWithHttpInfo(hqAddUserRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataHqAddUserVo>) => apiResponse.data));
    }

    /**
     * Batch Create user(Irregular vest number, used for testing)
     */
    public createUsersWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.createUsers(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createUsersWithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch Create user(Irregular vest number, used for testing)
     */
    public createUsers(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.createUsersWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Deduct User Integral
     * @param integralDeductRo
     */
    public deductWithHttpInfo(integralDeductRo: IntegralDeductRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deduct(integralDeductRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deductWithHttpInfo(rsp)));
            }));
    }

    /**
     * Deduct User Integral
     * @param integralDeductRo
     */
    public deduct(integralDeductRo: IntegralDeductRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deductWithHttpInfo(integralDeductRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Remove laboratory feature
     * @param featureKey laboratory feature unique identifier
     */
    public deleteLabsFeatureWithHttpInfo(featureKey: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteLabsFeature(featureKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteLabsFeatureWithHttpInfo(rsp)));
            }));
    }

    /**
     * Remove laboratory feature
     * @param featureKey laboratory feature unique identifier
     */
    public deleteLabsFeature(featureKey: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteLabsFeatureWithHttpInfo(featureKey, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Enable specified space chatbot feature
     * @param chatbotEnableRo
     */
    public enableChatbotWithHttpInfo(chatbotEnableRo: ChatbotEnableRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.enableChatbot(chatbotEnableRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.enableChatbotWithHttpInfo(rsp)));
            }));
    }

    /**
     * Enable specified space chatbot feature
     * @param chatbotEnableRo
     */
    public enableChatbot(chatbotEnableRo: ChatbotEnableRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.enableChatbotWithHttpInfo(chatbotEnableRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Manually execute compensation of feishu event
     * @param tenantId
     */
    public feishuTenantEventWithHttpInfo(tenantId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.feishuTenantEvent(tenantId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.feishuTenantEventWithHttpInfo(rsp)));
            }));
    }

    /**
     * Manually execute compensation of feishu event
     * @param tenantId
     */
    public feishuTenantEvent(tenantId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.feishuTenantEventWithHttpInfo(tenantId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Query User Integral
     * @param userId User ID
     * @param areaCode Area Code
     * @param credential Account Credential（mobile or email）
     */
    public get1WithHttpInfo(userId?: number, areaCode?: number, credential?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInteger>> {
        const requestContextPromise = this.requestFactory.get1(userId, areaCode, credential, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.get1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Query User Integral
     * @param userId User ID
     * @param areaCode Area Code
     * @param credential Account Credential（mobile or email）
     */
    public get1(userId?: number, areaCode?: number, credential?: string, _options?: Configuration): Observable<ResponseDataInteger> {
        return this.get1WithHttpInfo(userId, areaCode, credential, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInteger>) => apiResponse.data));
    }

    /**
     * Lock verification
     * @param unlockRo
     */
    public lockWithHttpInfo(unlockRo: UnlockRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.lock(unlockRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.lockWithHttpInfo(rsp)));
            }));
    }

    /**
     * Lock verification
     * @param unlockRo
     */
    public lock(unlockRo: UnlockRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.lockWithHttpInfo(unlockRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Reset the active state of the user
     * @param userActivityRo
     */
    public resetActivityWithHttpInfo(userActivityRo?: UserActivityRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.resetActivity(userActivityRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.resetActivityWithHttpInfo(rsp)));
            }));
    }

    /**
     * Reset the active state of the user
     * @param userActivityRo
     */
    public resetActivity(userActivityRo?: UserActivityRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.resetActivityWithHttpInfo(userActivityRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Cancel a player notification, deleted from the notification center
     * Cancel a player notification
     * @param notificationRevokeRo
     */
    public revokePlayerNotifyWithHttpInfo(notificationRevokeRo: NotificationRevokeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.revokePlayerNotify(notificationRevokeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.revokePlayerNotifyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Cancel a player notification, deleted from the notification center
     * Cancel a player notification
     * @param notificationRevokeRo
     */
    public revokePlayerNotify(notificationRevokeRo: NotificationRevokeRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.revokePlayerNotifyWithHttpInfo(notificationRevokeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * create dingTalk app
     * @param syncSocialDingTalkAppRo
     */
    public syncDingTalkAppWithHttpInfo(syncSocialDingTalkAppRo: Array<SyncSocialDingTalkAppRo>, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.syncDingTalkApp(syncSocialDingTalkAppRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.syncDingTalkAppWithHttpInfo(rsp)));
            }));
    }

    /**
     * create dingTalk app
     * @param syncSocialDingTalkAppRo
     */
    public syncDingTalkApp(syncSocialDingTalkAppRo: Array<SyncSocialDingTalkAppRo>, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.syncDingTalkAppWithHttpInfo(syncSocialDingTalkAppRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Unlock verification
     * @param unlockRo
     */
    public unlockWithHttpInfo(unlockRo: UnlockRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unlock(unlockRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unlockWithHttpInfo(rsp)));
            }));
    }

    /**
     * Unlock verification
     * @param unlockRo
     */
    public unlock(unlockRo: UnlockRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unlockWithHttpInfo(unlockRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Modify laboratory feature attribute
     * @param gmLabsFeatureCreatorRo
     */
    public updateLabsFeaturesAttributeWithHttpInfo(gmLabsFeatureCreatorRo: GmLabsFeatureCreatorRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateLabsFeaturesAttribute(gmLabsFeatureCreatorRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateLabsFeaturesAttributeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Modify laboratory feature attribute
     * @param gmLabsFeatureCreatorRo
     */
    public updateLabsFeaturesAttribute(gmLabsFeatureCreatorRo: GmLabsFeatureCreatorRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateLabsFeaturesAttributeWithHttpInfo(gmLabsFeatureCreatorRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update GM permission config
     * @param configDatasheetRo
     */
    public updatePermissionWithHttpInfo(configDatasheetRo: ConfigDatasheetRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updatePermission(configDatasheetRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updatePermissionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update GM permission config
     * @param configDatasheetRo
     */
    public updatePermission(configDatasheetRo: ConfigDatasheetRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updatePermissionWithHttpInfo(configDatasheetRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * query user\'s mobile phone and email by user\'s id
     * @param queryUserInfoRo
     */
    public userContactInfoQueryWithHttpInfo(queryUserInfoRo: QueryUserInfoRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.userContactInfoQuery(queryUserInfoRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userContactInfoQueryWithHttpInfo(rsp)));
            }));
    }

    /**
     * query user\'s mobile phone and email by user\'s id
     * @param queryUserInfoRo
     */
    public userContactInfoQuery(queryUserInfoRo: QueryUserInfoRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.userContactInfoQueryWithHttpInfo(queryUserInfoRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ClientInterfaceApiRequestFactory, ClientInterfaceApiResponseProcessor} from "../apis/ClientInterfaceApi";
export class ObservableClientInterfaceApi {
    private requestFactory: ClientInterfaceApiRequestFactory;
    private responseProcessor: ClientInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ClientInterfaceApiRequestFactory,
        responseProcessor?: ClientInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ClientInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ClientInterfaceApiResponseProcessor();
    }

    /**
     * Get the application client version rendering information
     * Get application version information
     * @param spaceId
     * @param pipeline Construction serial number
     */
    public getTemplateInfoWithHttpInfo(spaceId?: string, pipeline?: string, _options?: Configuration): Observable<HttpInfo<ClientInfoVO>> {
        const requestContextPromise = this.requestFactory.getTemplateInfo(spaceId, pipeline, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTemplateInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the application client version rendering information
     * Get application version information
     * @param spaceId
     * @param pipeline Construction serial number
     */
    public getTemplateInfo(spaceId?: string, pipeline?: string, _options?: Configuration): Observable<ClientInfoVO> {
        return this.getTemplateInfoWithHttpInfo(spaceId, pipeline, _options).pipe(map((apiResponse: HttpInfo<ClientInfoVO>) => apiResponse.data));
    }

}

import { ConfigurationRelatedInterfacesApiRequestFactory, ConfigurationRelatedInterfacesApiResponseProcessor} from "../apis/ConfigurationRelatedInterfacesApi";
export class ObservableConfigurationRelatedInterfacesApi {
    private requestFactory: ConfigurationRelatedInterfacesApiRequestFactory;
    private responseProcessor: ConfigurationRelatedInterfacesApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ConfigurationRelatedInterfacesApiRequestFactory,
        responseProcessor?: ConfigurationRelatedInterfacesApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ConfigurationRelatedInterfacesApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ConfigurationRelatedInterfacesApiResponseProcessor();
    }

    /**
     * Scenario: novice guidance, announcement
     * General configuration
     * @param configRo
     */
    public generalWithHttpInfo(configRo: ConfigRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.general(configRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.generalWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scenario: novice guidance, announcement
     * General configuration
     * @param configRo
     */
    public general(configRo: ConfigRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.generalWithHttpInfo(configRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get configuration information
     * @param lang language
     */
    public get2WithHttpInfo(lang?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataObject>> {
        const requestContextPromise = this.requestFactory.get2(lang, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.get2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get configuration information
     * @param lang language
     */
    public get2(lang?: string, _options?: Configuration): Observable<ResponseDataObject> {
        return this.get2WithHttpInfo(lang, _options).pipe(map((apiResponse: HttpInfo<ResponseDataObject>) => apiResponse.data));
    }

}

import { ContactMemberApiApiRequestFactory, ContactMemberApiApiResponseProcessor} from "../apis/ContactMemberApiApi";
export class ObservableContactMemberApiApi {
    private requestFactory: ContactMemberApiApiRequestFactory;
    private responseProcessor: ContactMemberApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ContactMemberApiApiRequestFactory,
        responseProcessor?: ContactMemberApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ContactMemberApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ContactMemberApiApiResponseProcessor();
    }

    /**
     * When adding new members, they can only be selected from within the organization structure and can be transferred by department
     * Add member
     * @param teamAddMemberRo
     * @param xSpaceId space id
     */
    public addMemberWithHttpInfo(teamAddMemberRo: TeamAddMemberRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.addMember(teamAddMemberRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.addMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * When adding new members, they can only be selected from within the organization structure and can be transferred by department
     * Add member
     * @param teamAddMemberRo
     * @param xSpaceId space id
     */
    public addMember(teamAddMemberRo: TeamAddMemberRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.addMemberWithHttpInfo(teamAddMemberRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Check whether email in space
     * Check whether email in space
     * @param email email
     * @param xSpaceId space id
     */
    public checkEmailInSpaceWithHttpInfo(email: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.checkEmailInSpace(email, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.checkEmailInSpaceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Check whether email in space
     * Check whether email in space
     * @param email email
     * @param xSpaceId space id
     */
    public checkEmailInSpace(email: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.checkEmailInSpaceWithHttpInfo(email, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * action provides two deletion modes，1.delete from organization 2. delete from team
     * Delete members
     * @param deleteBatchMemberRo
     * @param xSpaceId space id
     */
    public deleteBatchMemberWithHttpInfo(deleteBatchMemberRo: DeleteBatchMemberRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteBatchMember(deleteBatchMemberRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteBatchMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * action provides two deletion modes，1.delete from organization 2. delete from team
     * Delete members
     * @param deleteBatchMemberRo
     * @param xSpaceId space id
     */
    public deleteBatchMember(deleteBatchMemberRo: DeleteBatchMemberRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteBatchMemberWithHttpInfo(deleteBatchMemberRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * action provides two deletion modes.1.delete from organization 2. delete from team
     * Delete a Member
     * @param deleteMemberRo
     * @param xSpaceId space id
     */
    public deleteMemberWithHttpInfo(deleteMemberRo: DeleteMemberRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteMember(deleteMemberRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * action provides two deletion modes.1.delete from organization 2. delete from team
     * Delete a Member
     * @param deleteMemberRo
     * @param xSpaceId space id
     */
    public deleteMember(deleteMemberRo: DeleteMemberRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteMemberWithHttpInfo(deleteMemberRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Download contact template
     * Download contact template
     */
    public downloadTemplateWithHttpInfo(_options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.downloadTemplate(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.downloadTemplateWithHttpInfo(rsp)));
            }));
    }

    /**
     * Download contact template
     * Download contact template
     */
    public downloadTemplate(_options?: Configuration): Observable<void> {
        return this.downloadTemplateWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * Query all the members of the department, including the members of the sub department.if root team can lack teamId, teamId default 0.
     * Query the team\'s members
     * @param xSpaceId space id
     * @param teamId team id. if root team can lack teamId, teamId default 0.
     */
    public getMemberListWithHttpInfo(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListMemberInfoVo>> {
        const requestContextPromise = this.requestFactory.getMemberList(xSpaceId, teamId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMemberListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query all the members of the department, including the members of the sub department.if root team can lack teamId, teamId default 0.
     * Query the team\'s members
     * @param xSpaceId space id
     * @param teamId team id. if root team can lack teamId, teamId default 0.
     */
    public getMemberList(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<ResponseDataListMemberInfoVo> {
        return this.getMemberListWithHttpInfo(xSpaceId, teamId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListMemberInfoVo>) => apiResponse.data));
    }

    /**
     * Fuzzy Search Members
     * Fuzzy Search Members
     * @param keyword keyword
     * @param xSpaceId space id
     * @param filter whether to filter unadded members
     * @param className the highlighting style
     */
    public getMembersWithHttpInfo(keyword: string, xSpaceId: string, filter?: boolean, className?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListSearchMemberVo>> {
        const requestContextPromise = this.requestFactory.getMembers(keyword, xSpaceId, filter, className, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * Fuzzy Search Members
     * Fuzzy Search Members
     * @param keyword keyword
     * @param xSpaceId space id
     * @param filter whether to filter unadded members
     * @param className the highlighting style
     */
    public getMembers(keyword: string, xSpaceId: string, filter?: boolean, className?: string, _options?: Configuration): Observable<ResponseDataListSearchMemberVo> {
        return this.getMembersWithHttpInfo(keyword, xSpaceId, filter, className, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListSearchMemberVo>) => apiResponse.data));
    }

    /**
     * Query the units which a user belongs, include self
     * Query the units which a user belongs in space
     * @param xSpaceId space id
     */
    public getUnitsWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataMemberUnitsVo>> {
        const requestContextPromise = this.requestFactory.getUnits(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getUnitsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query the units which a user belongs, include self
     * Query the units which a user belongs in space
     * @param xSpaceId space id
     */
    public getUnits(xSpaceId: string, _options?: Configuration): Observable<ResponseDataMemberUnitsVo> {
        return this.getUnitsWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataMemberUnitsVo>) => apiResponse.data));
    }

    /**
     * Send an email to invite. The email is automatically bound to the platform user. The invited member will be in the state to be activated, and will not take effect until the user self activates.
     * Send an email to invite members
     * @param inviteRo
     * @param xSpaceId space id
     */
    public inviteMemberWithHttpInfo(inviteRo: InviteRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataMemberUnitsVo>> {
        const requestContextPromise = this.requestFactory.inviteMember(inviteRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inviteMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * Send an email to invite. The email is automatically bound to the platform user. The invited member will be in the state to be activated, and will not take effect until the user self activates.
     * Send an email to invite members
     * @param inviteRo
     * @param xSpaceId space id
     */
    public inviteMember(inviteRo: InviteRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataMemberUnitsVo> {
        return this.inviteMemberWithHttpInfo(inviteRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataMemberUnitsVo>) => apiResponse.data));
    }

    /**
     * If a member is not activated, it can send an invitation again regardless of whether the invitation has expired. After the invitation is successfully sent, the invitation link sent last time will be invalid.
     * Again send an email to invite members
     * @param inviteMemberAgainRo
     * @param xSpaceId space id
     */
    public inviteMemberSingleWithHttpInfo(inviteMemberAgainRo: InviteMemberAgainRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.inviteMemberSingle(inviteMemberAgainRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inviteMemberSingleWithHttpInfo(rsp)));
            }));
    }

    /**
     * If a member is not activated, it can send an invitation again regardless of whether the invitation has expired. After the invitation is successfully sent, the invitation link sent last time will be invalid.
     * Again send an email to invite members
     * @param inviteMemberAgainRo
     * @param xSpaceId space id
     */
    public inviteMemberSingle(inviteMemberAgainRo: InviteMemberAgainRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.inviteMemberSingleWithHttpInfo(inviteMemberAgainRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get member\'s detail info
     * Get member\'s detail info
     * @param xSpaceId space id
     * @param memberId member id
     * @param uuid user uuid
     */
    public read1WithHttpInfo(xSpaceId: string, memberId?: string, uuid?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataMemberInfoVo>> {
        const requestContextPromise = this.requestFactory.read1(xSpaceId, memberId, uuid, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.read1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get member\'s detail info
     * Get member\'s detail info
     * @param xSpaceId space id
     * @param memberId member id
     * @param uuid user uuid
     */
    public read1(xSpaceId: string, memberId?: string, uuid?: string, _options?: Configuration): Observable<ResponseDataMemberInfoVo> {
        return this.read1WithHttpInfo(xSpaceId, memberId, uuid, _options).pipe(map((apiResponse: HttpInfo<ResponseDataMemberInfoVo>) => apiResponse.data));
    }

    /**
     * Query all the members of the department,  including the members of the sub department. The query must be paging not full query. Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page query the team\'s member
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     * @param teamId team id. if root team can lack teamId, teamId default 0.
     * @param isActive whether to filter unadded members
     */
    public readPageWithHttpInfo(page: Page, xSpaceId: string, pageObjectParams: string, teamId?: string, isActive?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoMemberPageVo>> {
        const requestContextPromise = this.requestFactory.readPage(page, xSpaceId, pageObjectParams, teamId, isActive, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readPageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query all the members of the department,  including the members of the sub department. The query must be paging not full query. Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page query the team\'s member
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     * @param teamId team id. if root team can lack teamId, teamId default 0.
     * @param isActive whether to filter unadded members
     */
    public readPage(page: Page, xSpaceId: string, pageObjectParams: string, teamId?: string, isActive?: string, _options?: Configuration): Observable<ResponseDataPageInfoMemberPageVo> {
        return this.readPageWithHttpInfo(page, xSpaceId, pageObjectParams, teamId, isActive, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoMemberPageVo>) => apiResponse.data));
    }

    /**
     * Edit self member information
     * Edit self member information
     * @param updateMemberOpRo
     * @param xSpaceId space id
     */
    public update4WithHttpInfo(updateMemberOpRo: UpdateMemberOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.update4(updateMemberOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.update4WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit self member information
     * Edit self member information
     * @param updateMemberOpRo
     * @param xSpaceId space id
     */
    public update4(updateMemberOpRo: UpdateMemberOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.update4WithHttpInfo(updateMemberOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit member info
     * Edit member info
     * @param updateMemberRo
     * @param xSpaceId space id
     */
    public updateInfoWithHttpInfo(updateMemberRo: UpdateMemberRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateInfo(updateMemberRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit member info
     * Edit member info
     * @param updateMemberRo
     * @param xSpaceId space id
     */
    public updateInfo(updateMemberRo: UpdateMemberRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateInfoWithHttpInfo(updateMemberRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * assign members to departments
     * Update team
     * @param updateMemberTeamRo
     * @param xSpaceId space id
     */
    public updateTeam1WithHttpInfo(updateMemberTeamRo: UpdateMemberTeamRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateTeam1(updateMemberTeamRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateTeam1WithHttpInfo(rsp)));
            }));
    }

    /**
     * assign members to departments
     * Update team
     * @param updateMemberTeamRo
     * @param xSpaceId space id
     */
    public updateTeam1(updateMemberTeamRo: UpdateMemberTeamRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateTeam1WithHttpInfo(updateMemberTeamRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Upload employee sheet，then parse it.
     * Upload employee sheet
     * @param data
     * @param xSpaceId space id
     */
    public uploadExcelWithHttpInfo(data: UploadMemberTemplateRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUploadParseResultVO>> {
        const requestContextPromise = this.requestFactory.uploadExcel(data, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.uploadExcelWithHttpInfo(rsp)));
            }));
    }

    /**
     * Upload employee sheet，then parse it.
     * Upload employee sheet
     * @param data
     * @param xSpaceId space id
     */
    public uploadExcel(data: UploadMemberTemplateRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataUploadParseResultVO> {
        return this.uploadExcelWithHttpInfo(data, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUploadParseResultVO>) => apiResponse.data));
    }

}

import { ContactOrganizationApiApiRequestFactory, ContactOrganizationApiApiResponseProcessor} from "../apis/ContactOrganizationApiApi";
export class ObservableContactOrganizationApiApi {
    private requestFactory: ContactOrganizationApiApiRequestFactory;
    private responseProcessor: ContactOrganizationApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ContactOrganizationApiApiRequestFactory,
        responseProcessor?: ContactOrganizationApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ContactOrganizationApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ContactOrganizationApiApiResponseProcessor();
    }

    /**
     * Query the sub departments and members of department. if team id lack, default is 0
     * Query the sub departments and members of department
     * @param teamId team id
     * @param linkId link id: node share id | template id
     * @param xSpaceId space id
     */
    public getSubUnitListWithHttpInfo(teamId?: string, linkId?: string, xSpaceId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSubUnitResultVo>> {
        const requestContextPromise = this.requestFactory.getSubUnitList(teamId, linkId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSubUnitListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query the sub departments and members of department. if team id lack, default is 0
     * Query the sub departments and members of department
     * @param teamId team id
     * @param linkId link id: node share id | template id
     * @param xSpaceId space id
     */
    public getSubUnitList(teamId?: string, linkId?: string, xSpaceId?: string, _options?: Configuration): Observable<ResponseDataSubUnitResultVo> {
        return this.getSubUnitListWithHttpInfo(teamId, linkId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSubUnitResultVo>) => apiResponse.data));
    }

    /**
     * The most recently selected units are loaded by default when not keyword. The most recently added member of the same group are loaded when not selected. Load max 10
     * Load/search departments and members
     * @param params
     * @param xSpaceId space id
     * @param linkId link id: node share id | template id
     * @param keyword keyword
     * @param unitIds unitIds
     * @param filterIds specifies the organizational unit to filter
     * @param all whether to load all departments and members
     * @param searchEmail whether to search for emails
     */
    public loadOrSearchWithHttpInfo(params: LoadSearchDTO, xSpaceId?: string, linkId?: string, keyword?: string, unitIds?: string, filterIds?: string, all?: boolean, searchEmail?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataListUnitInfoVo>> {
        const requestContextPromise = this.requestFactory.loadOrSearch(params, xSpaceId, linkId, keyword, unitIds, filterIds, all, searchEmail, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.loadOrSearchWithHttpInfo(rsp)));
            }));
    }

    /**
     * The most recently selected units are loaded by default when not keyword. The most recently added member of the same group are loaded when not selected. Load max 10
     * Load/search departments and members
     * @param params
     * @param xSpaceId space id
     * @param linkId link id: node share id | template id
     * @param keyword keyword
     * @param unitIds unitIds
     * @param filterIds specifies the organizational unit to filter
     * @param all whether to load all departments and members
     * @param searchEmail whether to search for emails
     */
    public loadOrSearch(params: LoadSearchDTO, xSpaceId?: string, linkId?: string, keyword?: string, unitIds?: string, filterIds?: string, all?: boolean, searchEmail?: boolean, _options?: Configuration): Observable<ResponseDataListUnitInfoVo> {
        return this.loadOrSearchWithHttpInfo(params, xSpaceId, linkId, keyword, unitIds, filterIds, all, searchEmail, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListUnitInfoVo>) => apiResponse.data));
    }

    /**
     * Provide input word fuzzy search organization resources
     * search organization resources
     * @param keyword keyword
     * @param linkId link id: node share id | template id
     * @param className the highlight style
     * @param xSpaceId space id
     */
    public searchWithHttpInfo(keyword: string, linkId?: string, className?: string, xSpaceId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitSearchResultVo>> {
        const requestContextPromise = this.requestFactory.search(keyword, linkId, className, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.searchWithHttpInfo(rsp)));
            }));
    }

    /**
     * Provide input word fuzzy search organization resources
     * search organization resources
     * @param keyword keyword
     * @param linkId link id: node share id | template id
     * @param className the highlight style
     * @param xSpaceId space id
     */
    public search(keyword: string, linkId?: string, className?: string, xSpaceId?: string, _options?: Configuration): Observable<ResponseDataUnitSearchResultVo> {
        return this.searchWithHttpInfo(keyword, linkId, className, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitSearchResultVo>) => apiResponse.data));
    }

    /**
     * fuzzy search unit
     * Search departments or members（it will be abandoned）
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className the highlight style
     */
    public searchSubTeamAndMembersWithHttpInfo(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListOrganizationUnitVo>> {
        const requestContextPromise = this.requestFactory.searchSubTeamAndMembers(keyword, xSpaceId, className, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.searchSubTeamAndMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * fuzzy search unit
     * Search departments or members（it will be abandoned）
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className the highlight style
     */
    public searchSubTeamAndMembers(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<ResponseDataListOrganizationUnitVo> {
        return this.searchSubTeamAndMembersWithHttpInfo(keyword, xSpaceId, className, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListOrganizationUnitVo>) => apiResponse.data));
    }

    /**
     * fuzzy search department or members
     * Global search
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className the highlight style
     */
    public searchTeamInfoWithHttpInfo(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSearchResultVo>> {
        const requestContextPromise = this.requestFactory.searchTeamInfo(keyword, xSpaceId, className, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.searchTeamInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * fuzzy search department or members
     * Global search
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className the highlight style
     */
    public searchTeamInfo(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<ResponseDataSearchResultVo> {
        return this.searchTeamInfoWithHttpInfo(keyword, xSpaceId, className, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSearchResultVo>) => apiResponse.data));
    }

    /**
     * scenario field conversion（If the amount of data is large, the content requested by GET will exceed the limit.）
     * accurately query departments and members
     * @param searchUnitRo
     * @param xSpaceId space id
     */
    public searchUnitInfoVoWithHttpInfo(searchUnitRo: SearchUnitRo, xSpaceId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListUnitInfoVo>> {
        const requestContextPromise = this.requestFactory.searchUnitInfoVo(searchUnitRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.searchUnitInfoVoWithHttpInfo(rsp)));
            }));
    }

    /**
     * scenario field conversion（If the amount of data is large, the content requested by GET will exceed the limit.）
     * accurately query departments and members
     * @param searchUnitRo
     * @param xSpaceId space id
     */
    public searchUnitInfoVo(searchUnitRo: SearchUnitRo, xSpaceId?: string, _options?: Configuration): Observable<ResponseDataListUnitInfoVo> {
        return this.searchUnitInfoVoWithHttpInfo(searchUnitRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListUnitInfoVo>) => apiResponse.data));
    }

}

import { ContactsRoleApiApiRequestFactory, ContactsRoleApiApiResponseProcessor} from "../apis/ContactsRoleApiApi";
export class ObservableContactsRoleApiApi {
    private requestFactory: ContactsRoleApiApiRequestFactory;
    private responseProcessor: ContactsRoleApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ContactsRoleApiApiRequestFactory,
        responseProcessor?: ContactsRoleApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ContactsRoleApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ContactsRoleApiApiResponseProcessor();
    }

    /**
     * add role members
     * add role members
     * @param addRoleMemberRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public addRoleMembersWithHttpInfo(addRoleMemberRo: AddRoleMemberRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.addRoleMembers(addRoleMemberRo, roleId, xSpaceId, roleId2, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.addRoleMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * add role members
     * add role members
     * @param addRoleMemberRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public addRoleMembers(addRoleMemberRo: AddRoleMemberRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.addRoleMembersWithHttpInfo(addRoleMemberRo, roleId, xSpaceId, roleId2, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * create new role
     * create new role
     * @param createRoleRo
     * @param xSpaceId space id
     */
    public createRoleWithHttpInfo(createRoleRo: CreateRoleRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.createRole(createRoleRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * create new role
     * create new role
     * @param createRoleRo
     * @param xSpaceId space id
     */
    public createRole(createRoleRo: CreateRoleRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.createRoleWithHttpInfo(createRoleRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * delete role
     * delete role
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public deleteRole1WithHttpInfo(roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteRole1(roleId, xSpaceId, roleId2, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * delete role
     * delete role
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public deleteRole1(roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteRole1WithHttpInfo(roleId, xSpaceId, roleId2, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * query the role\'s members
     * query role members
     * @param roleId
     * @param page
     * @param xSpaceId space id
     * @param roleId2
     * @param pageObjectParams page parameters
     */
    public getRoleMembersWithHttpInfo(roleId: number, page: PageVoid, xSpaceId: string, roleId2: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoRoleMemberVo>> {
        const requestContextPromise = this.requestFactory.getRoleMembers(roleId, page, xSpaceId, roleId2, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRoleMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * query the role\'s members
     * query role members
     * @param roleId
     * @param page
     * @param xSpaceId space id
     * @param roleId2
     * @param pageObjectParams page parameters
     */
    public getRoleMembers(roleId: number, page: PageVoid, xSpaceId: string, roleId2: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoRoleMemberVo> {
        return this.getRoleMembersWithHttpInfo(roleId, page, xSpaceId, roleId2, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoRoleMemberVo>) => apiResponse.data));
    }

    /**
     * query the space\'s roles
     * query roles
     * @param xSpaceId space id
     */
    public getRolesWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListRoleInfoVo>> {
        const requestContextPromise = this.requestFactory.getRoles(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRolesWithHttpInfo(rsp)));
            }));
    }

    /**
     * query the space\'s roles
     * query roles
     * @param xSpaceId space id
     */
    public getRoles(xSpaceId: string, _options?: Configuration): Observable<ResponseDataListRoleInfoVo> {
        return this.getRolesWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListRoleInfoVo>) => apiResponse.data));
    }

    /**
     * create init role
     * create init role
     * @param xSpaceId space id
     */
    public initRolesWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.initRoles(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.initRolesWithHttpInfo(rsp)));
            }));
    }

    /**
     * create init role
     * create init role
     * @param xSpaceId space id
     */
    public initRoles(xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.initRolesWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * remove role members
     * remove role members
     * @param deleteRoleMemberRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public removeRoleMembersWithHttpInfo(deleteRoleMemberRo: DeleteRoleMemberRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.removeRoleMembers(deleteRoleMemberRo, roleId, xSpaceId, roleId2, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.removeRoleMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * remove role members
     * remove role members
     * @param deleteRoleMemberRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public removeRoleMembers(deleteRoleMemberRo: DeleteRoleMemberRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.removeRoleMembersWithHttpInfo(deleteRoleMemberRo, roleId, xSpaceId, roleId2, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * update role information
     * update role information
     * @param updateRoleRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public updateRoleWithHttpInfo(updateRoleRo: UpdateRoleRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateRole(updateRoleRo, roleId, xSpaceId, roleId2, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * update role information
     * update role information
     * @param updateRoleRo
     * @param roleId
     * @param xSpaceId space id
     * @param roleId2
     */
    public updateRole(updateRoleRo: UpdateRoleRo, roleId: number, xSpaceId: string, roleId2: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateRoleWithHttpInfo(updateRoleRo, roleId, xSpaceId, roleId2, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ContactsTeamApiApiRequestFactory, ContactsTeamApiApiResponseProcessor} from "../apis/ContactsTeamApiApi";
export class ObservableContactsTeamApiApi {
    private requestFactory: ContactsTeamApiApiRequestFactory;
    private responseProcessor: ContactsTeamApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ContactsTeamApiApiRequestFactory,
        responseProcessor?: ContactsTeamApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ContactsTeamApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ContactsTeamApiApiResponseProcessor();
    }

    /**
     * Create team
     * Create team
     * @param createTeamRo
     * @param xSpaceId space id
     */
    public createTeamWithHttpInfo(createTeamRo: CreateTeamRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.createTeam(createTeamRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create team
     * Create team
     * @param createTeamRo
     * @param xSpaceId space id
     */
    public createTeam(createTeamRo: CreateTeamRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.createTeamWithHttpInfo(createTeamRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete team. If team has members, it can be deleted.
     * Delete team
     * @param teamId team id
     * @param xSpaceId space id
     */
    public deleteTeamWithHttpInfo(teamId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteTeam(teamId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete team. If team has members, it can be deleted.
     * Delete team
     * @param teamId team id
     * @param xSpaceId space id
     */
    public deleteTeam(teamId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteTeamWithHttpInfo(teamId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * query sub team by team id. if team id lack, default root team.
     * Query direct sub departments
     * @param xSpaceId space id
     * @param teamId team id
     */
    public getSubTeamsWithHttpInfo(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTeamTreeVo>> {
        const requestContextPromise = this.requestFactory.getSubTeams(xSpaceId, teamId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSubTeamsWithHttpInfo(rsp)));
            }));
    }

    /**
     * query sub team by team id. if team id lack, default root team.
     * Query direct sub departments
     * @param xSpaceId space id
     * @param teamId team id
     */
    public getSubTeams(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<ResponseDataListTeamTreeVo> {
        return this.getSubTeamsWithHttpInfo(xSpaceId, teamId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTeamTreeVo>) => apiResponse.data));
    }

    /**
     * team branch. result is tree
     * team branch
     * @param xSpaceId space id
     */
    public getTeamBranchWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTeamTreeVo>> {
        const requestContextPromise = this.requestFactory.getTeamBranch(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTeamBranchWithHttpInfo(rsp)));
            }));
    }

    /**
     * team branch. result is tree
     * team branch
     * @param xSpaceId space id
     */
    public getTeamBranch(xSpaceId: string, _options?: Configuration): Observable<ResponseDataListTeamTreeVo> {
        return this.getTeamBranchWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTeamTreeVo>) => apiResponse.data));
    }

    /**
     * Query the team\'s members, no include sub team\'s
     * Query the team\'s members
     * @param teamId team id
     * @param xSpaceId space id
     */
    public getTeamMembersWithHttpInfo(teamId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListMemberPageVo>> {
        const requestContextPromise = this.requestFactory.getTeamMembers(teamId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTeamMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query the team\'s members, no include sub team\'s
     * Query the team\'s members
     * @param teamId team id
     * @param xSpaceId space id
     */
    public getTeamMembers(teamId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataListMemberPageVo> {
        return this.getTeamMembersWithHttpInfo(teamId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListMemberPageVo>) => apiResponse.data));
    }

    /**
     * Query team tree
     * @param xSpaceId space id
     * @param depth tree depth(default:1,max:2)
     */
    public getTeamTreeWithHttpInfo(xSpaceId: string, depth?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListTeamTreeVo>> {
        const requestContextPromise = this.requestFactory.getTeamTree(xSpaceId, depth, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTeamTreeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query team tree
     * @param xSpaceId space id
     * @param depth tree depth(default:1,max:2)
     */
    public getTeamTree(xSpaceId: string, depth?: number, _options?: Configuration): Observable<ResponseDataListTeamTreeVo> {
        return this.getTeamTreeWithHttpInfo(xSpaceId, depth, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTeamTreeVo>) => apiResponse.data));
    }

    /**
     * Query department information. if team id lack, default root team
     * Query team information
     * @param xSpaceId space id
     * @param teamId team id
     */
    public readTeamInfoWithHttpInfo(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTeamInfoVo>> {
        const requestContextPromise = this.requestFactory.readTeamInfo(xSpaceId, teamId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readTeamInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query department information. if team id lack, default root team
     * Query team information
     * @param xSpaceId space id
     * @param teamId team id
     */
    public readTeamInfo(xSpaceId: string, teamId?: string, _options?: Configuration): Observable<ResponseDataTeamInfoVo> {
        return this.readTeamInfoWithHttpInfo(xSpaceId, teamId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTeamInfoVo>) => apiResponse.data));
    }

    /**
     * Update team info. If modify team level,default sort in the end of parent team.
     * Update team info
     * @param updateTeamRo
     * @param xSpaceId space id
     */
    public updateTeamWithHttpInfo(updateTeamRo: UpdateTeamRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateTeam(updateTeamRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update team info. If modify team level,default sort in the end of parent team.
     * Update team info
     * @param updateTeamRo
     * @param xSpaceId space id
     */
    public updateTeam(updateTeamRo: UpdateTeamRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateTeamWithHttpInfo(updateTeamRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ContentRiskControlAPIApiRequestFactory, ContentRiskControlAPIApiResponseProcessor} from "../apis/ContentRiskControlAPIApi";
export class ObservableContentRiskControlAPIApi {
    private requestFactory: ContentRiskControlAPIApiRequestFactory;
    private responseProcessor: ContentRiskControlAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ContentRiskControlAPIApiRequestFactory,
        responseProcessor?: ContentRiskControlAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ContentRiskControlAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ContentRiskControlAPIApiResponseProcessor();
    }

    /**
     * Submit a report
     * @param contentCensorReportRo
     */
    public createReportsWithHttpInfo(contentCensorReportRo: ContentCensorReportRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.createReports(contentCensorReportRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createReportsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Submit a report
     * @param contentCensorReportRo
     */
    public createReports(contentCensorReportRo: ContentCensorReportRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.createReportsWithHttpInfo(contentCensorReportRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Paging query report information list, each table corresponds to a row of records, and the number of reports is automatically accumulatedDescription of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Paging query report information list
     * @param status Processing result, 0 unprocessed, 1 banned, 2 normal (unblocked)
     * @param page
     * @param pageObjectParams Paging parameters, see the interface description for instructions
     */
    public readReportsWithHttpInfo(status: number, page: Page, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoContentCensorResultVo>> {
        const requestContextPromise = this.requestFactory.readReports(status, page, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readReportsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Paging query report information list, each table corresponds to a row of records, and the number of reports is automatically accumulatedDescription of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Paging query report information list
     * @param status Processing result, 0 unprocessed, 1 banned, 2 normal (unblocked)
     * @param page
     * @param pageObjectParams Paging parameters, see the interface description for instructions
     */
    public readReports(status: number, page: Page, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoContentCensorResultVo> {
        return this.readReportsWithHttpInfo(status, page, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoContentCensorResultVo>) => apiResponse.data));
    }

    /**
     * Force to open in DingTalk, automatically acquire DingTalk users
     * Handling whistleblower information
     * @param nodeId node id
     * @param status Processing result, 0 unprocessed, 1 banned, 2 normal (unblocked)
     */
    public updateReportsWithHttpInfo(nodeId: string, status: number, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateReports(nodeId, status, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateReportsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Force to open in DingTalk, automatically acquire DingTalk users
     * Handling whistleblower information
     * @param nodeId node id
     * @param status Processing result, 0 unprocessed, 1 banned, 2 normal (unblocked)
     */
    public updateReports(nodeId: string, status: number, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateReportsWithHttpInfo(nodeId, status, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { DeveloperConfigAPIApiRequestFactory, DeveloperConfigAPIApiResponseProcessor} from "../apis/DeveloperConfigAPIApi";
export class ObservableDeveloperConfigAPIApi {
    private requestFactory: DeveloperConfigAPIApiRequestFactory;
    private responseProcessor: DeveloperConfigAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DeveloperConfigAPIApiRequestFactory,
        responseProcessor?: DeveloperConfigAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DeveloperConfigAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DeveloperConfigAPIApiResponseProcessor();
    }

    /**
     * Create developer access tokens to access open platform functionality.
     * Create the developer access token
     */
    public createApiKeyWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataDeveloperInfoVo>> {
        const requestContextPromise = this.requestFactory.createApiKey(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createApiKeyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create developer access tokens to access open platform functionality.
     * Create the developer access token
     */
    public createApiKey(_options?: Configuration): Observable<ResponseDataDeveloperInfoVo> {
        return this.createApiKeyWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataDeveloperInfoVo>) => apiResponse.data));
    }

    /**
     * Refresh developer access token before verifying phone number.If there is no verification mailbox, skip verification.
     * Refresh the developer access token
     * @param refreshApiKeyRo
     */
    public refreshApiKeyWithHttpInfo(refreshApiKeyRo: RefreshApiKeyRo, _options?: Configuration): Observable<HttpInfo<ResponseDataDeveloperInfoVo>> {
        const requestContextPromise = this.requestFactory.refreshApiKey(refreshApiKeyRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.refreshApiKeyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Refresh developer access token before verifying phone number.If there is no verification mailbox, skip verification.
     * Refresh the developer access token
     * @param refreshApiKeyRo
     */
    public refreshApiKey(refreshApiKeyRo: RefreshApiKeyRo, _options?: Configuration): Observable<ResponseDataDeveloperInfoVo> {
        return this.refreshApiKeyWithHttpInfo(refreshApiKeyRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDeveloperInfoVo>) => apiResponse.data));
    }

    /**
     * Provides a mid-tier validation access token.
     * Verify the access token
     * @param apiKey
     */
    public validateApiKeyWithHttpInfo(apiKey: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.validateApiKey(apiKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validateApiKeyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Provides a mid-tier validation access token.
     * Verify the access token
     * @param apiKey
     */
    public validateApiKey(apiKey: string, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.validateApiKeyWithHttpInfo(apiKey, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

}

import { DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiRequestFactory, DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiResponseProcessor} from "../apis/DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApi";
export class ObservableDingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApi {
    private requestFactory: DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiRequestFactory;
    private responseProcessor: DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiRequestFactory,
        responseProcessor?: DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DingTalkEnterpriseInternalApplicationRelatedServiceInterfaceApiResponseProcessor();
    }

    /**
     * After the login is completed, the system saves the user session by default, and calls other business interfaces to automatically bring the cookie
     * dingtalk user password free login
     * @param code temporary authorization code, uploaded by the client
     */
    public login1WithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkUserDetail>> {
        const requestContextPromise = this.requestFactory.login1(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.login1WithHttpInfo(rsp)));
            }));
    }

    /**
     * After the login is completed, the system saves the user session by default, and calls other business interfaces to automatically bring the cookie
     * dingtalk user password free login
     * @param code temporary authorization code, uploaded by the client
     */
    public login1(code: string, _options?: Configuration): Observable<ResponseDataDingTalkUserDetail> {
        return this.login1WithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkUserDetail>) => apiResponse.data));
    }

}

import { DingTalkServiceInterfaceApiRequestFactory, DingTalkServiceInterfaceApiResponseProcessor} from "../apis/DingTalkServiceInterfaceApi";
export class ObservableDingTalkServiceInterfaceApi {
    private requestFactory: DingTalkServiceInterfaceApiRequestFactory;
    private responseProcessor: DingTalkServiceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: DingTalkServiceInterfaceApiRequestFactory,
        responseProcessor?: DingTalkServiceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new DingTalkServiceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new DingTalkServiceInterfaceApiResponseProcessor();
    }

    /**
     * DingTalk scan code login callback
     * @param code coding. JS gets the login Tmp Code, redirects and returns after jumping to the specified connection
     * @param state declare value. Used to prevent replay attacks
     * @param type Type (0: scan code to log in; 1: account binding;)
     */
    public callback3WithHttpInfo(code: string, state: string, type?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.callback3(code, state, type, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callback3WithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk scan code login callback
     * @param code coding. JS gets the login Tmp Code, redirects and returns after jumping to the specified connection
     * @param state declare value. Used to prevent replay attacks
     * @param type Type (0: scan code to log in; 1: account binding;)
     */
    public callback3(code: string, state: string, type?: number, _options?: Configuration): Observable<ResponseDataString> {
        return this.callback3WithHttpInfo(code, state, type, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { GMWidgetAPIApiRequestFactory, GMWidgetAPIApiResponseProcessor} from "../apis/GMWidgetAPIApi";
export class ObservableGMWidgetAPIApi {
    private requestFactory: GMWidgetAPIApiRequestFactory;
    private responseProcessor: GMWidgetAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: GMWidgetAPIApiRequestFactory,
        responseProcessor?: GMWidgetAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new GMWidgetAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new GMWidgetAPIApiResponseProcessor();
    }

    /**
     * widget-cli ban/unban widget
     * Ban/Unban widget
     * @param widgetPackageBanRo
     * @param authorization developer token
     */
    public banWidgetWithHttpInfo(widgetPackageBanRo: WidgetPackageBanRo, authorization?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.banWidget(widgetPackageBanRo, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.banWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli ban/unban widget
     * Ban/Unban widget
     * @param widgetPackageBanRo
     * @param authorization developer token
     */
    public banWidget(widgetPackageBanRo: WidgetPackageBanRo, authorization?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.banWidgetWithHttpInfo(widgetPackageBanRo, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Refresh the global component DB data
     * @param globalWidgetListRo
     */
    public globalWidgetDbDataRefreshWithHttpInfo(globalWidgetListRo: GlobalWidgetListRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.globalWidgetDbDataRefresh(globalWidgetListRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.globalWidgetDbDataRefreshWithHttpInfo(rsp)));
            }));
    }

    /**
     * Refresh the global component DB data
     * @param globalWidgetListRo
     */
    public globalWidgetDbDataRefresh(globalWidgetListRo: GlobalWidgetListRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.globalWidgetDbDataRefreshWithHttpInfo(globalWidgetListRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Gets a list of global widget stores
     * @param globalWidgetListRo
     */
    public globalWidgetListWithHttpInfo(globalWidgetListRo: GlobalWidgetListRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListGlobalWidgetInfo>> {
        const requestContextPromise = this.requestFactory.globalWidgetList(globalWidgetListRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.globalWidgetListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets a list of global widget stores
     * @param globalWidgetListRo
     */
    public globalWidgetList(globalWidgetListRo: GlobalWidgetListRo, _options?: Configuration): Observable<ResponseDataListGlobalWidgetInfo> {
        return this.globalWidgetListWithHttpInfo(globalWidgetListRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListGlobalWidgetInfo>) => apiResponse.data));
    }

}

import { IDaaSAddressBookApiRequestFactory, IDaaSAddressBookApiResponseProcessor} from "../apis/IDaaSAddressBookApi";
export class ObservableIDaaSAddressBookApi {
    private requestFactory: IDaaSAddressBookApiRequestFactory;
    private responseProcessor: IDaaSAddressBookApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: IDaaSAddressBookApiRequestFactory,
        responseProcessor?: IDaaSAddressBookApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new IDaaSAddressBookApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new IDaaSAddressBookApiResponseProcessor();
    }

    /**
     * Synchronize address book
     */
    public postSyncWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postSync(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postSyncWithHttpInfo(rsp)));
            }));
    }

    /**
     * Synchronize address book
     */
    public postSync(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.postSyncWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { IDaaSLoginAuthorizationApiRequestFactory, IDaaSLoginAuthorizationApiResponseProcessor} from "../apis/IDaaSLoginAuthorizationApi";
export class ObservableIDaaSLoginAuthorizationApi {
    private requestFactory: IDaaSLoginAuthorizationApiRequestFactory;
    private responseProcessor: IDaaSLoginAuthorizationApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: IDaaSLoginAuthorizationApiRequestFactory,
        responseProcessor?: IDaaSLoginAuthorizationApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new IDaaSLoginAuthorizationApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new IDaaSLoginAuthorizationApiResponseProcessor();
    }

    /**
     * Get the IDaaS information bound to the space
     * @param spaceId
     */
    public getBindInfoWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataIdaasBindInfoVo>> {
        const requestContextPromise = this.requestFactory.getBindInfo(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getBindInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the IDaaS information bound to the space
     * @param spaceId
     */
    public getBindInfo(spaceId: string, _options?: Configuration): Observable<ResponseDataIdaasBindInfoVo> {
        return this.getBindInfoWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataIdaasBindInfoVo>) => apiResponse.data));
    }

    /**
     * Get the link to log in to the IDaaS system
     * @param clientId
     */
    public getLoginWithHttpInfo(clientId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataIdaasAuthLoginVo>> {
        const requestContextPromise = this.requestFactory.getLogin(clientId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the link to log in to the IDaaS system
     * @param clientId
     */
    public getLogin(clientId: string, _options?: Configuration): Observable<ResponseDataIdaasAuthLoginVo> {
        return this.getLoginWithHttpInfo(clientId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataIdaasAuthLoginVo>) => apiResponse.data));
    }

    /**
     * Jump to the IDaaS system for automatic login
     * @param clientId
     */
    public getLoginRedirectWithHttpInfo(clientId: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.getLoginRedirect(clientId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getLoginRedirectWithHttpInfo(rsp)));
            }));
    }

    /**
     * Jump to the IDaaS system for automatic login
     * @param clientId
     */
    public getLoginRedirect(clientId: string, _options?: Configuration): Observable<void> {
        return this.getLoginRedirectWithHttpInfo(clientId, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * For private deployment only
     * The user completes subsequent operations after logging in to the IDaaS system
     * @param idaasAuthCallbackRo
     * @param clientId
     */
    public postCallback1WithHttpInfo(idaasAuthCallbackRo: IdaasAuthCallbackRo, clientId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postCallback1(idaasAuthCallbackRo, clientId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postCallback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * For private deployment only
     * The user completes subsequent operations after logging in to the IDaaS system
     * @param idaasAuthCallbackRo
     * @param clientId
     */
    public postCallback1(idaasAuthCallbackRo: IdaasAuthCallbackRo, clientId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.postCallback1WithHttpInfo(idaasAuthCallbackRo, clientId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * For Sass version only
     * The user completes subsequent operations after logging in to the IDaaS system
     * @param idaasAuthCallbackRo
     * @param clientId
     * @param spaceId
     */
    public postSpaceCallbackWithHttpInfo(idaasAuthCallbackRo: IdaasAuthCallbackRo, clientId: string, spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postSpaceCallback(idaasAuthCallbackRo, clientId, spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postSpaceCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * For Sass version only
     * The user completes subsequent operations after logging in to the IDaaS system
     * @param idaasAuthCallbackRo
     * @param clientId
     * @param spaceId
     */
    public postSpaceCallback(idaasAuthCallbackRo: IdaasAuthCallbackRo, clientId: string, spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.postSpaceCallbackWithHttpInfo(idaasAuthCallbackRo, clientId, spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { IntegralApiApiRequestFactory, IntegralApiApiResponseProcessor} from "../apis/IntegralApiApi";
export class ObservableIntegralApiApi {
    private requestFactory: IntegralApiApiRequestFactory;
    private responseProcessor: IntegralApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: IntegralApiApiRequestFactory,
        responseProcessor?: IntegralApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new IntegralApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new IntegralApiApiResponseProcessor();
    }

    /**
     * Page by page query of integral revenue and expenditure details
     * @param page
     * @param pageObjectParams Page parameter
     */
    public integralRecordsWithHttpInfo(page: Page, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoIntegralRecordVO>> {
        const requestContextPromise = this.requestFactory.integralRecords(page, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.integralRecordsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Page by page query of integral revenue and expenditure details
     * @param page
     * @param pageObjectParams Page parameter
     */
    public integralRecords(page: Page, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoIntegralRecordVO> {
        return this.integralRecordsWithHttpInfo(page, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoIntegralRecordVO>) => apiResponse.data));
    }

    /**
     * Query account integral information
     */
    public integralsWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataUserIntegralVo>> {
        const requestContextPromise = this.requestFactory.integrals(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.integralsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query account integral information
     */
    public integrals(_options?: Configuration): Observable<ResponseDataUserIntegralVo> {
        return this.integralsWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataUserIntegralVo>) => apiResponse.data));
    }

    /**
     * Users fill in the invitation code and get rewards
     * Fill in invitation code reward
     * @param inviteCodeRewardRo
     */
    public inviteCodeRewardWithHttpInfo(inviteCodeRewardRo: InviteCodeRewardRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.inviteCodeReward(inviteCodeRewardRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.inviteCodeRewardWithHttpInfo(rsp)));
            }));
    }

    /**
     * Users fill in the invitation code and get rewards
     * Fill in invitation code reward
     * @param inviteCodeRewardRo
     */
    public inviteCodeReward(inviteCodeRewardRo: InviteCodeRewardRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.inviteCodeRewardWithHttpInfo(inviteCodeRewardRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { InternalContactsApiApiRequestFactory, InternalContactsApiApiResponseProcessor} from "../apis/InternalContactsApiApi";
export class ObservableInternalContactsApiApi {
    private requestFactory: InternalContactsApiApiRequestFactory;
    private responseProcessor: InternalContactsApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalContactsApiApiRequestFactory,
        responseProcessor?: InternalContactsApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalContactsApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalContactsApiApiResponseProcessor();
    }

    /**
     * create new role
     * create new role
     * @param createRoleRo
     * @param xSpaceId space id
     */
    public createUnitRoleWithHttpInfo(createRoleRo: CreateRoleRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitRoleInfoVo>> {
        const requestContextPromise = this.requestFactory.createUnitRole(createRoleRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createUnitRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * create new role
     * create new role
     * @param createRoleRo
     * @param xSpaceId space id
     */
    public createUnitRole(createRoleRo: CreateRoleRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataUnitRoleInfoVo> {
        return this.createUnitRoleWithHttpInfo(createRoleRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitRoleInfoVo>) => apiResponse.data));
    }

    /**
     * Add a sub team
     * Add a sub team
     * @param createUnitTeamRo
     * @param xSpaceId space id
     */
    public createUnitTeamWithHttpInfo(createUnitTeamRo: CreateUnitTeamRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitTeamInfoVo>> {
        const requestContextPromise = this.requestFactory.createUnitTeam(createUnitTeamRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createUnitTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Add a sub team
     * Add a sub team
     * @param createUnitTeamRo
     * @param xSpaceId space id
     */
    public createUnitTeam(createUnitTeamRo: CreateUnitTeamRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataUnitTeamInfoVo> {
        return this.createUnitTeamWithHttpInfo(createUnitTeamRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitTeamInfoVo>) => apiResponse.data));
    }

    /**
     * Delete a Member from organization
     * Delete a Member from organization
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteMember1WithHttpInfo(unitId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteMember1(unitId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteMember1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete a Member from organization
     * Delete a Member from organization
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteMember1(unitId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteMember1WithHttpInfo(unitId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete role. If role has members, it can be deleted.
     * Delete team
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteUnitRoleWithHttpInfo(unitId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteUnitRole(unitId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteUnitRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete role. If role has members, it can be deleted.
     * Delete team
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteUnitRole(unitId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteUnitRoleWithHttpInfo(unitId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete team. If team has members, it can be deleted.
     * Delete team
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteUnitTeamWithHttpInfo(unitId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteUnitTeam(unitId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteUnitTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete team. If team has members, it can be deleted.
     * Delete team
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public deleteUnitTeam(unitId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteUnitTeamWithHttpInfo(unitId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Query roles information
     * Query roles information
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getRolePageListWithHttpInfo(page: PageRoleBaseInfoDto, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoUnitRoleInfoVo>> {
        const requestContextPromise = this.requestFactory.getRolePageList(page, xSpaceId, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRolePageListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query roles information
     * Query roles information
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getRolePageList(page: PageRoleBaseInfoDto, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoUnitRoleInfoVo> {
        return this.getRolePageListWithHttpInfo(page, xSpaceId, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoUnitRoleInfoVo>) => apiResponse.data));
    }

    /**
     * Query department information. if team id lack, default root team
     * Query team information
     * @param unitId unit uuid
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getTeamChildrenPageListWithHttpInfo(unitId: string, page: PageLong, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoUnitTeamInfoVo>> {
        const requestContextPromise = this.requestFactory.getTeamChildrenPageList(unitId, page, xSpaceId, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTeamChildrenPageListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query department information. if team id lack, default root team
     * Query team information
     * @param unitId unit uuid
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getTeamChildrenPageList(unitId: string, page: PageLong, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoUnitTeamInfoVo> {
        return this.getTeamChildrenPageListWithHttpInfo(unitId, page, xSpaceId, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoUnitTeamInfoVo>) => apiResponse.data));
    }

    /**
     * Query department members information. if team id lack, default root team
     * Query team members information
     * @param unitId unit uuid
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     * @param sensitiveData includes mobile number and email
     */
    public getTeamMembersPageInfoWithHttpInfo(unitId: string, page: PageLong, xSpaceId: string, pageObjectParams: string, sensitiveData?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoUnitMemberInfoVo>> {
        const requestContextPromise = this.requestFactory.getTeamMembersPageInfo(unitId, page, xSpaceId, pageObjectParams, sensitiveData, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTeamMembersPageInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query department members information. if team id lack, default root team
     * Query team members information
     * @param unitId unit uuid
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     * @param sensitiveData includes mobile number and email
     */
    public getTeamMembersPageInfo(unitId: string, page: PageLong, xSpaceId: string, pageObjectParams: string, sensitiveData?: boolean, _options?: Configuration): Observable<ResponseDataPageInfoUnitMemberInfoVo> {
        return this.getTeamMembersPageInfoWithHttpInfo(unitId, page, xSpaceId, pageObjectParams, sensitiveData, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoUnitMemberInfoVo>) => apiResponse.data));
    }

    /**
     * Query team information
     * Query team information
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public getUnitMemberDetailsWithHttpInfo(unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitMemberInfoVo>> {
        const requestContextPromise = this.requestFactory.getUnitMemberDetails(unitId, xSpaceId, sensitiveData, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getUnitMemberDetailsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query team information
     * Query team information
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public getUnitMemberDetails(unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<ResponseDataUnitMemberInfoVo> {
        return this.getUnitMemberDetailsWithHttpInfo(unitId, xSpaceId, sensitiveData, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitMemberInfoVo>) => apiResponse.data));
    }

    /**
     * query the role\'s members
     * query role members
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public getUnitRoleMembersWithHttpInfo(unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitRoleMemberVo>> {
        const requestContextPromise = this.requestFactory.getUnitRoleMembers(unitId, xSpaceId, sensitiveData, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getUnitRoleMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * query the role\'s members
     * query role members
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public getUnitRoleMembers(unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<ResponseDataUnitRoleMemberVo> {
        return this.getUnitRoleMembersWithHttpInfo(unitId, xSpaceId, sensitiveData, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitRoleMemberVo>) => apiResponse.data));
    }

    /**
     * Edit member info
     * Edit member info
     * @param updateUnitMemberRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public updateUnitMemberWithHttpInfo(updateUnitMemberRo: UpdateUnitMemberRo, unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitMemberInfoVo>> {
        const requestContextPromise = this.requestFactory.updateUnitMember(updateUnitMemberRo, unitId, xSpaceId, sensitiveData, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateUnitMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit member info
     * Edit member info
     * @param updateUnitMemberRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     * @param sensitiveData includes mobile number and email
     */
    public updateUnitMember(updateUnitMemberRo: UpdateUnitMemberRo, unitId: string, xSpaceId: string, sensitiveData?: boolean, _options?: Configuration): Observable<ResponseDataUnitMemberInfoVo> {
        return this.updateUnitMemberWithHttpInfo(updateUnitMemberRo, unitId, xSpaceId, sensitiveData, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitMemberInfoVo>) => apiResponse.data));
    }

    /**
     * Update role info.
     * Update team info
     * @param updateUnitRoleRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public updateUnitRoleWithHttpInfo(updateUnitRoleRo: UpdateUnitRoleRo, unitId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitRoleInfoVo>> {
        const requestContextPromise = this.requestFactory.updateUnitRole(updateUnitRoleRo, unitId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateUnitRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update role info.
     * Update team info
     * @param updateUnitRoleRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public updateUnitRole(updateUnitRoleRo: UpdateUnitRoleRo, unitId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataUnitRoleInfoVo> {
        return this.updateUnitRoleWithHttpInfo(updateUnitRoleRo, unitId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitRoleInfoVo>) => apiResponse.data));
    }

    /**
     * Update team info. If modify team level, default sort in the end of parent team.
     * Update team info
     * @param updateUnitTeamRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public updateUnitTeamWithHttpInfo(updateUnitTeamRo: UpdateUnitTeamRo, unitId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUnitTeamInfoVo>> {
        const requestContextPromise = this.requestFactory.updateUnitTeam(updateUnitTeamRo, unitId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateUnitTeamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update team info. If modify team level, default sort in the end of parent team.
     * Update team info
     * @param updateUnitTeamRo
     * @param unitId unit uuid
     * @param xSpaceId space id
     */
    public updateUnitTeam(updateUnitTeamRo: UpdateUnitTeamRo, unitId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataUnitTeamInfoVo> {
        return this.updateUnitTeamWithHttpInfo(updateUnitTeamRo, unitId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUnitTeamInfoVo>) => apiResponse.data));
    }

}

import { InternalServerAssetAPIApiRequestFactory, InternalServerAssetAPIApiResponseProcessor} from "../apis/InternalServerAssetAPIApi";
export class ObservableInternalServerAssetAPIApi {
    private requestFactory: InternalServerAssetAPIApiRequestFactory;
    private responseProcessor: InternalServerAssetAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServerAssetAPIApiRequestFactory,
        responseProcessor?: InternalServerAssetAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServerAssetAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServerAssetAPIApiResponseProcessor();
    }

    /**
     * scene：Fusion server query the attachment field data before writing
     * Get Asset Info
     * @param token resource key
     */
    public getWithHttpInfo(token: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAssetUploadResult>> {
        const requestContextPromise = this.requestFactory.get(token, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWithHttpInfo(rsp)));
            }));
    }

    /**
     * scene：Fusion server query the attachment field data before writing
     * Get Asset Info
     * @param token resource key
     */
    public get(token: string, _options?: Configuration): Observable<ResponseDataAssetUploadResult> {
        return this.getWithHttpInfo(token, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAssetUploadResult>) => apiResponse.data));
    }

    /**
     * Batch get asset signature url
     * @param resourceKeys
     */
    public getSignatureUrls1WithHttpInfo(resourceKeys: Array<string>, _options?: Configuration): Observable<HttpInfo<ResponseDataListAssetUrlSignatureVo>> {
        const requestContextPromise = this.requestFactory.getSignatureUrls1(resourceKeys, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSignatureUrls1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch get asset signature url
     * @param resourceKeys
     */
    public getSignatureUrls1(resourceKeys: Array<string>, _options?: Configuration): Observable<ResponseDataListAssetUrlSignatureVo> {
        return this.getSignatureUrls1WithHttpInfo(resourceKeys, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAssetUrlSignatureVo>) => apiResponse.data));
    }

    /**
     * Get Upload PreSigned URL
     * @param nodeId node custom id
     * @param count number to create (default 1, max 20)
     */
    public getSpaceCapacity1WithHttpInfo(nodeId: string, count?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListAssetUploadCertificateVO>> {
        const requestContextPromise = this.requestFactory.getSpaceCapacity1(nodeId, count, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceCapacity1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Upload PreSigned URL
     * @param nodeId node custom id
     * @param count number to create (default 1, max 20)
     */
    public getSpaceCapacity1(nodeId: string, count?: string, _options?: Configuration): Observable<ResponseDataListAssetUploadCertificateVO> {
        return this.getSpaceCapacity1WithHttpInfo(nodeId, count, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAssetUploadCertificateVO>) => apiResponse.data));
    }

}

import { InternalServerOrgAPIApiRequestFactory, InternalServerOrgAPIApiResponseProcessor} from "../apis/InternalServerOrgAPIApi";
export class ObservableInternalServerOrgAPIApi {
    private requestFactory: InternalServerOrgAPIApiRequestFactory;
    private responseProcessor: InternalServerOrgAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServerOrgAPIApiRequestFactory,
        responseProcessor?: InternalServerOrgAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServerOrgAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServerOrgAPIApiResponseProcessor();
    }

    /**
     * The most recently selected units are loaded by default when not keyword. The most recently added member of the same group are loaded when not selected. Load max 10
     * Load/search departments and members
     * @param params
     * @param xSpaceId space id
     * @param userId user id
     * @param keyword keyword
     * @param unitIds unitIds
     * @param filterIds specifies the organizational unit to filter
     * @param all whether to load all departments and members
     * @param searchEmail whether to search for emails
     */
    public loadOrSearch1WithHttpInfo(params: LoadSearchDTO, xSpaceId?: string, userId?: string, keyword?: string, unitIds?: string, filterIds?: string, all?: boolean, searchEmail?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataListUnitInfoVo>> {
        const requestContextPromise = this.requestFactory.loadOrSearch1(params, xSpaceId, userId, keyword, unitIds, filterIds, all, searchEmail, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.loadOrSearch1WithHttpInfo(rsp)));
            }));
    }

    /**
     * The most recently selected units are loaded by default when not keyword. The most recently added member of the same group are loaded when not selected. Load max 10
     * Load/search departments and members
     * @param params
     * @param xSpaceId space id
     * @param userId user id
     * @param keyword keyword
     * @param unitIds unitIds
     * @param filterIds specifies the organizational unit to filter
     * @param all whether to load all departments and members
     * @param searchEmail whether to search for emails
     */
    public loadOrSearch1(params: LoadSearchDTO, xSpaceId?: string, userId?: string, keyword?: string, unitIds?: string, filterIds?: string, all?: boolean, searchEmail?: boolean, _options?: Configuration): Observable<ResponseDataListUnitInfoVo> {
        return this.loadOrSearch1WithHttpInfo(params, xSpaceId, userId, keyword, unitIds, filterIds, all, searchEmail, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListUnitInfoVo>) => apiResponse.data));
    }

}

import { InternalServiceDataTableFieldPermissionInterfaceApiRequestFactory, InternalServiceDataTableFieldPermissionInterfaceApiResponseProcessor} from "../apis/InternalServiceDataTableFieldPermissionInterfaceApi";
type ModelString = string;
export class ObservableInternalServiceDataTableFieldPermissionInterfaceApi {
    private requestFactory: InternalServiceDataTableFieldPermissionInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceDataTableFieldPermissionInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceDataTableFieldPermissionInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceDataTableFieldPermissionInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceDataTableFieldPermissionInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceDataTableFieldPermissionInterfaceApiResponseProcessor();
    }

    /**
     * room layer ot delete field operation call
     * turn off multiple field permissions
     * @param dstId table id
     * @param fieldIds list of field ids
     */
    public disableRolesWithHttpInfo(dstId: ModelString, fieldIds: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.disableRoles(dstId, fieldIds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.disableRolesWithHttpInfo(rsp)));
            }));
    }

    /**
     * room layer ot delete field operation call
     * turn off multiple field permissions
     * @param dstId table id
     * @param fieldIds list of field ids
     */
    public disableRoles(dstId: ModelString, fieldIds: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.disableRolesWithHttpInfo(dstId, fieldIds, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * get field permissions
     * @param nodeId node id
     * @param userId user id
     * @param shareId share id
     */
    public getFieldPermissionWithHttpInfo(nodeId: string, userId: string, shareId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFieldPermissionView>> {
        const requestContextPromise = this.requestFactory.getFieldPermission(nodeId, userId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getFieldPermissionWithHttpInfo(rsp)));
            }));
    }

    /**
     * get field permissions
     * @param nodeId node id
     * @param userId user id
     * @param shareId share id
     */
    public getFieldPermission(nodeId: string, userId: string, shareId?: string, _options?: Configuration): Observable<ResponseDataFieldPermissionView> {
        return this.getFieldPermissionWithHttpInfo(nodeId, userId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFieldPermissionView>) => apiResponse.data));
    }

    /**
     * get field permission set for multiple nodes
     * @param internalPermissionRo
     */
    public getMultiFieldPermissionViewsWithHttpInfo(internalPermissionRo: InternalPermissionRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListFieldPermissionView>> {
        const requestContextPromise = this.requestFactory.getMultiFieldPermissionViews(internalPermissionRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMultiFieldPermissionViewsWithHttpInfo(rsp)));
            }));
    }

    /**
     * get field permission set for multiple nodes
     * @param internalPermissionRo
     */
    public getMultiFieldPermissionViews(internalPermissionRo: InternalPermissionRo, _options?: Configuration): Observable<ResponseDataListFieldPermissionView> {
        return this.getMultiFieldPermissionViewsWithHttpInfo(internalPermissionRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListFieldPermissionView>) => apiResponse.data));
    }

}

import { InternalServiceEnterpriseMicroInterfaceApiRequestFactory, InternalServiceEnterpriseMicroInterfaceApiResponseProcessor} from "../apis/InternalServiceEnterpriseMicroInterfaceApi";
export class ObservableInternalServiceEnterpriseMicroInterfaceApi {
    private requestFactory: InternalServiceEnterpriseMicroInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceEnterpriseMicroInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceEnterpriseMicroInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceEnterpriseMicroInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceEnterpriseMicroInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceEnterpriseMicroInterfaceApiResponseProcessor();
    }

    /**
     * Batch processing pending interface license delay information
     */
    public postPermitDelayBatchProcessWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postPermitDelayBatchProcess(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postPermitDelayBatchProcessWithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch processing pending interface license delay information
     */
    public postPermitDelayBatchProcess(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.postPermitDelayBatchProcessWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { InternalServiceFieldServiceInterfaceApiRequestFactory, InternalServiceFieldServiceInterfaceApiResponseProcessor} from "../apis/InternalServiceFieldServiceInterfaceApi";
export class ObservableInternalServiceFieldServiceInterfaceApi {
    private requestFactory: InternalServiceFieldServiceInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceFieldServiceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceFieldServiceInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceFieldServiceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceFieldServiceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceFieldServiceInterfaceApiResponseProcessor();
    }

    /**
     * get url related information
     * get url related information
     * @param urlsWrapperRo
     */
    public urlContentsAwareFillWithHttpInfo(urlsWrapperRo: UrlsWrapperRo, _options?: Configuration): Observable<HttpInfo<ResponseDataUrlAwareContentsVo>> {
        const requestContextPromise = this.requestFactory.urlContentsAwareFill(urlsWrapperRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.urlContentsAwareFillWithHttpInfo(rsp)));
            }));
    }

    /**
     * get url related information
     * get url related information
     * @param urlsWrapperRo
     */
    public urlContentsAwareFill(urlsWrapperRo: UrlsWrapperRo, _options?: Configuration): Observable<ResponseDataUrlAwareContentsVo> {
        return this.urlContentsAwareFillWithHttpInfo(urlsWrapperRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUrlAwareContentsVo>) => apiResponse.data));
    }

}

import { InternalServiceNodeInterfaceApiRequestFactory, InternalServiceNodeInterfaceApiResponseProcessor} from "../apis/InternalServiceNodeInterfaceApi";
export class ObservableInternalServiceNodeInterfaceApi {
    private requestFactory: InternalServiceNodeInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceNodeInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceNodeInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceNodeInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceNodeInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceNodeInterfaceApiResponseProcessor();
    }

    /**
     * create a table node
     * create a table node
     * @param createDatasheetRo
     * @param spaceId
     */
    public createDatasheetWithHttpInfo(createDatasheetRo: CreateDatasheetRo, spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataCreateDatasheetVo>> {
        const requestContextPromise = this.requestFactory.createDatasheet(createDatasheetRo, spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createDatasheetWithHttpInfo(rsp)));
            }));
    }

    /**
     * create a table node
     * create a table node
     * @param createDatasheetRo
     * @param spaceId
     */
    public createDatasheet(createDatasheetRo: CreateDatasheetRo, spaceId: string, _options?: Configuration): Observable<ResponseDataCreateDatasheetVo> {
        return this.createDatasheetWithHttpInfo(createDatasheetRo, spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataCreateDatasheetVo>) => apiResponse.data));
    }

    /**
     * delete node
     * delete node
     * @param spaceId
     * @param nodeId
     */
    public deleteNodeWithHttpInfo(spaceId: string, nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteNode(spaceId, nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteNodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * delete node
     * delete node
     * @param spaceId
     * @param nodeId
     */
    public deleteNode(spaceId: string, nodeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteNodeWithHttpInfo(spaceId, nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * scenario: query an existing read-only dashboard
     * Get filter nodes by type, permissions and node name.
     * @param spaceId
     * @param type
     * @param nodePermissions
     * @param keyword
     */
    public filterWithHttpInfo(spaceId: string, type: number, nodePermissions?: Array<number>, keyword?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfo>> {
        const requestContextPromise = this.requestFactory.filter(spaceId, type, nodePermissions, keyword, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.filterWithHttpInfo(rsp)));
            }));
    }

    /**
     * scenario: query an existing read-only dashboard
     * Get filter nodes by type, permissions and node name.
     * @param spaceId
     * @param type
     * @param nodePermissions
     * @param keyword
     */
    public filter(spaceId: string, type: number, nodePermissions?: Array<number>, keyword?: string, _options?: Configuration): Observable<ResponseDataListNodeInfo> {
        return this.filterWithHttpInfo(spaceId, type, nodePermissions, keyword, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfo>) => apiResponse.data));
    }

}

import { InternalServiceNodePermissionInterfaceApiRequestFactory, InternalServiceNodePermissionInterfaceApiResponseProcessor} from "../apis/InternalServiceNodePermissionInterfaceApi";
export class ObservableInternalServiceNodePermissionInterfaceApi {
    private requestFactory: InternalServiceNodePermissionInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceNodePermissionInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceNodePermissionInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceNodePermissionInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceNodePermissionInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceNodePermissionInterfaceApiResponseProcessor();
    }

    /**
     * Get permission set for multiple nodes
     * @param internalPermissionRo
     */
    public getMultiNodePermissionsWithHttpInfo(internalPermissionRo: InternalPermissionRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListDatasheetPermissionView>> {
        const requestContextPromise = this.requestFactory.getMultiNodePermissions(internalPermissionRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMultiNodePermissionsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get permission set for multiple nodes
     * @param internalPermissionRo
     */
    public getMultiNodePermissions(internalPermissionRo: InternalPermissionRo, _options?: Configuration): Observable<ResponseDataListDatasheetPermissionView> {
        return this.getMultiNodePermissionsWithHttpInfo(internalPermissionRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListDatasheetPermissionView>) => apiResponse.data));
    }

    /**
     * Get Node permission
     * @param nodeId Node ID
     * @param shareId Share ID
     */
    public getNodePermissionWithHttpInfo(nodeId: string, shareId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDatasheetPermissionView>> {
        const requestContextPromise = this.requestFactory.getNodePermission(nodeId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getNodePermissionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Node permission
     * @param nodeId Node ID
     * @param shareId Share ID
     */
    public getNodePermission(nodeId: string, shareId?: string, _options?: Configuration): Observable<ResponseDataDatasheetPermissionView> {
        return this.getNodePermissionWithHttpInfo(nodeId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDatasheetPermissionView>) => apiResponse.data));
    }

}

import { InternalServiceNotificationInterfaceApiRequestFactory, InternalServiceNotificationInterfaceApiResponseProcessor} from "../apis/InternalServiceNotificationInterfaceApi";
export class ObservableInternalServiceNotificationInterfaceApi {
    private requestFactory: InternalServiceNotificationInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceNotificationInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceNotificationInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceNotificationInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceNotificationInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceNotificationInterfaceApiResponseProcessor();
    }

    /**
     * send a message
     * send a message
     * @param notificationCreateRo
     */
    public create7WithHttpInfo(notificationCreateRo: Array<NotificationCreateRo>, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.create7(notificationCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create7WithHttpInfo(rsp)));
            }));
    }

    /**
     * send a message
     * send a message
     * @param notificationCreateRo
     */
    public create7(notificationCreateRo: Array<NotificationCreateRo>, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.create7WithHttpInfo(notificationCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { InternalServiceSpaceInterfaceApiRequestFactory, InternalServiceSpaceInterfaceApiResponseProcessor} from "../apis/InternalServiceSpaceInterfaceApi";
export class ObservableInternalServiceSpaceInterfaceApi {
    private requestFactory: InternalServiceSpaceInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceSpaceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceSpaceInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceSpaceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceSpaceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceSpaceInterfaceApiResponseProcessor();
    }

    /**
     * Provides the authentication function of the middle layer request, and queries the API aps information in the subscription plan corresponding to the space.
     * get api qps information of a specified space
     * @param spaceId
     */
    public apiRateLimitWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceApiRateLimitVo>> {
        const requestContextPromise = this.requestFactory.apiRateLimit(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.apiRateLimitWithHttpInfo(rsp)));
            }));
    }

    /**
     * Provides the authentication function of the middle layer request, and queries the API aps information in the subscription plan corresponding to the space.
     * get api qps information of a specified space
     * @param spaceId
     */
    public apiRateLimit(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceApiRateLimitVo> {
        return this.apiRateLimitWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceApiRateLimitVo>) => apiResponse.data));
    }

    /**
     * Provides the authentication function of the middle layer request, and queries the API usage information in the subscription plan corresponding to the space.
     * get api usage information of a specified space
     * @param spaceId
     */
    public apiUsagesWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceApiUsageVo>> {
        const requestContextPromise = this.requestFactory.apiUsages(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.apiUsagesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Provides the authentication function of the middle layer request, and queries the API usage information in the subscription plan corresponding to the space.
     * get api usage information of a specified space
     * @param spaceId
     */
    public apiUsages(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceApiUsageVo> {
        return this.apiUsagesWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceApiUsageVo>) => apiResponse.data));
    }

    /**
     * get space automation run message
     * @param spaceId space id
     */
    public getAutomationRunMessageWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceAutomationRunMessageV0>> {
        const requestContextPromise = this.requestFactory.getAutomationRunMessage(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAutomationRunMessageWithHttpInfo(rsp)));
            }));
    }

    /**
     * get space automation run message
     * @param spaceId space id
     */
    public getAutomationRunMessage(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceAutomationRunMessageV0> {
        return this.getAutomationRunMessageWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceAutomationRunMessageV0>) => apiResponse.data));
    }

    /**
     * get space credit used usage
     * @param spaceId space id
     */
    public getCreditUsages1WithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalCreditUsageVo>> {
        const requestContextPromise = this.requestFactory.getCreditUsages1(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCreditUsages1WithHttpInfo(rsp)));
            }));
    }

    /**
     * get space credit used usage
     * @param spaceId space id
     */
    public getCreditUsages1(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalCreditUsageVo> {
        return this.getCreditUsages1WithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalCreditUsageVo>) => apiResponse.data));
    }

    /**
     * get attachment capacity information for a space
     * @param spaceId space id
     */
    public getSpaceCapacityWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceCapacityVo>> {
        const requestContextPromise = this.requestFactory.getSpaceCapacity(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceCapacityWithHttpInfo(rsp)));
            }));
    }

    /**
     * get attachment capacity information for a space
     * @param spaceId space id
     */
    public getSpaceCapacity(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceCapacityVo> {
        return this.getSpaceCapacityWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceCapacityVo>) => apiResponse.data));
    }

    /**
     * get subscription information for a space
     * @param spaceId space id
     */
    public getSpaceSubscriptionWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceSubscriptionVo>> {
        const requestContextPromise = this.requestFactory.getSpaceSubscription(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceSubscriptionWithHttpInfo(rsp)));
            }));
    }

    /**
     * get subscription information for a space
     * @param spaceId space id
     */
    public getSpaceSubscription(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceSubscriptionVo> {
        return this.getSpaceSubscriptionWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceSubscriptionVo>) => apiResponse.data));
    }

    /**
     * get space used usage information
     * @param spaceId space id
     */
    public getSpaceUsagesWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceUsageVo>> {
        const requestContextPromise = this.requestFactory.getSpaceUsages(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceUsagesWithHttpInfo(rsp)));
            }));
    }

    /**
     * get space used usage information
     * @param spaceId space id
     */
    public getSpaceUsages(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceUsageVo> {
        return this.getSpaceUsagesWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceUsageVo>) => apiResponse.data));
    }

    /**
     * get space information
     * @param spaceId
     */
    public labsWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInternalSpaceInfoVo>> {
        const requestContextPromise = this.requestFactory.labs(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.labsWithHttpInfo(rsp)));
            }));
    }

    /**
     * get space information
     * @param spaceId
     */
    public labs(spaceId: string, _options?: Configuration): Observable<ResponseDataInternalSpaceInfoVo> {
        return this.labsWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInternalSpaceInfoVo>) => apiResponse.data));
    }

    /**
     * get space information
     * @param spaceStatisticsRo
     * @param spaceId
     */
    public statisticsWithHttpInfo(spaceStatisticsRo: SpaceStatisticsRo, spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.statistics(spaceStatisticsRo, spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.statisticsWithHttpInfo(rsp)));
            }));
    }

    /**
     * get space information
     * @param spaceStatisticsRo
     * @param spaceId
     */
    public statistics(spaceStatisticsRo: SpaceStatisticsRo, spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.statisticsWithHttpInfo(spaceStatisticsRo, spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { InternalServiceUserInterfaceApiRequestFactory, InternalServiceUserInterfaceApiResponseProcessor} from "../apis/InternalServiceUserInterfaceApi";
export class ObservableInternalServiceUserInterfaceApi {
    private requestFactory: InternalServiceUserInterfaceApiRequestFactory;
    private responseProcessor: InternalServiceUserInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InternalServiceUserInterfaceApiRequestFactory,
        responseProcessor?: InternalServiceUserInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InternalServiceUserInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InternalServiceUserInterfaceApiResponseProcessor();
    }

    /**
     * Close and log off the cooling-off period user account
     * Close and log off the cooling-off period user account
     * @param userId
     */
    public closePausedUserAccountWithHttpInfo(userId: number, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.closePausedUserAccount(userId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.closePausedUserAccountWithHttpInfo(rsp)));
            }));
    }

    /**
     * Close and log off the cooling-off period user account
     * Close and log off the cooling-off period user account
     * @param userId
     */
    public closePausedUserAccount(userId: number, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.closePausedUserAccountWithHttpInfo(userId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * get cooling off users
     * get cooling off users
     */
    public getPausedUsersWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListUserInPausedDto>> {
        const requestContextPromise = this.requestFactory.getPausedUsers(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getPausedUsersWithHttpInfo(rsp)));
            }));
    }

    /**
     * get cooling off users
     * get cooling off users
     */
    public getPausedUsers(_options?: Configuration): Observable<ResponseDataListUserInPausedDto> {
        return this.getPausedUsersWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListUserInPausedDto>) => apiResponse.data));
    }

    /**
     * get the cooling-off period user operation record
     * get the cooling-off period user operation record
     * @param pausedUserHistoryRo
     */
    public getUserHistoriesWithHttpInfo(pausedUserHistoryRo: PausedUserHistoryRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListPausedUserHistoryDto>> {
        const requestContextPromise = this.requestFactory.getUserHistories(pausedUserHistoryRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getUserHistoriesWithHttpInfo(rsp)));
            }));
    }

    /**
     * get the cooling-off period user operation record
     * get the cooling-off period user operation record
     * @param pausedUserHistoryRo
     */
    public getUserHistories(pausedUserHistoryRo: PausedUserHistoryRo, _options?: Configuration): Observable<ResponseDataListPausedUserHistoryDto> {
        return this.getUserHistoriesWithHttpInfo(pausedUserHistoryRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListPausedUserHistoryDto>) => apiResponse.data));
    }

    /**
     * get the necessary information
     * check whether logged in
     */
    public meSessionWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.meSession(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.meSessionWithHttpInfo(rsp)));
            }));
    }

    /**
     * get the necessary information
     * check whether logged in
     */
    public meSession(_options?: Configuration): Observable<ResponseDataBoolean> {
        return this.meSessionWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * get the necessary information
     * get the necessary information
     */
    public userBaseInfoWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataUserBaseInfoVo>> {
        const requestContextPromise = this.requestFactory.userBaseInfo(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userBaseInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * get the necessary information
     * get the necessary information
     */
    public userBaseInfo(_options?: Configuration): Observable<ResponseDataUserBaseInfoVo> {
        return this.userBaseInfoWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataUserBaseInfoVo>) => apiResponse.data));
    }

}

import { K11LoginInterfaceApiRequestFactory, K11LoginInterfaceApiResponseProcessor} from "../apis/K11LoginInterfaceApi";
export class ObservableK11LoginInterfaceApi {
    private requestFactory: K11LoginInterfaceApiRequestFactory;
    private responseProcessor: K11LoginInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: K11LoginInterfaceApiRequestFactory,
        responseProcessor?: K11LoginInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new K11LoginInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new K11LoginInterfaceApiResponseProcessor();
    }

    /**
     * k11 Synchronous login with token
     * @param token
     */
    public loginBySsoTokenWithHttpInfo(token: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.loginBySsoToken(token, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.loginBySsoTokenWithHttpInfo(rsp)));
            }));
    }

    /**
     * k11 Synchronous login with token
     * @param token
     */
    public loginBySsoToken(token: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.loginBySsoTokenWithHttpInfo(token, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { LaboratoryModuleExperimentalFunctionInterfaceApiRequestFactory, LaboratoryModuleExperimentalFunctionInterfaceApiResponseProcessor} from "../apis/LaboratoryModuleExperimentalFunctionInterfaceApi";
export class ObservableLaboratoryModuleExperimentalFunctionInterfaceApi {
    private requestFactory: LaboratoryModuleExperimentalFunctionInterfaceApiRequestFactory;
    private responseProcessor: LaboratoryModuleExperimentalFunctionInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: LaboratoryModuleExperimentalFunctionInterfaceApiRequestFactory,
        responseProcessor?: LaboratoryModuleExperimentalFunctionInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new LaboratoryModuleExperimentalFunctionInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new LaboratoryModuleExperimentalFunctionInterfaceApiResponseProcessor();
    }

    /**
     * Get Lab Function List
     */
    public showAvailableLabsFeaturesWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataUserSpaceLabsFeatureVo>> {
        const requestContextPromise = this.requestFactory.showAvailableLabsFeatures(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showAvailableLabsFeaturesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Lab Function List
     */
    public showAvailableLabsFeatures(_options?: Configuration): Observable<ResponseDataUserSpaceLabsFeatureVo> {
        return this.showAvailableLabsFeaturesWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataUserSpaceLabsFeatureVo>) => apiResponse.data));
    }

}

import { LarkInterfaceApiRequestFactory, LarkInterfaceApiResponseProcessor} from "../apis/LarkInterfaceApi";
export class ObservableLarkInterfaceApi {
    private requestFactory: LarkInterfaceApiRequestFactory;
    private responseProcessor: LarkInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: LarkInterfaceApiRequestFactory,
        responseProcessor?: LarkInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new LarkInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new LarkInterfaceApiResponseProcessor();
    }

    /**
     * Replace the master administrator
     * Tenant space replacement master administrator
     * @param feishuTenantMainAdminChangeRo
     */
    public changeAdminWithHttpInfo(feishuTenantMainAdminChangeRo: FeishuTenantMainAdminChangeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.changeAdmin(feishuTenantMainAdminChangeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.changeAdminWithHttpInfo(rsp)));
            }));
    }

    /**
     * Replace the master administrator
     * Tenant space replacement master administrator
     * @param feishuTenantMainAdminChangeRo
     */
    public changeAdmin(feishuTenantMainAdminChangeRo: FeishuTenantMainAdminChangeRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.changeAdminWithHttpInfo(feishuTenantMainAdminChangeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get the space information bound by the tenant
     * Get tenant binding information
     * @param tenantKey Lark Tenant ID
     */
    public getTenantInfo1WithHttpInfo(tenantKey: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFeishuTenantDetailVO>> {
        const requestContextPromise = this.requestFactory.getTenantInfo1(tenantKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTenantInfo1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the space information bound by the tenant
     * Get tenant binding information
     * @param tenantKey Lark Tenant ID
     */
    public getTenantInfo1(tenantKey: string, _options?: Configuration): Observable<ResponseDataFeishuTenantDetailVO> {
        return this.getTenantInfo1WithHttpInfo(tenantKey, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFeishuTenantDetailVO>) => apiResponse.data));
    }

}

import { MigrationResourcesAPIApiRequestFactory, MigrationResourcesAPIApiResponseProcessor} from "../apis/MigrationResourcesAPIApi";
export class ObservableMigrationResourcesAPIApi {
    private requestFactory: MigrationResourcesAPIApiRequestFactory;
    private responseProcessor: MigrationResourcesAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MigrationResourcesAPIApiRequestFactory,
        responseProcessor?: MigrationResourcesAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MigrationResourcesAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MigrationResourcesAPIApiResponseProcessor();
    }

    /**
     * migration resources
     * @param migrationResourcesRo
     */
    public migrationResourcesWithHttpInfo(migrationResourcesRo: MigrationResourcesRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.migrationResources(migrationResourcesRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.migrationResourcesWithHttpInfo(rsp)));
            }));
    }

    /**
     * migration resources
     * @param migrationResourcesRo
     */
    public migrationResources(migrationResourcesRo: MigrationResourcesRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.migrationResourcesWithHttpInfo(migrationResourcesRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { OfficeOperationAPIApiRequestFactory, OfficeOperationAPIApiResponseProcessor} from "../apis/OfficeOperationAPIApi";
export class ObservableOfficeOperationAPIApi {
    private requestFactory: OfficeOperationAPIApiRequestFactory;
    private responseProcessor: OfficeOperationAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: OfficeOperationAPIApiRequestFactory,
        responseProcessor?: OfficeOperationAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new OfficeOperationAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new OfficeOperationAPIApiResponseProcessor();
    }

    /**
     * Office document preview conversion,call Yongzhong office conversion interface
     * Office document preview conversion
     * @param attachOfficePreviewRo
     * @param spaceId
     */
    public officePreviewWithHttpInfo(attachOfficePreviewRo: AttachOfficePreviewRo, spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.officePreview(attachOfficePreviewRo, spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.officePreviewWithHttpInfo(rsp)));
            }));
    }

    /**
     * Office document preview conversion,call Yongzhong office conversion interface
     * Office document preview conversion
     * @param attachOfficePreviewRo
     * @param spaceId
     */
    public officePreview(attachOfficePreviewRo: AttachOfficePreviewRo, spaceId: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.officePreviewWithHttpInfo(attachOfficePreviewRo, spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { OpenApiApiRequestFactory, OpenApiApiResponseProcessor} from "../apis/OpenApiApi";
export class ObservableOpenApiApi {
    private requestFactory: OpenApiApiRequestFactory;
    private responseProcessor: OpenApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: OpenApiApiRequestFactory,
        responseProcessor?: OpenApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new OpenApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new OpenApiApiResponseProcessor();
    }

    /**
     * Get information that the applet can expose
     * Get information that the applet can expose
     * @param widgetId
     */
    public validateApiKey1WithHttpInfo(widgetId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWidgetInfoVo>> {
        const requestContextPromise = this.requestFactory.validateApiKey1(widgetId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validateApiKey1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get information that the applet can expose
     * Get information that the applet can expose
     * @param widgetId
     */
    public validateApiKey1(widgetId: string, _options?: Configuration): Observable<ResponseDataWidgetInfoVo> {
        return this.validateApiKey1WithHttpInfo(widgetId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetInfoVo>) => apiResponse.data));
    }

}

import { PlayerSystemActivityAPIApiRequestFactory, PlayerSystemActivityAPIApiResponseProcessor} from "../apis/PlayerSystemActivityAPIApi";
export class ObservablePlayerSystemActivityAPIApi {
    private requestFactory: PlayerSystemActivityAPIApiRequestFactory;
    private responseProcessor: PlayerSystemActivityAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PlayerSystemActivityAPIApiRequestFactory,
        responseProcessor?: PlayerSystemActivityAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PlayerSystemActivityAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PlayerSystemActivityAPIApiResponseProcessor();
    }

    /**
     * Scene: After triggering the guided click event, modify the state or the cumulative number of times.
     * Trigger Wizard
     * @param activityStatusRo
     */
    public triggerWizardWithHttpInfo(activityStatusRo: ActivityStatusRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.triggerWizard(activityStatusRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.triggerWizardWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scene: After triggering the guided click event, modify the state or the cumulative number of times.
     * Trigger Wizard
     * @param activityStatusRo
     */
    public triggerWizard(activityStatusRo: ActivityStatusRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.triggerWizardWithHttpInfo(activityStatusRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { PlayerSystemNotificationAPIApiRequestFactory, PlayerSystemNotificationAPIApiResponseProcessor} from "../apis/PlayerSystemNotificationAPIApi";
export class ObservablePlayerSystemNotificationAPIApi {
    private requestFactory: PlayerSystemNotificationAPIApiRequestFactory;
    private responseProcessor: PlayerSystemNotificationAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: PlayerSystemNotificationAPIApiRequestFactory,
        responseProcessor?: PlayerSystemNotificationAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new PlayerSystemNotificationAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new PlayerSystemNotificationAPIApiResponseProcessor();
    }

    /**
     * Create Notification
     * @param notificationCreateRo
     */
    public create5WithHttpInfo(notificationCreateRo: Array<NotificationCreateRo>, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.create5(notificationCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create5WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Notification
     * @param notificationCreateRo
     */
    public create5(notificationCreateRo: Array<NotificationCreateRo>, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.create5WithHttpInfo(notificationCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete Notification
     * @param notificationReadRo
     */
    public delete10WithHttpInfo(notificationReadRo: NotificationReadRo, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.delete10(notificationReadRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete10WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Notification
     * @param notificationReadRo
     */
    public delete10(notificationReadRo: NotificationReadRo, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.delete10WithHttpInfo(notificationReadRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * Default: System Notification
     * Get Notification Detail List
     * @param notificationListRo
     */
    public list4WithHttpInfo(notificationListRo: NotificationListRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListNotificationDetailVo>> {
        const requestContextPromise = this.requestFactory.list4(notificationListRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list4WithHttpInfo(rsp)));
            }));
    }

    /**
     * Default: System Notification
     * Get Notification Detail List
     * @param notificationListRo
     */
    public list4(notificationListRo: NotificationListRo, _options?: Configuration): Observable<ResponseDataListNotificationDetailVo> {
        return this.list4WithHttpInfo(notificationListRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNotificationDetailVo>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Get Notification Page Info
     * @param notificationPageRo
     */
    public page3WithHttpInfo(notificationPageRo: NotificationPageRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListNotificationDetailVo>> {
        const requestContextPromise = this.requestFactory.page3(notificationPageRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.page3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Get Notification Page Info
     * @param notificationPageRo
     */
    public page3(notificationPageRo: NotificationPageRo, _options?: Configuration): Observable<ResponseDataListNotificationDetailVo> {
        return this.page3WithHttpInfo(notificationPageRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNotificationDetailVo>) => apiResponse.data));
    }

    /**
     * Mark Notification Read
     * @param notificationReadRo
     */
    public readWithHttpInfo(notificationReadRo: NotificationReadRo, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.read(notificationReadRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readWithHttpInfo(rsp)));
            }));
    }

    /**
     * Mark Notification Read
     * @param notificationReadRo
     */
    public read(notificationReadRo: NotificationReadRo, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.readWithHttpInfo(notificationReadRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * Get Notification\' Statistics
     */
    public statistics1WithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataNotificationStatisticsVo>> {
        const requestContextPromise = this.requestFactory.statistics1(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.statistics1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Notification\' Statistics
     */
    public statistics1(_options?: Configuration): Observable<ResponseDataNotificationStatisticsVo> {
        return this.statistics1WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataNotificationStatisticsVo>) => apiResponse.data));
    }

}

import { ProductControllerApiRequestFactory, ProductControllerApiResponseProcessor} from "../apis/ProductControllerApi";
export class ObservableProductControllerApi {
    private requestFactory: ProductControllerApiRequestFactory;
    private responseProcessor: ProductControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ProductControllerApiRequestFactory,
        responseProcessor?: ProductControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ProductControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ProductControllerApiResponseProcessor();
    }

    /**
     */
    public getListWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListProductVO>> {
        const requestContextPromise = this.requestFactory.getList(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getListWithHttpInfo(rsp)));
            }));
    }

    /**
     */
    public getList(_options?: Configuration): Observable<ResponseDataListProductVO> {
        return this.getListWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListProductVO>) => apiResponse.data));
    }

}

import { ProductOperationSystemAPIApiRequestFactory, ProductOperationSystemAPIApiResponseProcessor} from "../apis/ProductOperationSystemAPIApi";
export class ObservableProductOperationSystemAPIApi {
    private requestFactory: ProductOperationSystemAPIApiRequestFactory;
    private responseProcessor: ProductOperationSystemAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ProductOperationSystemAPIApiRequestFactory,
        responseProcessor?: ProductOperationSystemAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ProductOperationSystemAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ProductOperationSystemAPIApiResponseProcessor();
    }

    /**
     * Indicates the attachment resource of the specified template. Users refer to this part of the resource without occupying the space station capacity
     * Template Asset Remark
     * @param templateId Template Custom ID
     * @param isReversed Whether it is a reverse operation, that is, cancel the flag (default false)
     */
    public markTemplateAssetWithHttpInfo(templateId: string, isReversed?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.markTemplateAsset(templateId, isReversed, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.markTemplateAssetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Indicates the attachment resource of the specified template. Users refer to this part of the resource without occupying the space station capacity
     * Template Asset Remark
     * @param templateId Template Custom ID
     * @param isReversed Whether it is a reverse operation, that is, cancel the flag (default false)
     */
    public markTemplateAsset(templateId: string, isReversed?: boolean, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.markTemplateAssetWithHttpInfo(templateId, isReversed, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ProductOperationSystemTemplateAPIApiRequestFactory, ProductOperationSystemTemplateAPIApiResponseProcessor} from "../apis/ProductOperationSystemTemplateAPIApi";
export class ObservableProductOperationSystemTemplateAPIApi {
    private requestFactory: ProductOperationSystemTemplateAPIApiRequestFactory;
    private responseProcessor: ProductOperationSystemTemplateAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ProductOperationSystemTemplateAPIApiRequestFactory,
        responseProcessor?: ProductOperationSystemTemplateAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ProductOperationSystemTemplateAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ProductOperationSystemTemplateAPIApiResponseProcessor();
    }

    /**
     * Only supply to people in template space
     * Create Template Category
     * @param templateCategoryCreateRo
     */
    public createTemplateCategoryWithHttpInfo(templateCategoryCreateRo: TemplateCategoryCreateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.createTemplateCategory(templateCategoryCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createTemplateCategoryWithHttpInfo(rsp)));
            }));
    }

    /**
     * Only supply to people in template space
     * Create Template Category
     * @param templateCategoryCreateRo
     */
    public createTemplateCategory(templateCategoryCreateRo: TemplateCategoryCreateRo, _options?: Configuration): Observable<ResponseDataString> {
        return this.createTemplateCategoryWithHttpInfo(templateCategoryCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Only supply to people in template space
     * Delete Template Category
     * @param categoryCode
     */
    public deleteTemplateCategoryWithHttpInfo(categoryCode: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteTemplateCategory(categoryCode, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteTemplateCategoryWithHttpInfo(rsp)));
            }));
    }

    /**
     * Only supply to people in template space
     * Delete Template Category
     * @param categoryCode
     */
    public deleteTemplateCategory(categoryCode: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteTemplateCategoryWithHttpInfo(categoryCode, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Only supply to people in template space
     * Publish Template in Specified Template Category
     * @param templatePublishRo
     * @param templateId template id
     */
    public publishWithHttpInfo(templatePublishRo: TemplatePublishRo, templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.publish(templatePublishRo, templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.publishWithHttpInfo(rsp)));
            }));
    }

    /**
     * Only supply to people in template space
     * Publish Template in Specified Template Category
     * @param templatePublishRo
     * @param templateId template id
     */
    public publish(templatePublishRo: TemplatePublishRo, templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.publishWithHttpInfo(templatePublishRo, templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Only supply to people in template space
     * UnPublish Template
     * @param templateUnpublishRo
     * @param templateId template id
     */
    public unpublishWithHttpInfo(templateUnpublishRo: TemplateUnpublishRo, templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unpublish(templateUnpublishRo, templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unpublishWithHttpInfo(rsp)));
            }));
    }

    /**
     * Only supply to people in template space
     * UnPublish Template
     * @param templateUnpublishRo
     * @param templateId template id
     */
    public unpublish(templateUnpublishRo: TemplateUnpublishRo, templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unpublishWithHttpInfo(templateUnpublishRo, templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ProductOperationSystemUserAPIApiRequestFactory, ProductOperationSystemUserAPIApiResponseProcessor} from "../apis/ProductOperationSystemUserAPIApi";
export class ObservableProductOperationSystemUserAPIApi {
    private requestFactory: ProductOperationSystemUserAPIApiRequestFactory;
    private responseProcessor: ProductOperationSystemUserAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ProductOperationSystemUserAPIApiRequestFactory,
        responseProcessor?: ProductOperationSystemUserAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ProductOperationSystemUserAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ProductOperationSystemUserAPIApiResponseProcessor();
    }

    /**
     * Only supply to customized customers
     * Update Appoint Account Password
     * @param registerRO
     */
    public updatePwd1WithHttpInfo(registerRO: RegisterRO, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updatePwd1(registerRO, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updatePwd1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Only supply to customized customers
     * Update Appoint Account Password
     * @param registerRO
     */
    public updatePwd1(registerRO: RegisterRO, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updatePwd1WithHttpInfo(registerRO, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { SpaceApplyJoiningSpaceApiApiRequestFactory, SpaceApplyJoiningSpaceApiApiResponseProcessor} from "../apis/SpaceApplyJoiningSpaceApiApi";
export class ObservableSpaceApplyJoiningSpaceApiApi {
    private requestFactory: SpaceApplyJoiningSpaceApiApiRequestFactory;
    private responseProcessor: SpaceApplyJoiningSpaceApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceApplyJoiningSpaceApiApiRequestFactory,
        responseProcessor?: SpaceApplyJoiningSpaceApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceApplyJoiningSpaceApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceApplyJoiningSpaceApiApiResponseProcessor();
    }

    /**
     * Applying to join the space
     * @param spaceJoinApplyRo
     */
    public applyWithHttpInfo(spaceJoinApplyRo: SpaceJoinApplyRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.apply(spaceJoinApplyRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.applyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Applying to join the space
     * @param spaceJoinApplyRo
     */
    public apply(spaceJoinApplyRo: SpaceJoinApplyRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.applyWithHttpInfo(spaceJoinApplyRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Process joining application
     * @param spaceJoinProcessRo
     */
    public processWithHttpInfo(spaceJoinProcessRo: SpaceJoinProcessRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.process(spaceJoinProcessRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.processWithHttpInfo(rsp)));
            }));
    }

    /**
     * Process joining application
     * @param spaceJoinProcessRo
     */
    public process(spaceJoinProcessRo: SpaceJoinProcessRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.processWithHttpInfo(spaceJoinProcessRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { SpaceAuditApiApiRequestFactory, SpaceAuditApiApiResponseProcessor} from "../apis/SpaceAuditApiApi";
export class ObservableSpaceAuditApiApi {
    private requestFactory: SpaceAuditApiApiRequestFactory;
    private responseProcessor: SpaceAuditApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceAuditApiApiRequestFactory,
        responseProcessor?: SpaceAuditApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceAuditApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceAuditApiApiResponseProcessor();
    }

    /**
     * Query space audit logs in pages
     * @param spaceId space id
     * @param beginTime beginTime(format：yyyy-MM-dd HH:mm:ss)
     * @param endTime endTime(format：yyyy-MM-dd HH:mm:ss)
     * @param memberIds member ids
     * @param actions actions
     * @param keyword keyword
     * @param pageNo page no(default 1)
     * @param pageSize page size(default 20，max 100)
     */
    public auditWithHttpInfo(spaceId: string, beginTime?: Date, endTime?: Date, memberIds?: string, actions?: string, keyword?: string, pageNo?: number, pageSize?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoSpaceAuditPageVO>> {
        const requestContextPromise = this.requestFactory.audit(spaceId, beginTime, endTime, memberIds, actions, keyword, pageNo, pageSize, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.auditWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query space audit logs in pages
     * @param spaceId space id
     * @param beginTime beginTime(format：yyyy-MM-dd HH:mm:ss)
     * @param endTime endTime(format：yyyy-MM-dd HH:mm:ss)
     * @param memberIds member ids
     * @param actions actions
     * @param keyword keyword
     * @param pageNo page no(default 1)
     * @param pageSize page size(default 20，max 100)
     */
    public audit(spaceId: string, beginTime?: Date, endTime?: Date, memberIds?: string, actions?: string, keyword?: string, pageNo?: number, pageSize?: number, _options?: Configuration): Observable<ResponseDataPageInfoSpaceAuditPageVO> {
        return this.auditWithHttpInfo(spaceId, beginTime, endTime, memberIds, actions, keyword, pageNo, pageSize, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoSpaceAuditPageVO>) => apiResponse.data));
    }

}

import { SpaceInviteLinkApiApiRequestFactory, SpaceInviteLinkApiApiResponseProcessor} from "../apis/SpaceInviteLinkApiApi";
export class ObservableSpaceInviteLinkApiApi {
    private requestFactory: SpaceInviteLinkApiApiRequestFactory;
    private responseProcessor: SpaceInviteLinkApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceInviteLinkApiApiRequestFactory,
        responseProcessor?: SpaceInviteLinkApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceInviteLinkApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceInviteLinkApiApiResponseProcessor();
    }

    /**
     * Delete link
     * @param spaceLinkOpRo
     * @param xSpaceId space id
     */
    public delete15WithHttpInfo(spaceLinkOpRo: SpaceLinkOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete15(spaceLinkOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete15WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete link
     * @param spaceLinkOpRo
     * @param xSpaceId space id
     */
    public delete15(spaceLinkOpRo: SpaceLinkOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete15WithHttpInfo(spaceLinkOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * return token，the front end stitching $DOMAIN/invite/link?token=:token
     * Generate or refresh link
     * @param spaceLinkOpRo
     * @param xSpaceId space id
     */
    public generateWithHttpInfo(spaceLinkOpRo: SpaceLinkOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.generate(spaceLinkOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.generateWithHttpInfo(rsp)));
            }));
    }

    /**
     * return token，the front end stitching $DOMAIN/invite/link?token=:token
     * Generate or refresh link
     * @param spaceLinkOpRo
     * @param xSpaceId space id
     */
    public generate(spaceLinkOpRo: SpaceLinkOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.generateWithHttpInfo(spaceLinkOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * If return code status 201,the user redirects to the login page due to unauthorized.
     * Join the space using the public link
     * @param inviteValidRo
     */
    public joinWithHttpInfo(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.join(inviteValidRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.joinWithHttpInfo(rsp)));
            }));
    }

    /**
     * If return code status 201,the user redirects to the login page due to unauthorized.
     * Join the space using the public link
     * @param inviteValidRo
     */
    public join(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.joinWithHttpInfo(inviteValidRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get a list of links
     * @param xSpaceId space id
     */
    public list3WithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListSpaceLinkVo>> {
        const requestContextPromise = this.requestFactory.list3(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get a list of links
     * @param xSpaceId space id
     */
    public list3(xSpaceId: string, _options?: Configuration): Observable<ResponseDataListSpaceLinkVo> {
        return this.list3WithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListSpaceLinkVo>) => apiResponse.data));
    }

    /**
     * After the verification is successful, it can obtain related invitation information
     * Valid invite link token
     * @param inviteValidRo
     */
    public validWithHttpInfo(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceLinkInfoVo>> {
        const requestContextPromise = this.requestFactory.valid(inviteValidRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validWithHttpInfo(rsp)));
            }));
    }

    /**
     * After the verification is successful, it can obtain related invitation information
     * Valid invite link token
     * @param inviteValidRo
     */
    public valid(inviteValidRo: InviteValidRo, _options?: Configuration): Observable<ResponseDataSpaceLinkInfoVo> {
        return this.validWithHttpInfo(inviteValidRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceLinkInfoVo>) => apiResponse.data));
    }

}

import { SpaceMainAdminApiApiRequestFactory, SpaceMainAdminApiApiResponseProcessor} from "../apis/SpaceMainAdminApiApi";
export class ObservableSpaceMainAdminApiApi {
    private requestFactory: SpaceMainAdminApiApiRequestFactory;
    private responseProcessor: SpaceMainAdminApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceMainAdminApiApiRequestFactory,
        responseProcessor?: SpaceMainAdminApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceMainAdminApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceMainAdminApiApiResponseProcessor();
    }

    /**
     * Get main admin info
     * @param xSpaceId space id
     */
    public getMainAdminInfoWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataMainAdminInfoVo>> {
        const requestContextPromise = this.requestFactory.getMainAdminInfo(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMainAdminInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get main admin info
     * @param xSpaceId space id
     */
    public getMainAdminInfo(xSpaceId: string, _options?: Configuration): Observable<ResponseDataMainAdminInfoVo> {
        return this.getMainAdminInfoWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataMainAdminInfoVo>) => apiResponse.data));
    }

    /**
     * Change main admin
     * @param spaceMainAdminChangeOpRo
     * @param xSpaceId space id
     */
    public replaceWithHttpInfo(spaceMainAdminChangeOpRo: SpaceMainAdminChangeOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.replace(spaceMainAdminChangeOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.replaceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Change main admin
     * @param spaceMainAdminChangeOpRo
     * @param xSpaceId space id
     */
    public replace(spaceMainAdminChangeOpRo: SpaceMainAdminChangeOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.replaceWithHttpInfo(spaceMainAdminChangeOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { SpaceSpaceApiApiRequestFactory, SpaceSpaceApiApiResponseProcessor} from "../apis/SpaceSpaceApiApi";
export class ObservableSpaceSpaceApiApi {
    private requestFactory: SpaceSpaceApiApiRequestFactory;
    private responseProcessor: SpaceSpaceApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceSpaceApiApiRequestFactory,
        responseProcessor?: SpaceSpaceApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceSpaceApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceSpaceApiApiResponseProcessor();
    }

    /**
     * Undo delete space
     * @param spaceId space id
     */
    public cancelWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.cancel(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.cancelWithHttpInfo(rsp)));
            }));
    }

    /**
     * Undo delete space
     * @param spaceId space id
     */
    public cancel(spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.cancelWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get space capacity info
     * @param xSpaceId space id
     */
    public capacityWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceCapacityVO>> {
        const requestContextPromise = this.requestFactory.capacity(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.capacityWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get space capacity info
     * @param xSpaceId space id
     */
    public capacity(xSpaceId: string, _options?: Configuration): Observable<ResponseDataSpaceCapacityVO> {
        return this.capacityWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceCapacityVO>) => apiResponse.data));
    }

    /**
     * Create Space
     * @param spaceOpRo
     */
    public create4WithHttpInfo(spaceOpRo: SpaceOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataCreateSpaceResultVo>> {
        const requestContextPromise = this.requestFactory.create4(spaceOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create4WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Space
     * @param spaceOpRo
     */
    public create4(spaceOpRo: SpaceOpRo, _options?: Configuration): Observable<ResponseDataCreateSpaceResultVo> {
        return this.create4WithHttpInfo(spaceOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataCreateSpaceResultVo>) => apiResponse.data));
    }

    /**
     * Delete space immediately
     */
    public delWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.del(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete space immediately
     */
    public del(_options?: Configuration): Observable<ResponseDataVoid> {
        return this.delWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete space
     * @param spaceDeleteRo
     * @param spaceId space id
     */
    public delete16WithHttpInfo(spaceDeleteRo: SpaceDeleteRo, spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete16(spaceDeleteRo, spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete16WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete space
     * @param spaceDeleteRo
     * @param spaceId space id
     */
    public delete16(spaceDeleteRo: SpaceDeleteRo, spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete16WithHttpInfo(spaceDeleteRo, spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get space feature
     * @param xSpaceId space id
     */
    public featureWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceGlobalFeature>> {
        const requestContextPromise = this.requestFactory.feature(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.featureWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get space feature
     * @param xSpaceId space id
     */
    public feature(xSpaceId: string, _options?: Configuration): Observable<ResponseDataSpaceGlobalFeature> {
        return this.featureWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceGlobalFeature>) => apiResponse.data));
    }

    /**
     * Gets message credit chart data for the space
     * @param spaceId space id
     * @param timeDimension
     */
    public getCreditUsagesWithHttpInfo(spaceId: string, timeDimension?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataCreditUsages>> {
        const requestContextPromise = this.requestFactory.getCreditUsages(spaceId, timeDimension, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCreditUsagesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets message credit chart data for the space
     * @param spaceId space id
     * @param timeDimension
     */
    public getCreditUsages(spaceId: string, timeDimension?: string, _options?: Configuration): Observable<ResponseDataCreditUsages> {
        return this.getCreditUsagesWithHttpInfo(spaceId, timeDimension, _options).pipe(map((apiResponse: HttpInfo<ResponseDataCreditUsages>) => apiResponse.data));
    }

    /**
     * Get user space resource
     * @param xSpaceId space id
     */
    public getSpaceResourceWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataUserSpaceVo>> {
        const requestContextPromise = this.requestFactory.getSpaceResource(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceResourceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get user space resource
     * @param xSpaceId space id
     */
    public getSpaceResource(xSpaceId: string, _options?: Configuration): Observable<ResponseDataUserSpaceVo> {
        return this.getSpaceResourceWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataUserSpaceVo>) => apiResponse.data));
    }

    /**
     * Get space info
     * @param spaceId space id
     */
    public info1WithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceInfoVO>> {
        const requestContextPromise = this.requestFactory.info1(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.info1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get space info
     * @param spaceId space id
     */
    public info1(spaceId: string, _options?: Configuration): Observable<ResponseDataSpaceInfoVO> {
        return this.info1WithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceInfoVO>) => apiResponse.data));
    }

    /**
     * Get space list
     * @param onlyManageable Whether to query only the managed space list. By default, not include
     */
    public list2WithHttpInfo(onlyManageable?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataListSpaceVO>> {
        const requestContextPromise = this.requestFactory.list2(onlyManageable, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get space list
     * @param onlyManageable Whether to query only the managed space list. By default, not include
     */
    public list2(onlyManageable?: boolean, _options?: Configuration): Observable<ResponseDataListSpaceVO> {
        return this.list2WithHttpInfo(onlyManageable, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListSpaceVO>) => apiResponse.data));
    }

    /**
     * Quit space
     * @param spaceId space id
     */
    public quitWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.quit(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.quitWithHttpInfo(rsp)));
            }));
    }

    /**
     * Quit space
     * @param spaceId space id
     */
    public quit(spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.quitWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Scenario: Remove the red dot in the inactive space
     * Remove hot point in space
     * @param spaceId space id
     */
    public removeWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.remove(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.removeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scenario: Remove the red dot in the inactive space
     * Remove hot point in space
     * @param spaceId space id
     */
    public remove(spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.removeWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Gets subscription information for the space
     * @param spaceId space id
     */
    public subscribeWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceSubscribeVo>> {
        const requestContextPromise = this.requestFactory.subscribe(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.subscribeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets subscription information for the space
     * @param spaceId space id
     */
    public subscribe(spaceId: string, _options?: Configuration): Observable<ResponseDataSpaceSubscribeVo> {
        return this.subscribeWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceSubscribeVo>) => apiResponse.data));
    }

    /**
     * switch space
     * @param spaceId space id
     */
    public switchSpaceWithHttpInfo(spaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.switchSpace(spaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.switchSpaceWithHttpInfo(rsp)));
            }));
    }

    /**
     * switch space
     * @param spaceId space id
     */
    public switchSpace(spaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.switchSpaceWithHttpInfo(spaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * at least one item is name and logo
     * Update space
     * @param spaceUpdateOpRo
     * @param xSpaceId space id
     */
    public update3WithHttpInfo(spaceUpdateOpRo: SpaceUpdateOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.update3(spaceUpdateOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.update3WithHttpInfo(rsp)));
            }));
    }

    /**
     * at least one item is name and logo
     * Update space
     * @param spaceUpdateOpRo
     * @param xSpaceId space id
     */
    public update3(spaceUpdateOpRo: SpaceUpdateOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.update3WithHttpInfo(spaceUpdateOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update member setting
     * @param spaceMemberSettingRo
     * @param xSpaceId space id
     */
    public updateMemberSettingWithHttpInfo(spaceMemberSettingRo: SpaceMemberSettingRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateMemberSetting(spaceMemberSettingRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateMemberSettingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update member setting
     * @param spaceMemberSettingRo
     * @param xSpaceId space id
     */
    public updateMemberSetting(spaceMemberSettingRo: SpaceMemberSettingRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateMemberSettingWithHttpInfo(spaceMemberSettingRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update security setting
     * @param spaceSecuritySettingRo
     * @param xSpaceId space id
     */
    public updateSecuritySettingWithHttpInfo(spaceSecuritySettingRo: SpaceSecuritySettingRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateSecuritySetting(spaceSecuritySettingRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateSecuritySettingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update security setting
     * @param spaceSecuritySettingRo
     * @param xSpaceId space id
     */
    public updateSecuritySetting(spaceSecuritySettingRo: SpaceSecuritySettingRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateSecuritySettingWithHttpInfo(spaceSecuritySettingRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Update workbench setting
     * @param spaceWorkbenchSettingRo
     * @param xSpaceId space id
     */
    public updateWorkbenchSettingWithHttpInfo(spaceWorkbenchSettingRo: SpaceWorkbenchSettingRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateWorkbenchSetting(spaceWorkbenchSettingRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateWorkbenchSettingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update workbench setting
     * @param spaceWorkbenchSettingRo
     * @param xSpaceId space id
     */
    public updateWorkbenchSetting(spaceWorkbenchSettingRo: SpaceWorkbenchSettingRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateWorkbenchSettingWithHttpInfo(spaceWorkbenchSettingRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { SpaceSubAdminApiApiRequestFactory, SpaceSubAdminApiApiResponseProcessor} from "../apis/SpaceSubAdminApiApi";
export class ObservableSpaceSubAdminApiApi {
    private requestFactory: SpaceSubAdminApiApiRequestFactory;
    private responseProcessor: SpaceSubAdminApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SpaceSubAdminApiApiRequestFactory,
        responseProcessor?: SpaceSubAdminApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SpaceSubAdminApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SpaceSubAdminApiApiResponseProcessor();
    }

    /**
     * Create space role
     * @param addSpaceRoleRo
     * @param xSpaceId space id
     */
    public addRoleWithHttpInfo(addSpaceRoleRo: AddSpaceRoleRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.addRole(addSpaceRoleRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.addRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create space role
     * @param addSpaceRoleRo
     * @param xSpaceId space id
     */
    public addRole(addSpaceRoleRo: AddSpaceRoleRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.addRoleWithHttpInfo(addSpaceRoleRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * delete admin
     * delete admin
     * @param memberId
     * @param xSpaceId space id
     */
    public deleteRoleWithHttpInfo(memberId: number, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseData>> {
        const requestContextPromise = this.requestFactory.deleteRole(memberId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * delete admin
     * delete admin
     * @param memberId
     * @param xSpaceId space id
     */
    public deleteRole(memberId: number, xSpaceId: string, _options?: Configuration): Observable<ResponseData> {
        return this.deleteRoleWithHttpInfo(memberId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseData>) => apiResponse.data));
    }

    /**
     * Edite space role
     * @param updateSpaceRoleRo
     * @param xSpaceId space id
     */
    public editRoleWithHttpInfo(updateSpaceRoleRo: UpdateSpaceRoleRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseData>> {
        const requestContextPromise = this.requestFactory.editRole(updateSpaceRoleRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.editRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Edite space role
     * @param updateSpaceRoleRo
     * @param xSpaceId space id
     */
    public editRole(updateSpaceRoleRo: UpdateSpaceRoleRo, xSpaceId: string, _options?: Configuration): Observable<ResponseData> {
        return this.editRoleWithHttpInfo(updateSpaceRoleRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseData>) => apiResponse.data));
    }

    /**
     * query admin detail
     * @param memberId
     * @param xSpaceId space id
     */
    public getRoleDetailWithHttpInfo(memberId: number, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSpaceRoleDetailVo>> {
        const requestContextPromise = this.requestFactory.getRoleDetail(memberId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRoleDetailWithHttpInfo(rsp)));
            }));
    }

    /**
     * query admin detail
     * @param memberId
     * @param xSpaceId space id
     */
    public getRoleDetail(memberId: number, xSpaceId: string, _options?: Configuration): Observable<ResponseDataSpaceRoleDetailVo> {
        return this.getRoleDetailWithHttpInfo(memberId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSpaceRoleDetailVo>) => apiResponse.data));
    }

    /**
     * Page query sub admin.Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query admins
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams paging parameters
     */
    public listRoleWithHttpInfo(page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoSpaceRoleVo>> {
        const requestContextPromise = this.requestFactory.listRole(page, xSpaceId, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.listRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Page query sub admin.Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query admins
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams paging parameters
     */
    public listRole(page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoSpaceRoleVo> {
        return this.listRoleWithHttpInfo(page, xSpaceId, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoSpaceRoleVo>) => apiResponse.data));
    }

}

import { StoreAPIApiRequestFactory, StoreAPIApiResponseProcessor} from "../apis/StoreAPIApi";
export class ObservableStoreAPIApi {
    private requestFactory: StoreAPIApiRequestFactory;
    private responseProcessor: StoreAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: StoreAPIApiRequestFactory,
        responseProcessor?: StoreAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new StoreAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new StoreAPIApiResponseProcessor();
    }

    /**
     * Self-operated product price list
     * Get Price List for A Product
     * @param product product name
     */
    public getPricesWithHttpInfo(product: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListProductPriceVo>> {
        const requestContextPromise = this.requestFactory.getPrices(product, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getPricesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Self-operated product price list
     * Get Price List for A Product
     * @param product product name
     */
    public getPrices(product: string, _options?: Configuration): Observable<ResponseDataListProductPriceVo> {
        return this.getPricesWithHttpInfo(product, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListProductPriceVo>) => apiResponse.data));
    }

}

import { StripeWebhookControllerApiRequestFactory, StripeWebhookControllerApiResponseProcessor} from "../apis/StripeWebhookControllerApi";
export class ObservableStripeWebhookControllerApi {
    private requestFactory: StripeWebhookControllerApiRequestFactory;
    private responseProcessor: StripeWebhookControllerApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: StripeWebhookControllerApiRequestFactory,
        responseProcessor?: StripeWebhookControllerApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new StripeWebhookControllerApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new StripeWebhookControllerApiResponseProcessor();
    }

    /**
     */
    public retrieveStripeEventWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.retrieveStripeEvent(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.retrieveStripeEventWithHttpInfo(rsp)));
            }));
    }

    /**
     */
    public retrieveStripeEvent(_options?: Configuration): Observable<string> {
        return this.retrieveStripeEventWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

}

import { TemplateCenterTemplateAPIApiRequestFactory, TemplateCenterTemplateAPIApiResponseProcessor} from "../apis/TemplateCenterTemplateAPIApi";
export class ObservableTemplateCenterTemplateAPIApi {
    private requestFactory: TemplateCenterTemplateAPIApiRequestFactory;
    private responseProcessor: TemplateCenterTemplateAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TemplateCenterTemplateAPIApiRequestFactory,
        responseProcessor?: TemplateCenterTemplateAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TemplateCenterTemplateAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TemplateCenterTemplateAPIApiResponseProcessor();
    }

    /**
     * Created nodes (including child descendant nodes) have administrative rights and are not associated with data tables other than nodes.
     * Create Template
     * @param createTemplateRo
     */
    public create3WithHttpInfo(createTemplateRo: CreateTemplateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.create3(createTemplateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Created nodes (including child descendant nodes) have administrative rights and are not associated with data tables other than nodes.
     * Create Template
     * @param createTemplateRo
     */
    public create3(createTemplateRo: CreateTemplateRo, _options?: Configuration): Observable<ResponseDataString> {
        return this.create3WithHttpInfo(createTemplateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Deletion objects: main administrator, sub-admins with template permissions, creator of the template
     * Delete Template
     * @param templateId Template ID
     */
    public delete14WithHttpInfo(templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete14(templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete14WithHttpInfo(rsp)));
            }));
    }

    /**
     * Deletion objects: main administrator, sub-admins with template permissions, creator of the template
     * Delete Template
     * @param templateId Template ID
     */
    public delete14(templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete14WithHttpInfo(templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get Template Directory Info
     * @param templateId Template Id
     * @param categoryCode Official Template Category Code
     * @param isPrivate Whether it is a private template in the space station
     */
    public directoryWithHttpInfo(templateId: string, categoryCode?: string, isPrivate?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataTemplateDirectoryVo>> {
        const requestContextPromise = this.requestFactory.directory(templateId, categoryCode, isPrivate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.directoryWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Template Directory Info
     * @param templateId Template Id
     * @param categoryCode Official Template Category Code
     * @param isPrivate Whether it is a private template in the space station
     */
    public directory(templateId: string, categoryCode?: string, isPrivate?: boolean, _options?: Configuration): Observable<ResponseDataTemplateDirectoryVo> {
        return this.directoryWithHttpInfo(templateId, categoryCode, isPrivate, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTemplateDirectoryVo>) => apiResponse.data));
    }

    /**
     * Get The Template Category Content
     * @param categoryCode Template Category Code
     */
    public getCategoryContentWithHttpInfo(categoryCode: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTemplateCategoryContentVo>> {
        const requestContextPromise = this.requestFactory.getCategoryContent(categoryCode, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCategoryContentWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get The Template Category Content
     * @param categoryCode Template Category Code
     */
    public getCategoryContent(categoryCode: string, _options?: Configuration): Observable<ResponseDataTemplateCategoryContentVo> {
        return this.getCategoryContentWithHttpInfo(categoryCode, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTemplateCategoryContentVo>) => apiResponse.data));
    }

    /**
     * Get Template Category List
     */
    public getCategoryListWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListTemplateCategoryMenuVo>> {
        const requestContextPromise = this.requestFactory.getCategoryList(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCategoryListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Template Category List
     */
    public getCategoryList(_options?: Configuration): Observable<ResponseDataListTemplateCategoryMenuVo> {
        return this.getCategoryListWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListTemplateCategoryMenuVo>) => apiResponse.data));
    }

    /**
     * Get Space Templates
     * @param spaceId
     * @param xSpaceId Space Id
     */
    public getSpaceTemplatesWithHttpInfo(spaceId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListTemplateVo>> {
        const requestContextPromise = this.requestFactory.getSpaceTemplates(spaceId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSpaceTemplatesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Space Templates
     * @param spaceId
     * @param xSpaceId Space Id
     */
    public getSpaceTemplates(spaceId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataListTemplateVo> {
        return this.getSpaceTemplatesWithHttpInfo(spaceId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListTemplateVo>) => apiResponse.data));
    }

    /**
     * Template Global Search
     * @param keyword Search Keyword
     * @param className Highlight Style Class Name
     */
    public globalSearchWithHttpInfo(keyword: string, className?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTemplateSearchResultVo>> {
        const requestContextPromise = this.requestFactory.globalSearch(keyword, className, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.globalSearchWithHttpInfo(rsp)));
            }));
    }

    /**
     * Template Global Search
     * @param keyword Search Keyword
     * @param className Highlight Style Class Name
     */
    public globalSearch(keyword: string, className?: string, _options?: Configuration): Observable<ResponseDataTemplateSearchResultVo> {
        return this.globalSearchWithHttpInfo(keyword, className, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTemplateSearchResultVo>) => apiResponse.data));
    }

    /**
     * Quote Template
     * @param quoteTemplateRo
     * @param xSocketId user socket id
     */
    public quoteWithHttpInfo(quoteTemplateRo: QuoteTemplateRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.quote(quoteTemplateRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.quoteWithHttpInfo(rsp)));
            }));
    }

    /**
     * Quote Template
     * @param quoteTemplateRo
     * @param xSocketId user socket id
     */
    public quote(quoteTemplateRo: QuoteTemplateRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.quoteWithHttpInfo(quoteTemplateRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * Get Template Recommend Content
     */
    public recommendWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataRecommendVo>> {
        const requestContextPromise = this.requestFactory.recommend(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.recommendWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Template Recommend Content
     */
    public recommend(_options?: Configuration): Observable<ResponseDataRecommendVo> {
        return this.recommendWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataRecommendVo>) => apiResponse.data));
    }

    /**
     * Called before creating a template, the same name will overwrite the old template. you need to confirm the operation again
     * Check if the template name already exists
     * @param name Template Name
     * @param xSpaceId Space Id
     */
    public validateWithHttpInfo(name: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.validate(name, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.validateWithHttpInfo(rsp)));
            }));
    }

    /**
     * Called before creating a template, the same name will overwrite the old template. you need to confirm the operation again
     * Check if the template name already exists
     * @param name Template Name
     * @param xSpaceId Space Id
     */
    public validate(name: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.validateWithHttpInfo(name, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

}

import { TemplateCenterTemplateAlbumAPIApiRequestFactory, TemplateCenterTemplateAlbumAPIApiResponseProcessor} from "../apis/TemplateCenterTemplateAlbumAPIApi";
export class ObservableTemplateCenterTemplateAlbumAPIApi {
    private requestFactory: TemplateCenterTemplateAlbumAPIApiRequestFactory;
    private responseProcessor: TemplateCenterTemplateAlbumAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TemplateCenterTemplateAlbumAPIApiRequestFactory,
        responseProcessor?: TemplateCenterTemplateAlbumAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TemplateCenterTemplateAlbumAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TemplateCenterTemplateAlbumAPIApiResponseProcessor();
    }

    /**
     * Get The Template Album Content
     * @param albumId Template Album ID
     */
    public getAlbumContentWithHttpInfo(albumId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataAlbumContentVo>> {
        const requestContextPromise = this.requestFactory.getAlbumContent(albumId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAlbumContentWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get The Template Album Content
     * @param albumId Template Album ID
     */
    public getAlbumContent(albumId: string, _options?: Configuration): Observable<ResponseDataAlbumContentVo> {
        return this.getAlbumContentWithHttpInfo(albumId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataAlbumContentVo>) => apiResponse.data));
    }

    /**
     * Get Recommended Template Albums
     * @param excludeAlbumId Exclude Album
     * @param maxCount Max Count of Load.The number of response result may be smaller than it
     */
    public getRecommendedAlbumsWithHttpInfo(excludeAlbumId?: string, maxCount?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListAlbumVo>> {
        const requestContextPromise = this.requestFactory.getRecommendedAlbums(excludeAlbumId, maxCount, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRecommendedAlbumsWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Recommended Template Albums
     * @param excludeAlbumId Exclude Album
     * @param maxCount Max Count of Load.The number of response result may be smaller than it
     */
    public getRecommendedAlbums(excludeAlbumId?: string, maxCount?: number, _options?: Configuration): Observable<ResponseDataListAlbumVo> {
        return this.getRecommendedAlbumsWithHttpInfo(excludeAlbumId, maxCount, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListAlbumVo>) => apiResponse.data));
    }

}

import { TencentQQModuleTencentQQRelatedServiceInterfaceApiRequestFactory, TencentQQModuleTencentQQRelatedServiceInterfaceApiResponseProcessor} from "../apis/TencentQQModuleTencentQQRelatedServiceInterfaceApi";
export class ObservableTencentQQModuleTencentQQRelatedServiceInterfaceApi {
    private requestFactory: TencentQQModuleTencentQQRelatedServiceInterfaceApiRequestFactory;
    private responseProcessor: TencentQQModuleTencentQQRelatedServiceInterfaceApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TencentQQModuleTencentQQRelatedServiceInterfaceApiRequestFactory,
        responseProcessor?: TencentQQModuleTencentQQRelatedServiceInterfaceApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TencentQQModuleTencentQQRelatedServiceInterfaceApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TencentQQModuleTencentQQRelatedServiceInterfaceApiResponseProcessor();
    }

    /**
     * code、accessToken, At least one is passed in
     * Website application callback
     * @param type Type (0: Scan code for login; 1: Account binding;)
     * @param code Code (build the request yourself and call back the parameter)
     * @param accessToken Authorization token (use the JS SDK to call back this parameter)
     * @param expiresIn access token\&#39;s TERM OF VALIDITY
     */
    public callback2WithHttpInfo(type?: number, code?: string, accessToken?: string, expiresIn?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.callback2(type, code, accessToken, expiresIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callback2WithHttpInfo(rsp)));
            }));
    }

    /**
     * code、accessToken, At least one is passed in
     * Website application callback
     * @param type Type (0: Scan code for login; 1: Account binding;)
     * @param code Code (build the request yourself and call back the parameter)
     * @param accessToken Authorization token (use the JS SDK to call back this parameter)
     * @param expiresIn access token\&#39;s TERM OF VALIDITY
     */
    public callback2(type?: number, code?: string, accessToken?: string, expiresIn?: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.callback2WithHttpInfo(type, code, accessToken, expiresIn, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

}

import { ThirdPartyPlatformIntegrationInterfaceDingTalkApiRequestFactory, ThirdPartyPlatformIntegrationInterfaceDingTalkApiResponseProcessor} from "../apis/ThirdPartyPlatformIntegrationInterfaceDingTalkApi";
export class ObservableThirdPartyPlatformIntegrationInterfaceDingTalkApi {
    private requestFactory: ThirdPartyPlatformIntegrationInterfaceDingTalkApiRequestFactory;
    private responseProcessor: ThirdPartyPlatformIntegrationInterfaceDingTalkApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ThirdPartyPlatformIntegrationInterfaceDingTalkApiRequestFactory,
        responseProcessor?: ThirdPartyPlatformIntegrationInterfaceDingTalkApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ThirdPartyPlatformIntegrationInterfaceDingTalkApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ThirdPartyPlatformIntegrationInterfaceDingTalkApiResponseProcessor();
    }

    /**
     * DingTalk application bind space
     * DingTalk The application enterprise binds the space
     * @param dingTalkAgentBindSpaceDTO
     * @param agentId
     */
    public bindSpace1WithHttpInfo(dingTalkAgentBindSpaceDTO: DingTalkAgentBindSpaceDTO, agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.bindSpace1(dingTalkAgentBindSpaceDTO, agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindSpace1WithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk application bind space
     * DingTalk The application enterprise binds the space
     * @param dingTalkAgentBindSpaceDTO
     * @param agentId
     */
    public bindSpace1(dingTalkAgentBindSpaceDTO: DingTalkAgentBindSpaceDTO, agentId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.bindSpace1WithHttpInfo(dingTalkAgentBindSpaceDTO, agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get the space station ID of the application binding, and jump to the login page when success=false
     * Get the space station ID bound by the application
     * @param agentId
     */
    public bindSpaceInfo1WithHttpInfo(agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkBindSpaceVo>> {
        const requestContextPromise = this.requestFactory.bindSpaceInfo1(agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindSpaceInfo1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the space station ID of the application binding, and jump to the login page when success=false
     * Get the space station ID bound by the application
     * @param agentId
     */
    public bindSpaceInfo1(agentId: string, _options?: Configuration): Observable<ResponseDataDingTalkBindSpaceVo> {
        return this.bindSpaceInfo1WithHttpInfo(agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkBindSpaceVo>) => apiResponse.data));
    }

    /**
     * Replace the master administrator
     * Tenant space replacement master administrator
     * @param dingTalkTenantMainAdminChangeRo
     * @param suiteId kit ID
     */
    public changeAdmin1WithHttpInfo(dingTalkTenantMainAdminChangeRo: DingTalkTenantMainAdminChangeRo, suiteId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.changeAdmin1(dingTalkTenantMainAdminChangeRo, suiteId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.changeAdmin1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Replace the master administrator
     * Tenant space replacement master administrator
     * @param dingTalkTenantMainAdminChangeRo
     * @param suiteId kit ID
     */
    public changeAdmin1(dingTalkTenantMainAdminChangeRo: DingTalkTenantMainAdminChangeRo, suiteId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.changeAdmin1WithHttpInfo(dingTalkTenantMainAdminChangeRo, suiteId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * DingTalk Callback interface--Template Creation
     * DingTalk Callback interface--Template Creation
     * @param dingTalkDaTemplateCreateRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateCreateWithHttpInfo(dingTalkDaTemplateCreateRo: DingTalkDaTemplateCreateRo, dingTalkDaAppId: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.dingTalkDaTemplateCreate(dingTalkDaTemplateCreateRo, dingTalkDaAppId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.dingTalkDaTemplateCreateWithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk Callback interface--Template Creation
     * DingTalk Callback interface--Template Creation
     * @param dingTalkDaTemplateCreateRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateCreate(dingTalkDaTemplateCreateRo: DingTalkDaTemplateCreateRo, dingTalkDaAppId: string, _options?: Configuration): Observable<void> {
        return this.dingTalkDaTemplateCreateWithHttpInfo(dingTalkDaTemplateCreateRo, dingTalkDaAppId, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * DingTalk Callback interface--Template application deletion
     * DingTalk Callback interface--Template application deletion
     * @param dingTalkDaTemplateDeleteRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateDeleteWithHttpInfo(dingTalkDaTemplateDeleteRo: DingTalkDaTemplateDeleteRo, dingTalkDaAppId: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.dingTalkDaTemplateDelete(dingTalkDaTemplateDeleteRo, dingTalkDaAppId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.dingTalkDaTemplateDeleteWithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk Callback interface--Template application deletion
     * DingTalk Callback interface--Template application deletion
     * @param dingTalkDaTemplateDeleteRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateDelete(dingTalkDaTemplateDeleteRo: DingTalkDaTemplateDeleteRo, dingTalkDaAppId: string, _options?: Configuration): Observable<void> {
        return this.dingTalkDaTemplateDeleteWithHttpInfo(dingTalkDaTemplateDeleteRo, dingTalkDaAppId, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * DingTalk Callback interface--Template application modification
     * DingTalk Callback interface--Template application modification
     * @param dingTalkDaTemplateUpdateRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateUpdateWithHttpInfo(dingTalkDaTemplateUpdateRo: DingTalkDaTemplateUpdateRo, dingTalkDaAppId: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.dingTalkDaTemplateUpdate(dingTalkDaTemplateUpdateRo, dingTalkDaAppId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.dingTalkDaTemplateUpdateWithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk Callback interface--Template application modification
     * DingTalk Callback interface--Template application modification
     * @param dingTalkDaTemplateUpdateRo
     * @param dingTalkDaAppId
     */
    public dingTalkDaTemplateUpdate(dingTalkDaTemplateUpdateRo: DingTalkDaTemplateUpdateRo, dingTalkDaAppId: string, _options?: Configuration): Observable<void> {
        return this.dingTalkDaTemplateUpdateWithHttpInfo(dingTalkDaTemplateUpdateRo, dingTalkDaAppId, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * Use DingTalk login user identity to authorize login. If no user is bound, return parameters to guide registration
     * DingTalk Application user login
     * @param dingTalkUserLoginRo
     * @param agentId
     */
    public dingTalkUserLoginWithHttpInfo(dingTalkUserLoginRo: DingTalkUserLoginRo, agentId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkUserLoginVo>> {
        const requestContextPromise = this.requestFactory.dingTalkUserLogin(dingTalkUserLoginRo, agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.dingTalkUserLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Use DingTalk login user identity to authorize login. If no user is bound, return parameters to guide registration
     * DingTalk Application user login
     * @param dingTalkUserLoginRo
     * @param agentId
     */
    public dingTalkUserLogin(dingTalkUserLoginRo: DingTalkUserLoginRo, agentId: string, _options?: Configuration): Observable<ResponseDataDingTalkUserLoginVo> {
        return this.dingTalkUserLoginWithHttpInfo(dingTalkUserLoginRo, agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkUserLoginVo>) => apiResponse.data));
    }

    /**
     * Get the dd.config parameter
     * Get the dd.config parameter
     * @param dingTalkDdConfigRo
     */
    public getDdConfigParamWithHttpInfo(dingTalkDdConfigRo: DingTalkDdConfigRo, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkDdConfigVo>> {
        const requestContextPromise = this.requestFactory.getDdConfigParam(dingTalkDdConfigRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getDdConfigParamWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the dd.config parameter
     * Get the dd.config parameter
     * @param dingTalkDdConfigRo
     */
    public getDdConfigParam(dingTalkDdConfigRo: DingTalkDdConfigRo, _options?: Configuration): Observable<ResponseDataDingTalkDdConfigVo> {
        return this.getDdConfigParamWithHttpInfo(dingTalkDdConfigRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkDdConfigVo>) => apiResponse.data));
    }

    /**
     * Get the SKU page address of domestic products
     * Get the SKU page address of domestic products
     * @param dingTalkInternalSkuPageRo
     */
    public getSkuPageWithHttpInfo(dingTalkInternalSkuPageRo: DingTalkInternalSkuPageRo, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.getSkuPage(dingTalkInternalSkuPageRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSkuPageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the SKU page address of domestic products
     * Get the SKU page address of domestic products
     * @param dingTalkInternalSkuPageRo
     */
    public getSkuPage(dingTalkInternalSkuPageRo: DingTalkInternalSkuPageRo, _options?: Configuration): Observable<ResponseDataString> {
        return this.getSkuPageWithHttpInfo(dingTalkInternalSkuPageRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Get the space information bound by the tenant
     * Get tenant binding information
     * @param suiteId kit ID
     * @param corpId current organization ID
     */
    public getTenantInfo2WithHttpInfo(suiteId: string, corpId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTenantDetailVO>> {
        const requestContextPromise = this.requestFactory.getTenantInfo2(suiteId, corpId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTenantInfo2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the space information bound by the tenant
     * Get tenant binding information
     * @param suiteId kit ID
     * @param corpId current organization ID
     */
    public getTenantInfo2(suiteId: string, corpId: string, _options?: Configuration): Observable<ResponseDataTenantDetailVO> {
        return this.getTenantInfo2WithHttpInfo(suiteId, corpId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTenantDetailVO>) => apiResponse.data));
    }

    /**
     * DingTalk workbench entry, administrator login
     * ISV third-party DingTalk application background administrator login
     * @param dingTalkIsvAminUserLoginRo
     * @param suiteId kit ID
     */
    public isvAminUserLoginWithHttpInfo(dingTalkIsvAminUserLoginRo: DingTalkIsvAminUserLoginRo, suiteId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkIsvAdminUserLoginVo>> {
        const requestContextPromise = this.requestFactory.isvAminUserLogin(dingTalkIsvAminUserLoginRo, suiteId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.isvAminUserLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * DingTalk workbench entry, administrator login
     * ISV third-party DingTalk application background administrator login
     * @param dingTalkIsvAminUserLoginRo
     * @param suiteId kit ID
     */
    public isvAminUserLogin(dingTalkIsvAminUserLoginRo: DingTalkIsvAminUserLoginRo, suiteId: string, _options?: Configuration): Observable<ResponseDataDingTalkIsvAdminUserLoginVo> {
        return this.isvAminUserLoginWithHttpInfo(dingTalkIsvAminUserLoginRo, suiteId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkIsvAdminUserLoginVo>) => apiResponse.data));
    }

    /**
     * Get the space station ID of the application binding, and jump to the login page when success=false
     * ISV Third party application obtains the space ID bound by the application
     * @param suiteId kit ID
     * @param corpId Current Organization ID
     */
    public isvBindSpaceInfoWithHttpInfo(suiteId: string, corpId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkBindSpaceVo>> {
        const requestContextPromise = this.requestFactory.isvBindSpaceInfo(suiteId, corpId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.isvBindSpaceInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the space station ID of the application binding, and jump to the login page when success=false
     * ISV Third party application obtains the space ID bound by the application
     * @param suiteId kit ID
     * @param corpId Current Organization ID
     */
    public isvBindSpaceInfo(suiteId: string, corpId: string, _options?: Configuration): Observable<ResponseDataDingTalkBindSpaceVo> {
        return this.isvBindSpaceInfoWithHttpInfo(suiteId, corpId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkBindSpaceVo>) => apiResponse.data));
    }

    /**
     * Use the third-party DingTalk login user identity to authorize login. If no user is bound, return the parameter to guide the registration
     * ISV Third party Ding Talk application user login
     * @param dingTalkIsvUserLoginRo
     * @param suiteId kit ID
     */
    public isvUserLoginWithHttpInfo(dingTalkIsvUserLoginRo: DingTalkIsvUserLoginRo, suiteId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataDingTalkIsvUserLoginVo>> {
        const requestContextPromise = this.requestFactory.isvUserLogin(dingTalkIsvUserLoginRo, suiteId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.isvUserLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Use the third-party DingTalk login user identity to authorize login. If no user is bound, return the parameter to guide the registration
     * ISV Third party Ding Talk application user login
     * @param dingTalkIsvUserLoginRo
     * @param suiteId kit ID
     */
    public isvUserLogin(dingTalkIsvUserLoginRo: DingTalkIsvUserLoginRo, suiteId: string, _options?: Configuration): Observable<ResponseDataDingTalkIsvUserLoginVo> {
        return this.isvUserLoginWithHttpInfo(dingTalkIsvUserLoginRo, suiteId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataDingTalkIsvUserLoginVo>) => apiResponse.data));
    }

    /**
     * Refresh the address book of DingTalk application
     * Refresh the address book of DingTalk application
     * @param xSpaceId space id
     */
    public refreshContact1WithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.refreshContact1(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.refreshContact1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Refresh the address book of DingTalk application
     * Refresh the address book of DingTalk application
     * @param xSpaceId space id
     */
    public refreshContact1(xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.refreshContact1WithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiRequestFactory, ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiResponseProcessor} from "../apis/ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApi";
export class ObservableThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApi {
    private requestFactory: ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiRequestFactory;
    private responseProcessor: ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiRequestFactory,
        responseProcessor?: ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ThirdPartyPlatformIntegrationInterfaceHuaweiOneAccessApiResponseProcessor();
    }

    /**
     * Synchronize a group or member to the current station
     * Sync group or member to Honma station
     * @param oneAccessCopyInfoRo
     */
    public copyTeamAndMembersWithHttpInfo(oneAccessCopyInfoRo: OneAccessCopyInfoRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.copyTeamAndMembers(oneAccessCopyInfoRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.copyTeamAndMembersWithHttpInfo(rsp)));
            }));
    }

    /**
     * Synchronize a group or member to the current station
     * Sync group or member to Honma station
     * @param oneAccessCopyInfoRo
     */
    public copyTeamAndMembers(oneAccessCopyInfoRo: OneAccessCopyInfoRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.copyTeamAndMembersWithHttpInfo(oneAccessCopyInfoRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * login
     * Unified login interface
     */
    public login2WithHttpInfo(_options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.login2(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.login2WithHttpInfo(rsp)));
            }));
    }

    /**
     * login
     * Unified login interface
     */
    public login2(_options?: Configuration): Observable<void> {
        return this.login2WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * Accept the authorization interface of OneAccess and call back the login
     * Login callback interface
     * @param code
     * @param state
     */
    public oauth2CallbackWithHttpInfo(code: string, state: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.oauth2Callback(code, state, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.oauth2CallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * Accept the authorization interface of OneAccess and call back the login
     * Login callback interface
     * @param code
     * @param state
     */
    public oauth2Callback(code: string, state: string, _options?: Configuration): Observable<void> {
        return this.oauth2CallbackWithHttpInfo(code, state, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * Organizations are created by oneAccess
     * organization creation
     */
    public orgCreateWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.orgCreate(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.orgCreateWithHttpInfo(rsp)));
            }));
    }

    /**
     * Organizations are created by oneAccess
     * organization creation
     */
    public orgCreate(_options?: Configuration): Observable<string> {
        return this.orgCreateWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Active deletion of an organization by OneAccess
     * Organization deletion
     */
    public orgDeleteWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.orgDelete(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.orgDeleteWithHttpInfo(rsp)));
            }));
    }

    /**
     * Active deletion of an organization by OneAccess
     * Organization deletion
     */
    public orgDelete(_options?: Configuration): Observable<string> {
        return this.orgDeleteWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Organizations are updated by OneAccess
     * Organizational update
     */
    public orgUpdateWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.orgUpdate(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.orgUpdateWithHttpInfo(rsp)));
            }));
    }

    /**
     * Organizations are updated by OneAccess
     * Organizational update
     */
    public orgUpdate(_options?: Configuration): Observable<string> {
        return this.orgUpdateWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * query org by params
     * query org
     */
    public queryOrgByIdServiceWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.queryOrgByIdService(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.queryOrgByIdServiceWithHttpInfo(rsp)));
            }));
    }

    /**
     * query org by params
     * query org
     */
    public queryOrgByIdService(_options?: Configuration): Observable<string> {
        return this.queryOrgByIdServiceWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * query user by params
     * query user
     */
    public queryUserByIdServiceWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.queryUserByIdService(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.queryUserByIdServiceWithHttpInfo(rsp)));
            }));
    }

    /**
     * query user by params
     * query user
     */
    public queryUserByIdService(_options?: Configuration): Observable<string> {
        return this.queryUserByIdServiceWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * The account is actively created by the oneAccess platform
     * Account creation
     */
    public userCreateWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.userCreate(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userCreateWithHttpInfo(rsp)));
            }));
    }

    /**
     * The account is actively created by the oneAccess platform
     * Account creation
     */
    public userCreate(_options?: Configuration): Observable<string> {
        return this.userCreateWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Delete the account by the oneAccess platform
     * user delete
     */
    public userDeleteWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.userDelete(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userDeleteWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete the account by the oneAccess platform
     * user delete
     */
    public userDelete(_options?: Configuration): Observable<string> {
        return this.userDeleteWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Log in to the openaccess interface, redirect iam single sign-on
     * login
     */
    public userLogin1WithHttpInfo(_options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.userLogin1(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userLogin1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Log in to the openaccess interface, redirect iam single sign-on
     * login
     */
    public userLogin1(_options?: Configuration): Observable<void> {
        return this.userLogin1WithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * Get all information about objects such as system account, institution role, etc.
     * Get schema information
     */
    public userSchemaWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.userSchema(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userSchemaWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get all information about objects such as system account, institution role, etc.
     * Get schema information
     */
    public userSchema(_options?: Configuration): Observable<string> {
        return this.userSchemaWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * The user information is actively updated by the OneAccess platform
     * User update
     */
    public userUpdateWithHttpInfo(_options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.userUpdate(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userUpdateWithHttpInfo(rsp)));
            }));
    }

    /**
     * The user information is actively updated by the OneAccess platform
     * User update
     */
    public userUpdate(_options?: Configuration): Observable<string> {
        return this.userUpdateWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Government WeCom Login
     * Government Affairs WeCom Login Interface
     * @param code
     */
    public wecomLoginWithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.wecomLogin(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.wecomLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Government WeCom Login
     * Government Affairs WeCom Login Interface
     * @param code
     */
    public wecomLogin(code: string, _options?: Configuration): Observable<void> {
        return this.wecomLoginWithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

}

import { ThirdPartyPlatformIntegrationInterfaceWeComApiRequestFactory, ThirdPartyPlatformIntegrationInterfaceWeComApiResponseProcessor} from "../apis/ThirdPartyPlatformIntegrationInterfaceWeComApi";
export class ObservableThirdPartyPlatformIntegrationInterfaceWeComApi {
    private requestFactory: ThirdPartyPlatformIntegrationInterfaceWeComApiRequestFactory;
    private responseProcessor: ThirdPartyPlatformIntegrationInterfaceWeComApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ThirdPartyPlatformIntegrationInterfaceWeComApiRequestFactory,
        responseProcessor?: ThirdPartyPlatformIntegrationInterfaceWeComApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ThirdPartyPlatformIntegrationInterfaceWeComApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ThirdPartyPlatformIntegrationInterfaceWeComApiResponseProcessor();
    }

    /**
     * Get the space ID bound to the self built application of WeCom, and jump to the login page when success=false
     * Obtain the space ID bound by the self built application of WeCom
     * @param corpId
     * @param agentId
     */
    public bindSpaceInfoWithHttpInfo(corpId: string, agentId: number, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComBindSpaceVo>> {
        const requestContextPromise = this.requestFactory.bindSpaceInfo(corpId, agentId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindSpaceInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the space ID bound to the self built application of WeCom, and jump to the login page when success=false
     * Obtain the space ID bound by the self built application of WeCom
     * @param corpId
     * @param agentId
     */
    public bindSpaceInfo(corpId: string, agentId: number, _options?: Configuration): Observable<ResponseDataWeComBindSpaceVo> {
        return this.bindSpaceInfoWithHttpInfo(corpId, agentId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComBindSpaceVo>) => apiResponse.data));
    }

    /**
     * Get the bound WeCom application configuration of the space station
     * Get the bound WeCom application configuration of the space station
     * @param xSpaceId space ID
     */
    public getTenantBindWeComConfigWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComBindConfigVo>> {
        const requestContextPromise = this.requestFactory.getTenantBindWeComConfig(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTenantBindWeComConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the bound WeCom application configuration of the space station
     * Get the bound WeCom application configuration of the space station
     * @param xSpaceId space ID
     */
    public getTenantBindWeComConfig(xSpaceId: string, _options?: Configuration): Observable<ResponseDataWeComBindConfigVo> {
        return this.getTenantBindWeComConfigWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComBindConfigVo>) => apiResponse.data));
    }

    /**
     * Used to generate We Com scanning code to log in and verify whether the domain name can be accessed
     * WeCom Verification domain name conversion IP
     * @param hotsTransformIpRo
     */
    public hotsTransformIpWithHttpInfo(hotsTransformIpRo: HotsTransformIpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataBoolean>> {
        const requestContextPromise = this.requestFactory.hotsTransformIp(hotsTransformIpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.hotsTransformIpWithHttpInfo(rsp)));
            }));
    }

    /**
     * Used to generate We Com scanning code to log in and verify whether the domain name can be accessed
     * WeCom Verification domain name conversion IP
     * @param hotsTransformIpRo
     */
    public hotsTransformIp(hotsTransformIpRo: HotsTransformIpRo, _options?: Configuration): Observable<ResponseDataBoolean> {
        return this.hotsTransformIpWithHttpInfo(hotsTransformIpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataBoolean>) => apiResponse.data));
    }

    /**
     * Get integrated tenant environment configuration
     * Get integrated tenant environment configuration
     * @param xRealHost Real request address
     */
    public socialTenantEnvWithHttpInfo(xRealHost: string, _options?: Configuration): Observable<HttpInfo<ResponseDataSocialTenantEnvVo>> {
        const requestContextPromise = this.requestFactory.socialTenantEnv(xRealHost, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.socialTenantEnvWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get integrated tenant environment configuration
     * Get integrated tenant environment configuration
     * @param xRealHost Real request address
     */
    public socialTenantEnv(xRealHost: string, _options?: Configuration): Observable<ResponseDataSocialTenantEnvVo> {
        return this.socialTenantEnvWithHttpInfo(xRealHost, _options).pipe(map((apiResponse: HttpInfo<ResponseDataSocialTenantEnvVo>) => apiResponse.data));
    }

    /**
     * WeCom Application binding space
     * WeCom Application binding space
     * @param weComAgentBindSpaceRo
     * @param configSha
     */
    public weComBindConfigWithHttpInfo(weComAgentBindSpaceRo: WeComAgentBindSpaceRo, configSha: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.weComBindConfig(weComAgentBindSpaceRo, configSha, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.weComBindConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * WeCom Application binding space
     * WeCom Application binding space
     * @param weComAgentBindSpaceRo
     * @param configSha
     */
    public weComBindConfig(weComAgentBindSpaceRo: WeComAgentBindSpaceRo, configSha: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.weComBindConfigWithHttpInfo(weComAgentBindSpaceRo, configSha, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Before binding We Com, verify the third-party application configuration in advance. If the code scanning verification is not successful, the configuration file is not effective
     * WeCom Verification - Authorization Application Configuration
     * @param weComCheckConfigRo
     * @param xSpaceId space id
     */
    public weComCheckConfigWithHttpInfo(weComCheckConfigRo: WeComCheckConfigRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComCheckConfigVo>> {
        const requestContextPromise = this.requestFactory.weComCheckConfig(weComCheckConfigRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.weComCheckConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * Before binding We Com, verify the third-party application configuration in advance. If the code scanning verification is not successful, the configuration file is not effective
     * WeCom Verification - Authorization Application Configuration
     * @param weComCheckConfigRo
     * @param xSpaceId space id
     */
    public weComCheckConfig(weComCheckConfigRo: WeComCheckConfigRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataWeComCheckConfigVo> {
        return this.weComCheckConfigWithHttpInfo(weComCheckConfigRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComCheckConfigVo>) => apiResponse.data));
    }

    /**
     * WeCom Apply to refresh the address book manually
     * WeCom App Refresh Address Book
     * @param xSpaceId space ID
     */
    public weComRefreshContactWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.weComRefreshContact(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.weComRefreshContactWithHttpInfo(rsp)));
            }));
    }

    /**
     * WeCom Apply to refresh the address book manually
     * WeCom App Refresh Address Book
     * @param xSpaceId space ID
     */
    public weComRefreshContact(xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.weComRefreshContactWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Use WeCom login user identity to authorize login, and return parameters to guide registration when no user is bound
     * WeCom Application user login
     * @param weComUserLoginRo
     */
    public weComUserLoginWithHttpInfo(weComUserLoginRo: WeComUserLoginRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComUserLoginVo>> {
        const requestContextPromise = this.requestFactory.weComUserLogin(weComUserLoginRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.weComUserLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Use WeCom login user identity to authorize login, and return parameters to guide registration when no user is bound
     * WeCom Application user login
     * @param weComUserLoginRo
     */
    public weComUserLogin(weComUserLoginRo: WeComUserLoginRo, _options?: Configuration): Observable<ResponseDataWeComUserLoginVo> {
        return this.weComUserLoginWithHttpInfo(weComUserLoginRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComUserLoginVo>) => apiResponse.data));
    }

}

import { ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiRequestFactory, ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiResponseProcessor} from "../apis/ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApi";
export class ObservableThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApi {
    private requestFactory: ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiRequestFactory;
    private responseProcessor: ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiRequestFactory,
        responseProcessor?: ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ThirdPartyPlatformIntegrationInterfaceWeComThirdPartyServiceProviderApiResponseProcessor();
    }

    /**
     * @param msgSignature
     * @param timestamp
     * @param nonce
     * @param echostr
     */
    public getCallbackWithHttpInfo(msgSignature: string, timestamp: string, nonce: string, echostr: string, _options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.getCallback(msgSignature, timestamp, nonce, echostr, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param msgSignature
     * @param timestamp
     * @param nonce
     * @param echostr
     */
    public getCallback(msgSignature: string, timestamp: string, nonce: string, echostr: string, _options?: Configuration): Observable<string> {
        return this.getCallbackWithHttpInfo(msgSignature, timestamp, nonce, echostr, _options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * JS-SDK Verify the configuration parameters of application identity and permission
     * JS-SDK Verify the configuration parameters of application identity and permission
     * @param spaceId
     * @param url
     */
    public getJsSdkAgentConfigWithHttpInfo(spaceId: string, url: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvJsSdkAgentConfigVo>> {
        const requestContextPromise = this.requestFactory.getJsSdkAgentConfig(spaceId, url, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getJsSdkAgentConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * JS-SDK Verify the configuration parameters of application identity and permission
     * JS-SDK Verify the configuration parameters of application identity and permission
     * @param spaceId
     * @param url
     */
    public getJsSdkAgentConfig(spaceId: string, url: string, _options?: Configuration): Observable<ResponseDataWeComIsvJsSdkAgentConfigVo> {
        return this.getJsSdkAgentConfigWithHttpInfo(spaceId, url, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvJsSdkAgentConfigVo>) => apiResponse.data));
    }

    /**
     * JS-SDK Verify the configuration parameters of enterprise identity and authority
     * JS-SDK Verify the configuration parameters of enterprise identity and authority
     * @param spaceId
     * @param url
     */
    public getJsSdkConfigWithHttpInfo(spaceId: string, url: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvJsSdkConfigVo>> {
        const requestContextPromise = this.requestFactory.getJsSdkConfig(spaceId, url, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getJsSdkConfigWithHttpInfo(rsp)));
            }));
    }

    /**
     * JS-SDK Verify the configuration parameters of enterprise identity and authority
     * JS-SDK Verify the configuration parameters of enterprise identity and authority
     * @param spaceId
     * @param url
     */
    public getJsSdkConfig(spaceId: string, url: string, _options?: Configuration): Observable<ResponseDataWeComIsvJsSdkConfigVo> {
        return this.getJsSdkConfigWithHttpInfo(spaceId, url, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvJsSdkConfigVo>) => apiResponse.data));
    }

    /**
     * Get the authorization link for installing vika
     * Get the authorization link for installing vika
     * @param finalPath
     */
    public getRegisterInstallSelfUrlWithHttpInfo(finalPath: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvRegisterInstallSelfUrlVo>> {
        const requestContextPromise = this.requestFactory.getRegisterInstallSelfUrl(finalPath, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRegisterInstallSelfUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the authorization link for installing vika
     * Get the authorization link for installing vika
     * @param finalPath
     */
    public getRegisterInstallSelfUrl(finalPath: string, _options?: Configuration): Observable<ResponseDataWeComIsvRegisterInstallSelfUrlVo> {
        return this.getRegisterInstallSelfUrlWithHttpInfo(finalPath, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvRegisterInstallSelfUrlVo>) => apiResponse.data));
    }

    /**
     * Get the registration code for registering WeCom and installing vika
     * Get the registration code for registering WeCom and installing vika
     */
    public getRegisterInstallWeComWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvRegisterInstallWeComVo>> {
        const requestContextPromise = this.requestFactory.getRegisterInstallWeCom(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getRegisterInstallWeComWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get the registration code for registering WeCom and installing vika
     * Get the registration code for registering WeCom and installing vika
     */
    public getRegisterInstallWeCom(_options?: Configuration): Observable<ResponseDataWeComIsvRegisterInstallWeComVo> {
        return this.getRegisterInstallWeComWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvRegisterInstallWeComVo>) => apiResponse.data));
    }

    /**
     * Get tenant binding information
     * Get tenant binding information
     * @param suiteId
     * @param authCorpId
     */
    public getTenantInfoWithHttpInfo(suiteId: string, authCorpId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataTenantDetailVO>> {
        const requestContextPromise = this.requestFactory.getTenantInfo(suiteId, authCorpId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTenantInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get tenant binding information
     * Get tenant binding information
     * @param suiteId
     * @param authCorpId
     */
    public getTenantInfo(suiteId: string, authCorpId: string, _options?: Configuration): Observable<ResponseDataTenantDetailVO> {
        return this.getTenantInfoWithHttpInfo(suiteId, authCorpId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataTenantDetailVO>) => apiResponse.data));
    }

    /**
     * Tenant space replacement master administrator
     * Tenant space replacement master administrator
     * @param weComIsvAdminChangeRo
     */
    public postAdminChangeWithHttpInfo(weComIsvAdminChangeRo: WeComIsvAdminChangeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postAdminChange(weComIsvAdminChangeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postAdminChangeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Tenant space replacement master administrator
     * Tenant space replacement master administrator
     * @param weComIsvAdminChangeRo
     */
    public postAdminChange(weComIsvAdminChangeRo: WeComIsvAdminChangeRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.postAdminChangeWithHttpInfo(weComIsvAdminChangeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * @param body
     * @param type
     * @param msgSignature
     * @param timestamp
     * @param nonce
     * @param suiteId
     */
    public postCallbackWithHttpInfo(body: string, type: string, msgSignature: string, timestamp: string, nonce: string, suiteId?: string, _options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.postCallback(body, type, msgSignature, timestamp, nonce, suiteId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postCallbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * @param body
     * @param type
     * @param msgSignature
     * @param timestamp
     * @param nonce
     * @param suiteId
     */
    public postCallback(body: string, type: string, msgSignature: string, timestamp: string, nonce: string, suiteId?: string, _options?: Configuration): Observable<string> {
        return this.postCallbackWithHttpInfo(body, type, msgSignature, timestamp, nonce, suiteId, _options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Invite unauthorized users
     * Invite unauthorized users
     * @param weComIsvInviteUnauthMemberRo
     */
    public postInviteUnauthMemberWithHttpInfo(weComIsvInviteUnauthMemberRo: WeComIsvInviteUnauthMemberRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.postInviteUnauthMember(weComIsvInviteUnauthMemberRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postInviteUnauthMemberWithHttpInfo(rsp)));
            }));
    }

    /**
     * Invite unauthorized users
     * Invite unauthorized users
     * @param weComIsvInviteUnauthMemberRo
     */
    public postInviteUnauthMember(weComIsvInviteUnauthMemberRo: WeComIsvInviteUnauthMemberRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.postInviteUnauthMemberWithHttpInfo(weComIsvInviteUnauthMemberRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * WeCom administrator jumps to the third-party application management page and automatically logs in
     * WeCom administrator jumps to the third-party application management page and automatically logs in
     * @param weComIsvLoginAdminCodeRo
     */
    public postLoginAdminCodeWithHttpInfo(weComIsvLoginAdminCodeRo: WeComIsvLoginAdminCodeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvUserLoginVo>> {
        const requestContextPromise = this.requestFactory.postLoginAdminCode(weComIsvLoginAdminCodeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postLoginAdminCodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * WeCom administrator jumps to the third-party application management page and automatically logs in
     * WeCom administrator jumps to the third-party application management page and automatically logs in
     * @param weComIsvLoginAdminCodeRo
     */
    public postLoginAdminCode(weComIsvLoginAdminCodeRo: WeComIsvLoginAdminCodeRo, _options?: Configuration): Observable<ResponseDataWeComIsvUserLoginVo> {
        return this.postLoginAdminCodeWithHttpInfo(weComIsvLoginAdminCodeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvUserLoginVo>) => apiResponse.data));
    }

    /**
     * WeCom third-party application scanning code login
     * WeCom third-party application scanning code login
     * @param weComIsvLoginAuthCodeRo
     */
    public postLoginAuthCodeWithHttpInfo(weComIsvLoginAuthCodeRo: WeComIsvLoginAuthCodeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvUserLoginVo>> {
        const requestContextPromise = this.requestFactory.postLoginAuthCode(weComIsvLoginAuthCodeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postLoginAuthCodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * WeCom third-party application scanning code login
     * WeCom third-party application scanning code login
     * @param weComIsvLoginAuthCodeRo
     */
    public postLoginAuthCode(weComIsvLoginAuthCodeRo: WeComIsvLoginAuthCodeRo, _options?: Configuration): Observable<ResponseDataWeComIsvUserLoginVo> {
        return this.postLoginAuthCodeWithHttpInfo(weComIsvLoginAuthCodeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvUserLoginVo>) => apiResponse.data));
    }

    /**
     * Auto login to third-party applications within WeCom
     * Auto login to third-party applications within WeCom
     * @param weComIsvLoginCodeRo
     */
    public postLoginCodeWithHttpInfo(weComIsvLoginCodeRo: WeComIsvLoginCodeRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWeComIsvUserLoginVo>> {
        const requestContextPromise = this.requestFactory.postLoginCode(weComIsvLoginCodeRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postLoginCodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Auto login to third-party applications within WeCom
     * Auto login to third-party applications within WeCom
     * @param weComIsvLoginCodeRo
     */
    public postLoginCode(weComIsvLoginCodeRo: WeComIsvLoginCodeRo, _options?: Configuration): Observable<ResponseDataWeComIsvUserLoginVo> {
        return this.postLoginCodeWithHttpInfo(weComIsvLoginCodeRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWeComIsvUserLoginVo>) => apiResponse.data));
    }

}

import { ThirdPartyPlatformIntegrationInterfaceWoaApiRequestFactory, ThirdPartyPlatformIntegrationInterfaceWoaApiResponseProcessor} from "../apis/ThirdPartyPlatformIntegrationInterfaceWoaApi";
export class ObservableThirdPartyPlatformIntegrationInterfaceWoaApi {
    private requestFactory: ThirdPartyPlatformIntegrationInterfaceWoaApiRequestFactory;
    private responseProcessor: ThirdPartyPlatformIntegrationInterfaceWoaApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ThirdPartyPlatformIntegrationInterfaceWoaApiRequestFactory,
        responseProcessor?: ThirdPartyPlatformIntegrationInterfaceWoaApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ThirdPartyPlatformIntegrationInterfaceWoaApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ThirdPartyPlatformIntegrationInterfaceWoaApiResponseProcessor();
    }

    /**
     * Woa Application Binding Space
     * @param woaAppBindSpaceRo
     */
    public bindSpaceWithHttpInfo(woaAppBindSpaceRo: WoaAppBindSpaceRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.bindSpace(woaAppBindSpaceRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.bindSpaceWithHttpInfo(rsp)));
            }));
    }

    /**
     * Woa Application Binding Space
     * @param woaAppBindSpaceRo
     */
    public bindSpace(woaAppBindSpaceRo: WoaAppBindSpaceRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.bindSpaceWithHttpInfo(woaAppBindSpaceRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Apply to refresh the address book manually
     * Woa App Refresh Address Book
     * @param xSpaceId Space ID
     */
    public refreshContactWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.refreshContact(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.refreshContactWithHttpInfo(rsp)));
            }));
    }

    /**
     * Apply to refresh the address book manually
     * Woa App Refresh Address Book
     * @param xSpaceId Space ID
     */
    public refreshContact(xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.refreshContactWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Woa Application User Login
     * @param woaUserLoginRo
     */
    public userLoginWithHttpInfo(woaUserLoginRo: WoaUserLoginRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWoaUserLoginVo>> {
        const requestContextPromise = this.requestFactory.userLogin(woaUserLoginRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.userLoginWithHttpInfo(rsp)));
            }));
    }

    /**
     * Woa Application User Login
     * @param woaUserLoginRo
     */
    public userLogin(woaUserLoginRo: WoaUserLoginRo, _options?: Configuration): Observable<ResponseDataWoaUserLoginVo> {
        return this.userLoginWithHttpInfo(woaUserLoginRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWoaUserLoginVo>) => apiResponse.data));
    }

}

import { VCodeActivityAPIApiRequestFactory, VCodeActivityAPIApiResponseProcessor} from "../apis/VCodeActivityAPIApi";
export class ObservableVCodeActivityAPIApi {
    private requestFactory: VCodeActivityAPIApiRequestFactory;
    private responseProcessor: VCodeActivityAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: VCodeActivityAPIApiRequestFactory,
        responseProcessor?: VCodeActivityAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new VCodeActivityAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new VCodeActivityAPIApiResponseProcessor();
    }

    /**
     * Create Activity
     * @param vCodeActivityRo
     */
    public create2WithHttpInfo(vCodeActivityRo: VCodeActivityRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVCodeActivityVo>> {
        const requestContextPromise = this.requestFactory.create2(vCodeActivityRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Activity
     * @param vCodeActivityRo
     */
    public create2(vCodeActivityRo: VCodeActivityRo, _options?: Configuration): Observable<ResponseDataVCodeActivityVo> {
        return this.create2WithHttpInfo(vCodeActivityRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVCodeActivityVo>) => apiResponse.data));
    }

    /**
     * Delete Activity
     * @param activityId Activity ID
     */
    public delete4WithHttpInfo(activityId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete4(activityId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete4WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Activity
     * @param activityId Activity ID
     */
    public delete4(activityId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete4WithHttpInfo(activityId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete Activity
     * @param activityId Activity ID
     */
    public delete5WithHttpInfo(activityId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete5(activityId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete5WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Activity
     * @param activityId Activity ID
     */
    public delete5(activityId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete5WithHttpInfo(activityId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit Activity Info
     * @param vCodeActivityRo
     * @param activityId Activity ID
     */
    public edit2WithHttpInfo(vCodeActivityRo: VCodeActivityRo, activityId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit2(vCodeActivityRo, activityId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.edit2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit Activity Info
     * @param vCodeActivityRo
     * @param activityId Activity ID
     */
    public edit2(vCodeActivityRo: VCodeActivityRo, activityId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.edit2WithHttpInfo(vCodeActivityRo, activityId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Query Activity List
     * @param keyword Keyword
     */
    public list1WithHttpInfo(keyword?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListVCodeActivityVo>> {
        const requestContextPromise = this.requestFactory.list1(keyword, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Query Activity List
     * @param keyword Keyword
     */
    public list1(keyword?: string, _options?: Configuration): Observable<ResponseDataListVCodeActivityVo> {
        return this.list1WithHttpInfo(keyword, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListVCodeActivityVo>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Activity Page
     * @param page
     * @param pageObjectParams Page params
     * @param keyword Keyword
     */
    public page2WithHttpInfo(page: Page, pageObjectParams: string, keyword?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoVCodeActivityPageVo>> {
        const requestContextPromise = this.requestFactory.page2(page, pageObjectParams, keyword, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.page2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Activity Page
     * @param page
     * @param pageObjectParams Page params
     * @param keyword Keyword
     */
    public page2(page: Page, pageObjectParams: string, keyword?: string, _options?: Configuration): Observable<ResponseDataPageInfoVCodeActivityPageVo> {
        return this.page2WithHttpInfo(page, pageObjectParams, keyword, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoVCodeActivityPageVo>) => apiResponse.data));
    }

}

import { VCodeSystemCouponAPIApiRequestFactory, VCodeSystemCouponAPIApiResponseProcessor} from "../apis/VCodeSystemCouponAPIApi";
export class ObservableVCodeSystemCouponAPIApi {
    private requestFactory: VCodeSystemCouponAPIApiRequestFactory;
    private responseProcessor: VCodeSystemCouponAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: VCodeSystemCouponAPIApiRequestFactory,
        responseProcessor?: VCodeSystemCouponAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new VCodeSystemCouponAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new VCodeSystemCouponAPIApiResponseProcessor();
    }

    /**
     * Create Coupon Template
     * @param vCodeCouponRo
     */
    public create1WithHttpInfo(vCodeCouponRo: VCodeCouponRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVCodeCouponVo>> {
        const requestContextPromise = this.requestFactory.create1(vCodeCouponRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Coupon Template
     * @param vCodeCouponRo
     */
    public create1(vCodeCouponRo: VCodeCouponRo, _options?: Configuration): Observable<ResponseDataVCodeCouponVo> {
        return this.create1WithHttpInfo(vCodeCouponRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVCodeCouponVo>) => apiResponse.data));
    }

    /**
     * Delete Coupon Template
     * @param templateId Coupon Template ID
     */
    public delete2WithHttpInfo(templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete2(templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Coupon Template
     * @param templateId Coupon Template ID
     */
    public delete2(templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete2WithHttpInfo(templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete Coupon Template
     * @param templateId Coupon Template ID
     */
    public delete3WithHttpInfo(templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete3(templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Coupon Template
     * @param templateId Coupon Template ID
     */
    public delete3(templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete3WithHttpInfo(templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit Coupon Template
     * @param vCodeCouponRo
     * @param templateId Coupon Template ID
     */
    public edit1WithHttpInfo(vCodeCouponRo: VCodeCouponRo, templateId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit1(vCodeCouponRo, templateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.edit1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit Coupon Template
     * @param vCodeCouponRo
     * @param templateId Coupon Template ID
     */
    public edit1(vCodeCouponRo: VCodeCouponRo, templateId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.edit1WithHttpInfo(vCodeCouponRo, templateId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Query Coupon View List
     * @param keyword Keyword
     */
    public listWithHttpInfo(keyword?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListVCodeCouponVo>> {
        const requestContextPromise = this.requestFactory.list(keyword, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.listWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query Coupon View List
     * @param keyword Keyword
     */
    public list(keyword?: string, _options?: Configuration): Observable<ResponseDataListVCodeCouponVo> {
        return this.listWithHttpInfo(keyword, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListVCodeCouponVo>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Coupon Page
     * @param page
     * @param pageObjectParams Page Params
     * @param keyword Keyword
     */
    public page1WithHttpInfo(page: Page, pageObjectParams: string, keyword?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoVCodeCouponPageVo>> {
        const requestContextPromise = this.requestFactory.page1(page, pageObjectParams, keyword, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.page1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Coupon Page
     * @param page
     * @param pageObjectParams Page Params
     * @param keyword Keyword
     */
    public page1(page: Page, pageObjectParams: string, keyword?: string, _options?: Configuration): Observable<ResponseDataPageInfoVCodeCouponPageVo> {
        return this.page1WithHttpInfo(page, pageObjectParams, keyword, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoVCodeCouponPageVo>) => apiResponse.data));
    }

}

import { VCodeSystemVCodeAPIApiRequestFactory, VCodeSystemVCodeAPIApiResponseProcessor} from "../apis/VCodeSystemVCodeAPIApi";
export class ObservableVCodeSystemVCodeAPIApi {
    private requestFactory: VCodeSystemVCodeAPIApiRequestFactory;
    private responseProcessor: VCodeSystemVCodeAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: VCodeSystemVCodeAPIApiRequestFactory,
        responseProcessor?: VCodeSystemVCodeAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new VCodeSystemVCodeAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new VCodeSystemVCodeAPIApiResponseProcessor();
    }

    /**
     * Delete VCode
     * @param code VCode
     */
    public _deleteWithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory._delete(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor._deleteWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete VCode
     * @param code VCode
     */
    public _delete(code: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this._deleteWithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Create VCode
     * @param vCodeCreateRo
     */
    public createWithHttpInfo(vCodeCreateRo: VCodeCreateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListString>> {
        const requestContextPromise = this.requestFactory.create(vCodeCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create VCode
     * @param vCodeCreateRo
     */
    public create(vCodeCreateRo: VCodeCreateRo, _options?: Configuration): Observable<ResponseDataListString> {
        return this.createWithHttpInfo(vCodeCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListString>) => apiResponse.data));
    }

    /**
     * Delete VCode
     * @param code VCode
     */
    public delete1WithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete1(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete VCode
     * @param code VCode
     */
    public delete1(code: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete1WithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit VCode Setting
     * @param vCodeUpdateRo
     * @param code VCode
     */
    public editWithHttpInfo(vCodeUpdateRo: VCodeUpdateRo, code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.edit(vCodeUpdateRo, code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.editWithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit VCode Setting
     * @param vCodeUpdateRo
     * @param code VCode
     */
    public edit(vCodeUpdateRo: VCodeUpdateRo, code: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.editWithHttpInfo(vCodeUpdateRo, code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Exchange VCode
     * @param code VCode
     */
    public exchangeWithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataInteger>> {
        const requestContextPromise = this.requestFactory.exchange(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.exchangeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Exchange VCode
     * @param code VCode
     */
    public exchange(code: string, _options?: Configuration): Observable<ResponseDataInteger> {
        return this.exchangeWithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataInteger>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query VCode Page
     * @param page
     * @param pageObjectParams Page Params
     * @param type Type (0: official invitation code; 2: redemption code)
     * @param activityId Activity ID
     */
    public pageWithHttpInfo(page: Page, pageObjectParams: string, type?: number, activityId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoVCodePageVo>> {
        const requestContextPromise = this.requestFactory.page(page, pageObjectParams, type, activityId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.pageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query VCode Page
     * @param page
     * @param pageObjectParams Page Params
     * @param type Type (0: official invitation code; 2: redemption code)
     * @param activityId Activity ID
     */
    public page(page: Page, pageObjectParams: string, type?: number, activityId?: string, _options?: Configuration): Observable<ResponseDataPageInfoVCodePageVo> {
        return this.pageWithHttpInfo(page, pageObjectParams, type, activityId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoVCodePageVo>) => apiResponse.data));
    }

}

import { WeChatMiniAppAPIApiRequestFactory, WeChatMiniAppAPIApiResponseProcessor} from "../apis/WeChatMiniAppAPIApi";
export class ObservableWeChatMiniAppAPIApi {
    private requestFactory: WeChatMiniAppAPIApiRequestFactory;
    private responseProcessor: WeChatMiniAppAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WeChatMiniAppAPIApiRequestFactory,
        responseProcessor?: WeChatMiniAppAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WeChatMiniAppAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WeChatMiniAppAPIApiResponseProcessor();
    }

    /**
     * Mini Program Authorized Login (Silent Authorization)
     * Authorized Login(wx.login user)
     * @param code Wechat login credentials obtained by wx.login
     */
    public authorizeWithHttpInfo(code: string, _options?: Configuration): Observable<HttpInfo<ResponseDataLoginResultVo>> {
        const requestContextPromise = this.requestFactory.authorize(code, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.authorizeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Mini Program Authorized Login (Silent Authorization)
     * Authorized Login(wx.login user)
     * @param code Wechat login credentials obtained by wx.login
     */
    public authorize(code: string, _options?: Configuration): Observable<ResponseDataLoginResultVo> {
        return this.authorizeWithHttpInfo(code, _options).pipe(map((apiResponse: HttpInfo<ResponseDataLoginResultVo>) => apiResponse.data));
    }

    /**
     * Get User Information
     */
    public getInfoWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataWechatInfoVo>> {
        const requestContextPromise = this.requestFactory.getInfo(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get User Information
     */
    public getInfo(_options?: Configuration): Observable<ResponseDataWechatInfoVo> {
        return this.getInfoWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataWechatInfoVo>) => apiResponse.data));
    }

    /**
     * Synchronize WeChat User Information
     * @param signature signature
     * @param rawData data
     * @param encryptedData encrypted data
     * @param iv initial vector for encryption algorithm
     */
    public infoWithHttpInfo(signature: string, rawData: string, encryptedData: string, iv: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.info(signature, rawData, encryptedData, iv, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.infoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Synchronize WeChat User Information
     * @param signature signature
     * @param rawData data
     * @param encryptedData encrypted data
     * @param iv initial vector for encryption algorithm
     */
    public info(signature: string, rawData: string, encryptedData: string, iv: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.infoWithHttpInfo(signature, rawData, encryptedData, iv, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * The Operation of The Applet Code
     * @param type type (0: Enter verification validity; 1: Confirm the login (the WeChat account of the Weige account is bound); 2: Cancel the login/bind the account; 3: Confirm the binding account)
     * @param mark mini program code unique identifier
     */
    public operateWithHttpInfo(type: number, mark: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.operate(type, mark, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.operateWithHttpInfo(rsp)));
            }));
    }

    /**
     * The Operation of The Applet Code
     * @param type type (0: Enter verification validity; 1: Confirm the login (the WeChat account of the Weige account is bound); 2: Cancel the login/bind the account; 3: Confirm the binding account)
     * @param mark mini program code unique identifier
     */
    public operate(type: number, mark: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.operateWithHttpInfo(type, mark, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * User authorized to use WeChat mobile number
     * @param encryptedData encrypted data
     * @param iv initial vector for encryption algorithm
     * @param mark mini program code unique identifier
     */
    public phoneWithHttpInfo(encryptedData: string, iv: string, mark?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataLoginResultVo>> {
        const requestContextPromise = this.requestFactory.phone(encryptedData, iv, mark, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.phoneWithHttpInfo(rsp)));
            }));
    }

    /**
     * User authorized to use WeChat mobile number
     * @param encryptedData encrypted data
     * @param iv initial vector for encryption algorithm
     * @param mark mini program code unique identifier
     */
    public phone(encryptedData: string, iv: string, mark?: string, _options?: Configuration): Observable<ResponseDataLoginResultVo> {
        return this.phoneWithHttpInfo(encryptedData, iv, mark, _options).pipe(map((apiResponse: HttpInfo<ResponseDataLoginResultVo>) => apiResponse.data));
    }

}

import { WeChatMpAPIApiRequestFactory, WeChatMpAPIApiResponseProcessor} from "../apis/WeChatMpAPIApi";
export class ObservableWeChatMpAPIApi {
    private requestFactory: WeChatMpAPIApiRequestFactory;
    private responseProcessor: WeChatMpAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WeChatMpAPIApiRequestFactory,
        responseProcessor?: WeChatMpAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WeChatMpAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WeChatMpAPIApiResponseProcessor();
    }

    /**
     * Web Page Authorization Callback
     * @param code coding. JS gets the loginTmpCode, redirects and returns after jumping to the specified connection
     * @param state declare value. Used to prevent replay attacks
     */
    public callback1WithHttpInfo(code: string, state: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.callback1(code, state, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callback1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Web Page Authorization Callback
     * @param code coding. JS gets the loginTmpCode, redirects and returns after jumping to the specified connection
     * @param state declare value. Used to prevent replay attacks
     */
    public callback1(code: string, state: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.callback1WithHttpInfo(code, state, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Scene: Scan code login, account binding polling results
     * Scan poll
     * @param type type (0: scan code to log in; 1: account binding)
     * @param mark the unique identifier of the qrcode
     */
    public pollWithHttpInfo(type: number, mark: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.poll(type, mark, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.pollWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scene: Scan code login, account binding polling results
     * Scan poll
     * @param type type (0: scan code to log in; 1: account binding)
     * @param mark the unique identifier of the qrcode
     */
    public poll(type: number, mark: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.pollWithHttpInfo(type, mark, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * Get qrcode
     */
    public qrcodeWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataQrCodeVo>> {
        const requestContextPromise = this.requestFactory.qrcode(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.qrcodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get qrcode
     */
    public qrcode(_options?: Configuration): Observable<ResponseDataQrCodeVo> {
        return this.qrcodeWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataQrCodeVo>) => apiResponse.data));
    }

    /**
     * Get wechat signature
     * @param mpSignatureRo
     */
    public signatureWithHttpInfo(mpSignatureRo: MpSignatureRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWxJsapiSignature>> {
        const requestContextPromise = this.requestFactory.signature(mpSignatureRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.signatureWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get wechat signature
     * @param mpSignatureRo
     */
    public signature(mpSignatureRo: MpSignatureRo, _options?: Configuration): Observable<ResponseDataWxJsapiSignature> {
        return this.signatureWithHttpInfo(mpSignatureRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWxJsapiSignature>) => apiResponse.data));
    }

}

import { WeChatOpenPlatformAPIApiRequestFactory, WeChatOpenPlatformAPIApiResponseProcessor} from "../apis/WeChatOpenPlatformAPIApi";
export class ObservableWeChatOpenPlatformAPIApi {
    private requestFactory: WeChatOpenPlatformAPIApiRequestFactory;
    private responseProcessor: WeChatOpenPlatformAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WeChatOpenPlatformAPIApiRequestFactory,
        responseProcessor?: WeChatOpenPlatformAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WeChatOpenPlatformAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WeChatOpenPlatformAPIApiResponseProcessor();
    }

    /**
     * WeChat Message Push Callback
     * @param appId
     * @param signature
     * @param timestamp
     * @param nonce
     * @param openid
     * @param encryptType
     * @param msgSignature
     * @param body
     */
    public callbackWithHttpInfo(appId: string, signature: string, timestamp: string, nonce: string, openid: string, encryptType: string, msgSignature: string, body?: string, _options?: Configuration): Observable<HttpInfo<any>> {
        const requestContextPromise = this.requestFactory.callback(appId, signature, timestamp, nonce, openid, encryptType, msgSignature, body, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.callbackWithHttpInfo(rsp)));
            }));
    }

    /**
     * WeChat Message Push Callback
     * @param appId
     * @param signature
     * @param timestamp
     * @param nonce
     * @param openid
     * @param encryptType
     * @param msgSignature
     * @param body
     */
    public callback(appId: string, signature: string, timestamp: string, nonce: string, openid: string, encryptType: string, msgSignature: string, body?: string, _options?: Configuration): Observable<any> {
        return this.callbackWithHttpInfo(appId, signature, timestamp, nonce, openid, encryptType, msgSignature, body, _options).pipe(map((apiResponse: HttpInfo<any>) => apiResponse.data));
    }

    /**
     * Create Pre-authorization URL
     * @param authType Authorized account type, 1. Only the official account authorization list is displayed, 2. Only the applet authorization list is displayed, 3. Both are displayed
     * @param componentAppid Authorized Official Account or Mini Program AppId
     */
    public createPreAuthUrlWithHttpInfo(authType: string, componentAppid: string, _options?: Configuration): Observable<HttpInfo<ResponseDataString>> {
        const requestContextPromise = this.requestFactory.createPreAuthUrl(authType, componentAppid, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createPreAuthUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Create Pre-authorization URL
     * @param authType Authorized account type, 1. Only the official account authorization list is displayed, 2. Only the applet authorization list is displayed, 3. Both are displayed
     * @param componentAppid Authorized Official Account or Mini Program AppId
     */
    public createPreAuthUrl(authType: string, componentAppid: string, _options?: Configuration): Observable<ResponseDataString> {
        return this.createPreAuthUrlWithHttpInfo(authType, componentAppid, _options).pipe(map((apiResponse: HttpInfo<ResponseDataString>) => apiResponse.data));
    }

    /**
     * The scene value cannot be passed at all, and the string type is preferred.
     * Generates Qrcode
     * @param type qrcode type, type value (temporary integer value: QR_SCENE, temporary string value: QR_STR_SCENE; permanent integer value: QR_LIMIT_SCENE, permanent string value: QR_LIMIT_STR_SCENE)
     * @param expireSeconds the valid time of the QR code, in seconds. The maximum is not more than 2592000 (that is, 30 days), and the default is 30 seconds.
     * @param sceneId scene value ID, a 32-bit non-zero integer for a temporary QR code, and a maximum value of 100000 for a permanent QR code (current parameters only support 1--100000)
     * @param sceneStr Scene value ID (ID in string form), string type, length limited from 1 to 64.
     * @param appId wechat public account appId
     */
    public createWxQrCodeWithHttpInfo(type?: string, expireSeconds?: number, sceneId?: number, sceneStr?: string, appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataQrCodeVo>> {
        const requestContextPromise = this.requestFactory.createWxQrCode(type, expireSeconds, sceneId, sceneStr, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createWxQrCodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * The scene value cannot be passed at all, and the string type is preferred.
     * Generates Qrcode
     * @param type qrcode type, type value (temporary integer value: QR_SCENE, temporary string value: QR_STR_SCENE; permanent integer value: QR_LIMIT_SCENE, permanent string value: QR_LIMIT_STR_SCENE)
     * @param expireSeconds the valid time of the QR code, in seconds. The maximum is not more than 2592000 (that is, 30 days), and the default is 30 seconds.
     * @param sceneId scene value ID, a 32-bit non-zero integer for a temporary QR code, and a maximum value of 100000 for a permanent QR code (current parameters only support 1--100000)
     * @param sceneStr Scene value ID (ID in string form), string type, length limited from 1 to 64.
     * @param appId wechat public account appId
     */
    public createWxQrCode(type?: string, expireSeconds?: number, sceneId?: number, sceneStr?: string, appId?: string, _options?: Configuration): Observable<ResponseDataQrCodeVo> {
        return this.createWxQrCodeWithHttpInfo(type, expireSeconds, sceneId, sceneStr, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataQrCodeVo>) => apiResponse.data));
    }

    /**
     * Delete Qrcode
     * @param qrCodeId qrcode ID
     * @param appId wechat public account appId
     */
    public delQrCodeWithHttpInfo(qrCodeId: string, appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delQrCode(qrCodeId, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delQrCodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Qrcode
     * @param qrCodeId qrcode ID
     * @param appId wechat public account appId
     */
    public delQrCode(qrCodeId: string, appId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delQrCodeWithHttpInfo(qrCodeId, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete Qrcode
     * @param qrCodeId qrcode ID
     * @param appId wechat public account appId
     */
    public delQrCode1WithHttpInfo(qrCodeId: string, appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delQrCode1(qrCodeId, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delQrCode1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete Qrcode
     * @param qrCodeId qrcode ID
     * @param appId wechat public account appId
     */
    public delQrCode1(qrCodeId: string, appId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delQrCode1WithHttpInfo(qrCodeId, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Obtain the basic information of the authorized account
     * @param authorizerAppid
     */
    public getAuthorizerInfoWithHttpInfo(authorizerAppid?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWechatAuthorizationEntity>> {
        const requestContextPromise = this.requestFactory.getAuthorizerInfo(authorizerAppid, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAuthorizerInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Obtain the basic information of the authorized account
     * @param authorizerAppid
     */
    public getAuthorizerInfo(authorizerAppid?: string, _options?: Configuration): Observable<ResponseDataWechatAuthorizationEntity> {
        return this.getAuthorizerInfoWithHttpInfo(authorizerAppid, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWechatAuthorizationEntity>) => apiResponse.data));
    }

    /**
     * Get All Authorized Account Information
     */
    public getAuthorizerListWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataWxOpenAuthorizerListResult>> {
        const requestContextPromise = this.requestFactory.getAuthorizerList(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAuthorizerListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get All Authorized Account Information
     */
    public getAuthorizerList(_options?: Configuration): Observable<ResponseDataWxOpenAuthorizerListResult> {
        return this.getAuthorizerListWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataWxOpenAuthorizerListResult>) => apiResponse.data));
    }

    /**
     * Receive Verification Ticket
     * @param timestamp
     * @param nonce
     * @param signature
     * @param body
     * @param encryptType
     * @param msgSignature
     */
    public getComponentVerifyTicketWithHttpInfo(timestamp: string, nonce: string, signature: string, body?: string, encryptType?: string, msgSignature?: string, _options?: Configuration): Observable<HttpInfo<string>> {
        const requestContextPromise = this.requestFactory.getComponentVerifyTicket(timestamp, nonce, signature, body, encryptType, msgSignature, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getComponentVerifyTicketWithHttpInfo(rsp)));
            }));
    }

    /**
     * Receive Verification Ticket
     * @param timestamp
     * @param nonce
     * @param signature
     * @param body
     * @param encryptType
     * @param msgSignature
     */
    public getComponentVerifyTicket(timestamp: string, nonce: string, signature: string, body?: string, encryptType?: string, msgSignature?: string, _options?: Configuration): Observable<string> {
        return this.getComponentVerifyTicketWithHttpInfo(timestamp, nonce, signature, body, encryptType, msgSignature, _options).pipe(map((apiResponse: HttpInfo<string>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Qrcode pagination list
     * @param page
     * @param pageObjectParams page params
     * @param appId wechat public account appId
     */
    public getQrCodePageWithHttpInfo(page: Page, pageObjectParams: string, appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoQrCodePageVo>> {
        const requestContextPromise = this.requestFactory.getQrCodePage(page, pageObjectParams, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getQrCodePageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Query Qrcode pagination list
     * @param page
     * @param pageObjectParams page params
     * @param appId wechat public account appId
     */
    public getQrCodePage(page: Page, pageObjectParams: string, appId?: string, _options?: Configuration): Observable<ResponseDataPageInfoQrCodePageVo> {
        return this.getQrCodePageWithHttpInfo(page, pageObjectParams, appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoQrCodePageVo>) => apiResponse.data));
    }

    /**
     * Get Authorization Code Get Authorization Information
     * @param authCode
     */
    public getQueryAuthWithHttpInfo(authCode?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWechatAuthorizationEntity>> {
        const requestContextPromise = this.requestFactory.getQueryAuth(authCode, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getQueryAuthWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get Authorization Code Get Authorization Information
     * @param authCode
     */
    public getQueryAuth(authCode?: string, _options?: Configuration): Observable<ResponseDataWechatAuthorizationEntity> {
        return this.getQueryAuthWithHttpInfo(authCode, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWechatAuthorizationEntity>) => apiResponse.data));
    }

    /**
     * Get WeChat server IP list
     * @param appId
     */
    public getWechatIpListWithHttpInfo(appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListString>> {
        const requestContextPromise = this.requestFactory.getWechatIpList(appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWechatIpListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get WeChat server IP list
     * @param appId
     */
    public getWechatIpList(appId?: string, _options?: Configuration): Observable<ResponseDataListString> {
        return this.getWechatIpListWithHttpInfo(appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListString>) => apiResponse.data));
    }

    /**
     * Be sure to add keyword replies first in the background of the official account
     * Synchronously update WeChat keyword automatic reply rules
     * @param appId
     */
    public updateWxReplyWithHttpInfo(appId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateWxReply(appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateWxReplyWithHttpInfo(rsp)));
            }));
    }

    /**
     * Be sure to add keyword replies first in the background of the official account
     * Synchronously update WeChat keyword automatic reply rules
     * @param appId
     */
    public updateWxReply(appId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateWxReplyWithHttpInfo(appId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { WidgetSDKPackageApiApiRequestFactory, WidgetSDKPackageApiApiResponseProcessor} from "../apis/WidgetSDKPackageApiApi";
export class ObservableWidgetSDKPackageApiApi {
    private requestFactory: WidgetSDKPackageApiApiRequestFactory;
    private responseProcessor: WidgetSDKPackageApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WidgetSDKPackageApiApiRequestFactory,
        responseProcessor?: WidgetSDKPackageApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WidgetSDKPackageApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WidgetSDKPackageApiApiResponseProcessor();
    }

    /**
     * widget-cli initialization create widget
     * Create widget
     * @param widgetPackageCreateRo
     * @param authorization developer token
     */
    public createWidgetWithHttpInfo(widgetPackageCreateRo: WidgetPackageCreateRo, authorization: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWidgetReleaseCreateVo>> {
        const requestContextPromise = this.requestFactory.createWidget(widgetPackageCreateRo, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli initialization create widget
     * Create widget
     * @param widgetPackageCreateRo
     * @param authorization developer token
     */
    public createWidget(widgetPackageCreateRo: WidgetPackageCreateRo, authorization: string, _options?: Configuration): Observable<ResponseDataWidgetReleaseCreateVo> {
        return this.createWidgetWithHttpInfo(widgetPackageCreateRo, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetReleaseCreateVo>) => apiResponse.data));
    }

    /**
     * widget-cli get widget package info
     * Get widget package info
     * @param packageId
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public getWidgetPackageInfoWithHttpInfo(packageId: string, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataWidgetPackageInfoVo>> {
        const requestContextPromise = this.requestFactory.getWidgetPackageInfo(packageId, authorization, acceptLanguage, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWidgetPackageInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli get widget package info
     * Get widget package info
     * @param packageId
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public getWidgetPackageInfo(packageId: string, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<ResponseDataWidgetPackageInfoVo> {
        return this.getWidgetPackageInfoWithHttpInfo(packageId, authorization, acceptLanguage, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetPackageInfoVo>) => apiResponse.data));
    }

    /**
     * widget-cli get widget store information
     * Get widget store information
     * @param spaceId
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public getWidgetPackageListInfoWithHttpInfo(spaceId: string, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetPackageInfoVo>> {
        const requestContextPromise = this.requestFactory.getWidgetPackageListInfo(spaceId, authorization, acceptLanguage, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWidgetPackageListInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli get widget store information
     * Get widget store information
     * @param spaceId
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public getWidgetPackageListInfo(spaceId: string, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<ResponseDataListWidgetPackageInfoVo> {
        return this.getWidgetPackageListInfoWithHttpInfo(spaceId, authorization, acceptLanguage, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetPackageInfoVo>) => apiResponse.data));
    }

    /**
     * Get widget release history
     * @param packageId widget package id
     * @param page
     * @param authorization developer token
     * @param pageObjectParams page
     */
    public releaseListWidgetWithHttpInfo(packageId: number, page: Page, authorization: string, pageObjectParams?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetReleaseListVo>> {
        const requestContextPromise = this.requestFactory.releaseListWidget(packageId, page, authorization, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.releaseListWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get widget release history
     * @param packageId widget package id
     * @param page
     * @param authorization developer token
     * @param pageObjectParams page
     */
    public releaseListWidget(packageId: number, page: Page, authorization: string, pageObjectParams?: string, _options?: Configuration): Observable<ResponseDataListWidgetReleaseListVo> {
        return this.releaseListWidgetWithHttpInfo(packageId, page, authorization, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetReleaseListVo>) => apiResponse.data));
    }

    /**
     * widget-cli release widget
     * release widget v2
     * @param widgetPackageReleaseV2Ro
     * @param authorization developer token
     */
    public releaseWidgetV2WithHttpInfo(widgetPackageReleaseV2Ro: WidgetPackageReleaseV2Ro, authorization: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.releaseWidgetV2(widgetPackageReleaseV2Ro, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.releaseWidgetV2WithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli release widget
     * release widget v2
     * @param widgetPackageReleaseV2Ro
     * @param authorization developer token
     */
    public releaseWidgetV2(widgetPackageReleaseV2Ro: WidgetPackageReleaseV2Ro, authorization: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.releaseWidgetV2WithHttpInfo(widgetPackageReleaseV2Ro, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Rollback widget
     * @param widgetPackageRollbackRo
     * @param authorization developer token
     */
    public rollbackWidgetWithHttpInfo(widgetPackageRollbackRo: WidgetPackageRollbackRo, authorization: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.rollbackWidget(widgetPackageRollbackRo, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.rollbackWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Rollback widget
     * @param widgetPackageRollbackRo
     * @param authorization developer token
     */
    public rollbackWidget(widgetPackageRollbackRo: WidgetPackageRollbackRo, authorization: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.rollbackWidgetWithHttpInfo(widgetPackageRollbackRo, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * widget-cli submit widget
     * submit widget v2
     * @param widgetPackageSubmitV2Ro
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public submitWidgetV2WithHttpInfo(widgetPackageSubmitV2Ro: WidgetPackageSubmitV2Ro, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.submitWidgetV2(widgetPackageSubmitV2Ro, authorization, acceptLanguage, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.submitWidgetV2WithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli submit widget
     * submit widget v2
     * @param widgetPackageSubmitV2Ro
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public submitWidgetV2(widgetPackageSubmitV2Ro: WidgetPackageSubmitV2Ro, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.submitWidgetV2WithHttpInfo(widgetPackageSubmitV2Ro, authorization, acceptLanguage, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * widget-cli transfer widget owner
     * Transfer widget owner
     * @param widgetTransferOwnerRo
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public transferWidgetOwnerWithHttpInfo(widgetTransferOwnerRo: WidgetTransferOwnerRo, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.transferWidgetOwner(widgetTransferOwnerRo, authorization, acceptLanguage, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.transferWidgetOwnerWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli transfer widget owner
     * Transfer widget owner
     * @param widgetTransferOwnerRo
     * @param authorization developer token
     * @param acceptLanguage developer\&#39;s language
     */
    public transferWidgetOwner(widgetTransferOwnerRo: WidgetTransferOwnerRo, authorization: string, acceptLanguage?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.transferWidgetOwnerWithHttpInfo(widgetTransferOwnerRo, authorization, acceptLanguage, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Unpublish widget
     * @param widgetPackageUnpublishRo
     * @param authorization developer token
     */
    public unpublishWidgetWithHttpInfo(widgetPackageUnpublishRo: WidgetPackageUnpublishRo, authorization: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.unpublishWidget(widgetPackageUnpublishRo, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.unpublishWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Unpublish widget
     * @param widgetPackageUnpublishRo
     * @param authorization developer token
     */
    public unpublishWidget(widgetPackageUnpublishRo: WidgetPackageUnpublishRo, authorization: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.unpublishWidgetWithHttpInfo(widgetPackageUnpublishRo, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * widget-cli widget development authentication verification
     * Auth widget
     * @param widgetPackageAuthRo
     * @param authorization developer token
     */
    public widgetAuthWithHttpInfo(widgetPackageAuthRo: WidgetPackageAuthRo, authorization: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.widgetAuth(widgetPackageAuthRo, authorization, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.widgetAuthWithHttpInfo(rsp)));
            }));
    }

    /**
     * widget-cli widget development authentication verification
     * Auth widget
     * @param widgetPackageAuthRo
     * @param authorization developer token
     */
    public widgetAuth(widgetPackageAuthRo: WidgetPackageAuthRo, authorization: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.widgetAuthWithHttpInfo(widgetPackageAuthRo, authorization, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { WidgetSDKWidgetApiApiRequestFactory, WidgetSDKWidgetApiApiResponseProcessor} from "../apis/WidgetSDKWidgetApiApi";
export class ObservableWidgetSDKWidgetApiApi {
    private requestFactory: WidgetSDKWidgetApiApiRequestFactory;
    private responseProcessor: WidgetSDKWidgetApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WidgetSDKWidgetApiApiRequestFactory,
        responseProcessor?: WidgetSDKWidgetApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WidgetSDKWidgetApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WidgetSDKWidgetApiApiResponseProcessor();
    }

    /**
     * Scenario: 1、dashboard import widget2:the widget panel sends applets to the dashboard; 3:copy widget
     * Copy widget
     * @param widgetCopyRo
     */
    public copyWidgetWithHttpInfo(widgetCopyRo: WidgetCopyRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetPack>> {
        const requestContextPromise = this.requestFactory.copyWidget(widgetCopyRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.copyWidgetWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scenario: 1、dashboard import widget2:the widget panel sends applets to the dashboard; 3:copy widget
     * Copy widget
     * @param widgetCopyRo
     */
    public copyWidget(widgetCopyRo: WidgetCopyRo, _options?: Configuration): Observable<ResponseDataListWidgetPack> {
        return this.copyWidgetWithHttpInfo(widgetCopyRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetPack>) => apiResponse.data));
    }

    /**
     * Scenario:1、dashboard new applet 2、datasheet widget panel new widget
     * Create widget
     * @param widgetCreateRo
     */
    public createWidget1WithHttpInfo(widgetCreateRo: WidgetCreateRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWidgetPack>> {
        const requestContextPromise = this.requestFactory.createWidget1(widgetCreateRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createWidget1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Scenario:1、dashboard new applet 2、datasheet widget panel new widget
     * Create widget
     * @param widgetCreateRo
     */
    public createWidget1(widgetCreateRo: WidgetCreateRo, _options?: Configuration): Observable<ResponseDataWidgetPack> {
        return this.createWidget1WithHttpInfo(widgetCreateRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetPack>) => apiResponse.data));
    }

    /**
     * Get package teamplates
     */
    public findTemplatePackageListWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetTemplatePackageInfo>> {
        const requestContextPromise = this.requestFactory.findTemplatePackageList(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.findTemplatePackageListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get package teamplates
     */
    public findTemplatePackageList(_options?: Configuration): Observable<ResponseDataListWidgetTemplatePackageInfo> {
        return this.findTemplatePackageListWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetTemplatePackageInfo>) => apiResponse.data));
    }

    /**
     * get the widget information of the node
     * @param nodeId node id
     */
    public findWidgetInfoByNodeIdWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetInfo>> {
        const requestContextPromise = this.requestFactory.findWidgetInfoByNodeId(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.findWidgetInfoByNodeIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * get the widget information of the node
     * @param nodeId node id
     */
    public findWidgetInfoByNodeId(nodeId: string, _options?: Configuration): Observable<ResponseDataListWidgetInfo> {
        return this.findWidgetInfoByNodeIdWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetInfo>) => apiResponse.data));
    }

    /**
     * get the widgets under the entire space
     * Get the space widgets
     * @param spaceId space id
     * @param count load quantity
     */
    public findWidgetInfoBySpaceIdWithHttpInfo(spaceId: string, count?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetInfo>> {
        const requestContextPromise = this.requestFactory.findWidgetInfoBySpaceId(spaceId, count, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.findWidgetInfoBySpaceIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * get the widgets under the entire space
     * Get the space widgets
     * @param spaceId space id
     * @param count load quantity
     */
    public findWidgetInfoBySpaceId(spaceId: string, count?: number, _options?: Configuration): Observable<ResponseDataListWidgetInfo> {
        return this.findWidgetInfoBySpaceIdWithHttpInfo(spaceId, count, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetInfo>) => apiResponse.data));
    }

    /**
     * Node types are limited to dashboards and datasheet
     * Get the node widget package
     * @param nodeId node id
     * @param linkId association id：node share id、template id
     * @param xSpaceId space id
     */
    public findWidgetPackByNodeIdWithHttpInfo(nodeId: string, linkId?: string, xSpaceId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetPack>> {
        const requestContextPromise = this.requestFactory.findWidgetPackByNodeId(nodeId, linkId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.findWidgetPackByNodeIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * Node types are limited to dashboards and datasheet
     * Get the node widget package
     * @param nodeId node id
     * @param linkId association id：node share id、template id
     * @param xSpaceId space id
     */
    public findWidgetPackByNodeId(nodeId: string, linkId?: string, xSpaceId?: string, _options?: Configuration): Observable<ResponseDataListWidgetPack> {
        return this.findWidgetPackByNodeIdWithHttpInfo(nodeId, linkId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetPack>) => apiResponse.data));
    }

    /**
     * get widget info by widget id
     * Get widget info
     * @param widgetIds widget ids
     * @param linkId Association ID: node sharing ID and template ID
     */
    public findWidgetPackByWidgetIdsWithHttpInfo(widgetIds: string, linkId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetPack>> {
        const requestContextPromise = this.requestFactory.findWidgetPackByWidgetIds(widgetIds, linkId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.findWidgetPackByWidgetIdsWithHttpInfo(rsp)));
            }));
    }

    /**
     * get widget info by widget id
     * Get widget info
     * @param widgetIds widget ids
     * @param linkId Association ID: node sharing ID and template ID
     */
    public findWidgetPackByWidgetIds(widgetIds: string, linkId?: string, _options?: Configuration): Observable<ResponseDataListWidgetPack> {
        return this.findWidgetPackByWidgetIdsWithHttpInfo(widgetIds, linkId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetPack>) => apiResponse.data));
    }

    /**
     * Get widget store
     * @param widgetStoreListRo
     * @param xSpaceId space id
     */
    public widgetStoreListWithHttpInfo(widgetStoreListRo: WidgetStoreListRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetStoreListInfo>> {
        const requestContextPromise = this.requestFactory.widgetStoreList(widgetStoreListRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.widgetStoreListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get widget store
     * @param widgetStoreListRo
     * @param xSpaceId space id
     */
    public widgetStoreList(widgetStoreListRo: WidgetStoreListRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataListWidgetStoreListInfo> {
        return this.widgetStoreListWithHttpInfo(widgetStoreListRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetStoreListInfo>) => apiResponse.data));
    }

}

import { WidgetSDKWidgetAuditApiApiRequestFactory, WidgetSDKWidgetAuditApiApiResponseProcessor} from "../apis/WidgetSDKWidgetAuditApiApi";
export class ObservableWidgetSDKWidgetAuditApiApi {
    private requestFactory: WidgetSDKWidgetAuditApiApiRequestFactory;
    private responseProcessor: WidgetSDKWidgetAuditApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WidgetSDKWidgetAuditApiApiRequestFactory,
        responseProcessor?: WidgetSDKWidgetAuditApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WidgetSDKWidgetAuditApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WidgetSDKWidgetAuditApiApiResponseProcessor();
    }

    /**
     * Audit global widget submit data
     * @param widgetAuditSubmitDataRo
     */
    public auditSubmitDataWithHttpInfo(widgetAuditSubmitDataRo: WidgetAuditSubmitDataRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.auditSubmitData(widgetAuditSubmitDataRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.auditSubmitDataWithHttpInfo(rsp)));
            }));
    }

    /**
     * Audit global widget submit data
     * @param widgetAuditSubmitDataRo
     */
    public auditSubmitData(widgetAuditSubmitDataRo: WidgetAuditSubmitDataRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.auditSubmitDataWithHttpInfo(widgetAuditSubmitDataRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Issue global id
     * @param widgetAuditGlobalIdRo
     */
    public issuedGlobalIdWithHttpInfo(widgetAuditGlobalIdRo: WidgetAuditGlobalIdRo, _options?: Configuration): Observable<HttpInfo<ResponseDataWidgetIssuedGlobalIdVo>> {
        const requestContextPromise = this.requestFactory.issuedGlobalId(widgetAuditGlobalIdRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.issuedGlobalIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * Issue global id
     * @param widgetAuditGlobalIdRo
     */
    public issuedGlobalId(widgetAuditGlobalIdRo: WidgetAuditGlobalIdRo, _options?: Configuration): Observable<ResponseDataWidgetIssuedGlobalIdVo> {
        return this.issuedGlobalIdWithHttpInfo(widgetAuditGlobalIdRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetIssuedGlobalIdVo>) => apiResponse.data));
    }

}

import { WidgetUploadAPIApiRequestFactory, WidgetUploadAPIApiResponseProcessor} from "../apis/WidgetUploadAPIApi";
export class ObservableWidgetUploadAPIApi {
    private requestFactory: WidgetUploadAPIApiRequestFactory;
    private responseProcessor: WidgetUploadAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WidgetUploadAPIApiRequestFactory,
        responseProcessor?: WidgetUploadAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WidgetUploadAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WidgetUploadAPIApiResponseProcessor();
    }

    /**
     * Get widget file upload pre signed url
     * @param widgetAssetUploadCertificateRO
     * @param packageId
     */
    public generateWidgetPreSignedUrlWithHttpInfo(widgetAssetUploadCertificateRO: WidgetAssetUploadCertificateRO, packageId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListWidgetUploadTokenVo>> {
        const requestContextPromise = this.requestFactory.generateWidgetPreSignedUrl(widgetAssetUploadCertificateRO, packageId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.generateWidgetPreSignedUrlWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get widget file upload pre signed url
     * @param widgetAssetUploadCertificateRO
     * @param packageId
     */
    public generateWidgetPreSignedUrl(widgetAssetUploadCertificateRO: WidgetAssetUploadCertificateRO, packageId: string, _options?: Configuration): Observable<ResponseDataListWidgetUploadTokenVo> {
        return this.generateWidgetPreSignedUrlWithHttpInfo(widgetAssetUploadCertificateRO, packageId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListWidgetUploadTokenVo>) => apiResponse.data));
    }

    /**
     * get widget upload meta
     * get widget upload meta
     */
    public getWidgetUploadMetaWithHttpInfo(_options?: Configuration): Observable<HttpInfo<ResponseDataWidgetUploadMetaVo>> {
        const requestContextPromise = this.requestFactory.getWidgetUploadMeta(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWidgetUploadMetaWithHttpInfo(rsp)));
            }));
    }

    /**
     * get widget upload meta
     * get widget upload meta
     */
    public getWidgetUploadMeta(_options?: Configuration): Observable<ResponseDataWidgetUploadMetaVo> {
        return this.getWidgetUploadMetaWithHttpInfo(_options).pipe(map((apiResponse: HttpInfo<ResponseDataWidgetUploadMetaVo>) => apiResponse.data));
    }

}

import { WorkbenchFieldRoleAPIApiRequestFactory, WorkbenchFieldRoleAPIApiResponseProcessor} from "../apis/WorkbenchFieldRoleAPIApi";
export class ObservableWorkbenchFieldRoleAPIApi {
    private requestFactory: WorkbenchFieldRoleAPIApiRequestFactory;
    private responseProcessor: WorkbenchFieldRoleAPIApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchFieldRoleAPIApiRequestFactory,
        responseProcessor?: WorkbenchFieldRoleAPIApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchFieldRoleAPIApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchFieldRoleAPIApiResponseProcessor();
    }

    /**
     * Add field role
     * @param fieldRoleCreateRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public addRole1WithHttpInfo(fieldRoleCreateRo: FieldRoleCreateRo, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.addRole1(fieldRoleCreateRo, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.addRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Add field role
     * @param fieldRoleCreateRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public addRole1(fieldRoleCreateRo: FieldRoleCreateRo, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.addRole1WithHttpInfo(fieldRoleCreateRo, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Batch delete role
     * @param batchFieldRoleDeleteRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public batchDeleteRole1WithHttpInfo(batchFieldRoleDeleteRo: BatchFieldRoleDeleteRo, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.batchDeleteRole1(batchFieldRoleDeleteRo, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.batchDeleteRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch delete role
     * @param batchFieldRoleDeleteRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public batchDeleteRole1(batchFieldRoleDeleteRo: BatchFieldRoleDeleteRo, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.batchDeleteRole1WithHttpInfo(batchFieldRoleDeleteRo, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Batch edit field role
     * @param batchFieldRoleEditRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public batchEditRole1WithHttpInfo(batchFieldRoleEditRo: BatchFieldRoleEditRo, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.batchEditRole1(batchFieldRoleEditRo, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.batchEditRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch edit field role
     * @param batchFieldRoleEditRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public batchEditRole1(batchFieldRoleEditRo: BatchFieldRoleEditRo, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.batchEditRole1WithHttpInfo(batchFieldRoleEditRo, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete field role
     * @param fieldRoleDeleteRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public deleteRole3WithHttpInfo(fieldRoleDeleteRo: FieldRoleDeleteRo, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteRole3(fieldRoleDeleteRo, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteRole3WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete field role
     * @param fieldRoleDeleteRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public deleteRole3(fieldRoleDeleteRo: FieldRoleDeleteRo, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteRole3WithHttpInfo(fieldRoleDeleteRo, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Disable field role
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public disableRoleWithHttpInfo(dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.disableRole(dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.disableRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Disable field role
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public disableRole(dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.disableRoleWithHttpInfo(dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Edit field role
     * @param fieldRoleEditRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public editRole2WithHttpInfo(fieldRoleEditRo: FieldRoleEditRo, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.editRole2(fieldRoleEditRo, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.editRole2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Edit field role
     * @param fieldRoleEditRo
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public editRole2(fieldRoleEditRo: FieldRoleEditRo, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.editRole2WithHttpInfo(fieldRoleEditRo, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Enable field role
     * @param dstId datasheet id
     * @param fieldId field id
     * @param roleControlOpenRo
     */
    public enableRoleWithHttpInfo(dstId: string, fieldId: string, roleControlOpenRo?: RoleControlOpenRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.enableRole(dstId, fieldId, roleControlOpenRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.enableRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Enable field role
     * @param dstId datasheet id
     * @param fieldId field id
     * @param roleControlOpenRo
     */
    public enableRole(dstId: string, fieldId: string, roleControlOpenRo?: RoleControlOpenRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.enableRoleWithHttpInfo(dstId, fieldId, roleControlOpenRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page Query the Field\' Collaborator
     * @param dstId datasheet id
     * @param fieldId field id
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getCollaboratorPage1WithHttpInfo(dstId: string, fieldId: string, page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoFieldRoleMemberVo>> {
        const requestContextPromise = this.requestFactory.getCollaboratorPage1(dstId, fieldId, page, xSpaceId, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCollaboratorPage1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page Query the Field\' Collaborator
     * @param dstId datasheet id
     * @param fieldId field id
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getCollaboratorPage1(dstId: string, fieldId: string, page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoFieldRoleMemberVo> {
        return this.getCollaboratorPage1WithHttpInfo(dstId, fieldId, page, xSpaceId, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoFieldRoleMemberVo>) => apiResponse.data));
    }

    /**
     * Get multi datasheet field permission
     * @param dstIds datasheet id
     * @param shareId share id
     */
    public getMultiDatasheetFieldPermissionWithHttpInfo(dstIds: string, shareId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListFieldPermissionView>> {
        const requestContextPromise = this.requestFactory.getMultiDatasheetFieldPermission(dstIds, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getMultiDatasheetFieldPermissionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get multi datasheet field permission
     * @param dstIds datasheet id
     * @param shareId share id
     */
    public getMultiDatasheetFieldPermission(dstIds: string, shareId?: string, _options?: Configuration): Observable<ResponseDataListFieldPermissionView> {
        return this.getMultiDatasheetFieldPermissionWithHttpInfo(dstIds, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListFieldPermissionView>) => apiResponse.data));
    }

    /**
     * Gets the field role infos in datasheet.
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public listRole2WithHttpInfo(dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataFieldCollaboratorVO>> {
        const requestContextPromise = this.requestFactory.listRole2(dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.listRole2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets the field role infos in datasheet.
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public listRole2(dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataFieldCollaboratorVO> {
        return this.listRole2WithHttpInfo(dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataFieldCollaboratorVO>) => apiResponse.data));
    }

    /**
     * Update field role setting
     * @param fieldControlProp
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public updateRoleSettingWithHttpInfo(fieldControlProp: FieldControlProp, dstId: string, fieldId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateRoleSetting(fieldControlProp, dstId, fieldId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateRoleSettingWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update field role setting
     * @param fieldControlProp
     * @param dstId datasheet id
     * @param fieldId field id
     */
    public updateRoleSetting(fieldControlProp: FieldControlProp, dstId: string, fieldId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateRoleSettingWithHttpInfo(fieldControlProp, dstId, fieldId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { WorkbenchNodeApiApiRequestFactory, WorkbenchNodeApiApiResponseProcessor} from "../apis/WorkbenchNodeApiApi";
export class ObservableWorkbenchNodeApiApi {
    private requestFactory: WorkbenchNodeApiApiRequestFactory;
    private responseProcessor: WorkbenchNodeApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchNodeApiApiRequestFactory,
        responseProcessor?: WorkbenchNodeApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchNodeApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchNodeApiApiResponseProcessor();
    }

    /**
     * node id and view id are not required（do not pass means all closed）
     * Record active node
     * @param activeSheetsOpRo
     * @param xSpaceId space id
     */
    public activeSheetsWithHttpInfo(activeSheetsOpRo: ActiveSheetsOpRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.activeSheets(activeSheetsOpRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.activeSheetsWithHttpInfo(rsp)));
            }));
    }

    /**
     * node id and view id are not required（do not pass means all closed）
     * Record active node
     * @param activeSheetsOpRo
     * @param xSpaceId space id
     */
    public activeSheets(activeSheetsOpRo: ActiveSheetsOpRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.activeSheetsWithHttpInfo(activeSheetsOpRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * The front node is saved in the first place of the parent node when it is not under the parent node. Save in the first place of the first level directory when it is not transmitted.
     * Analyze Bundle
     * @param nodeBundleOpRo
     */
    public analyzeBundleWithHttpInfo(nodeBundleOpRo?: NodeBundleOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.analyzeBundle(nodeBundleOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.analyzeBundleWithHttpInfo(rsp)));
            }));
    }

    /**
     * The front node is saved in the first place of the parent node when it is not under the parent node. Save in the first place of the first level directory when it is not transmitted.
     * Analyze Bundle
     * @param nodeBundleOpRo
     */
    public analyzeBundle(nodeBundleOpRo?: NodeBundleOpRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.analyzeBundleWithHttpInfo(nodeBundleOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * permission of the associated node is not required. Scenario: Check whether the view associated mirror before deleting the table.
     * check for associated nodes
     * @param nodeId node id
     * @param viewId view id（do not specify full return）
     * @param type node type（do not specify full return，form:3/mirror:5）
     */
    public checkRelNodeWithHttpInfo(nodeId: string, viewId?: string, type?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfo>> {
        const requestContextPromise = this.requestFactory.checkRelNode(nodeId, viewId, type, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.checkRelNodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * permission of the associated node is not required. Scenario: Check whether the view associated mirror before deleting the table.
     * check for associated nodes
     * @param nodeId node id
     * @param viewId view id（do not specify full return）
     * @param type node type（do not specify full return，form:3/mirror:5）
     */
    public checkRelNode(nodeId: string, viewId?: string, type?: number, _options?: Configuration): Observable<ResponseDataListNodeInfo> {
        return this.checkRelNodeWithHttpInfo(nodeId, viewId, type, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfo>) => apiResponse.data));
    }

    /**
     * node id is required, whether to copy data is not required.
     * Copy node
     * @param nodeCopyOpRo
     * @param xSocketId user socket id
     */
    public copyWithHttpInfo(nodeCopyOpRo: NodeCopyOpRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.copy(nodeCopyOpRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.copyWithHttpInfo(rsp)));
            }));
    }

    /**
     * node id is required, whether to copy data is not required.
     * Copy node
     * @param nodeCopyOpRo
     * @param xSocketId user socket id
     */
    public copy(nodeCopyOpRo: NodeCopyOpRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.copyWithHttpInfo(nodeCopyOpRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * create a new node under the node<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Create child node
     * @param nodeOpRo
     * @param xSocketId user socket id
     */
    public create6WithHttpInfo(nodeOpRo: NodeOpRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.create6(nodeOpRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.create6WithHttpInfo(rsp)));
            }));
    }

    /**
     * create a new node under the node<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Create child node
     * @param nodeOpRo
     * @param xSocketId user socket id
     */
    public create6(nodeOpRo: NodeOpRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.create6WithHttpInfo(nodeOpRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * You can pass in an ID array and delete multiple nodes.
     * Delete node
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public delete8WithHttpInfo(nodeId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete8(nodeId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete8WithHttpInfo(rsp)));
            }));
    }

    /**
     * You can pass in an ID array and delete multiple nodes.
     * Delete node
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public delete8(nodeId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete8WithHttpInfo(nodeId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * You can pass in an ID array and delete multiple nodes.
     * Delete node
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public delete9WithHttpInfo(nodeId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete9(nodeId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete9WithHttpInfo(rsp)));
            }));
    }

    /**
     * You can pass in an ID array and delete multiple nodes.
     * Delete node
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public delete9(nodeId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete9WithHttpInfo(nodeId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Export Bundle
     * @param nodeId node id
     * @param saveData whether to retain data
     * @param password encrypted password
     */
    public exportBundleWithHttpInfo(nodeId: string, saveData?: boolean, password?: string, _options?: Configuration): Observable<HttpInfo<void>> {
        const requestContextPromise = this.requestFactory.exportBundle(nodeId, saveData, password, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.exportBundleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Export Bundle
     * @param nodeId node id
     * @param saveData whether to retain data
     * @param password encrypted password
     */
    public exportBundle(nodeId: string, saveData?: boolean, password?: string, _options?: Configuration): Observable<void> {
        return this.exportBundleWithHttpInfo(nodeId, saveData, password, _options).pipe(map((apiResponse: HttpInfo<void>) => apiResponse.data));
    }

    /**
     * obtain information about the node <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Query nodes
     * @param nodeIds node ids
     */
    public getByNodeIdWithHttpInfo(nodeIds: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.getByNodeId(nodeIds, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getByNodeIdWithHttpInfo(rsp)));
            }));
    }

    /**
     * obtain information about the node <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Query nodes
     * @param nodeIds node ids
     */
    public getByNodeId(nodeIds: string, _options?: Configuration): Observable<ResponseDataListNodeInfoVo> {
        return this.getByNodeIdWithHttpInfo(nodeIds, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfoVo>) => apiResponse.data));
    }

    /**
     * Obtain the list of child nodes of the specified node. The nodes are classified into folders or datasheet by type <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Get child nodes
     * @param nodeId node id
     * @param nodeType node type 1:folder,2:datasheet
     */
    public getNodeChildrenListWithHttpInfo(nodeId: string, nodeType?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.getNodeChildrenList(nodeId, nodeType, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getNodeChildrenListWithHttpInfo(rsp)));
            }));
    }

    /**
     * Obtain the list of child nodes of the specified node. The nodes are classified into folders or datasheet by type <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Get child nodes
     * @param nodeId node id
     * @param nodeType node type 1:folder,2:datasheet
     */
    public getNodeChildrenList(nodeId: string, nodeType?: number, _options?: Configuration): Observable<ResponseDataListNodeInfoVo> {
        return this.getNodeChildrenListWithHttpInfo(nodeId, nodeType, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfoVo>) => apiResponse.data));
    }

    /**
     * This interface requires readable or above permissions of the associated node. Scenario: Open the display columns of form and mirror in the datasheet.
     * Get associated node
     * @param nodeId node id
     * @param viewId view id（do not specify full return）
     * @param type node type（do not specify full return，form:3/mirror:5）
     */
    public getNodeRelWithHttpInfo(nodeId: string, viewId?: string, type?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfo>> {
        const requestContextPromise = this.requestFactory.getNodeRel(nodeId, viewId, type, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getNodeRelWithHttpInfo(rsp)));
            }));
    }

    /**
     * This interface requires readable or above permissions of the associated node. Scenario: Open the display columns of form and mirror in the datasheet.
     * Get associated node
     * @param nodeId node id
     * @param viewId view id（do not specify full return）
     * @param type node type（do not specify full return，form:3/mirror:5）
     */
    public getNodeRel(nodeId: string, viewId?: string, type?: number, _options?: Configuration): Observable<ResponseDataListNodeInfo> {
        return this.getNodeRelWithHttpInfo(nodeId, viewId, type, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfo>) => apiResponse.data));
    }

    /**
     * Gets a list of all parent nodes of the specified node <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Get parent nodes
     * @param nodeId node id
     */
    public getParentNodesWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodePathVo>> {
        const requestContextPromise = this.requestFactory.getParentNodes(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getParentNodesWithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets a list of all parent nodes of the specified node <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Get parent nodes
     * @param nodeId node id
     */
    public getParentNodes(nodeId: string, _options?: Configuration): Observable<ResponseDataListNodePathVo> {
        return this.getParentNodesWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodePathVo>) => apiResponse.data));
    }

    /**
     * Query the node tree of workbench, restricted to two levels.<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Query tree node
     * @param xSpaceId space id
     * @param depth tree depth, we can specify the query depth, maximum 2 layers depth.
     */
    public getTreeWithHttpInfo(xSpaceId: string, depth?: number, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoTreeVo>> {
        const requestContextPromise = this.requestFactory.getTree(xSpaceId, depth, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTreeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Query the node tree of workbench, restricted to two levels.<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Query tree node
     * @param xSpaceId space id
     * @param depth tree depth, we can specify the query depth, maximum 2 layers depth.
     */
    public getTree(xSpaceId: string, depth?: number, _options?: Configuration): Observable<ResponseDataNodeInfoTreeVo> {
        return this.getTreeWithHttpInfo(xSpaceId, depth, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoTreeVo>) => apiResponse.data));
    }

    /**
     * all parameters must be
     * Import excel
     * @param importExcelOpRo
     */
    public importExcelWithHttpInfo(importExcelOpRo?: ImportExcelOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.importExcel(importExcelOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.importExcelWithHttpInfo(rsp)));
            }));
    }

    /**
     * all parameters must be
     * Import excel
     * @param importExcelOpRo
     */
    public importExcel(importExcelOpRo?: ImportExcelOpRo, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.importExcelWithHttpInfo(importExcelOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * all parameters must be
     * Import excel
     * @param importExcelOpRo
     */
    public importExcel1WithHttpInfo(importExcelOpRo?: ImportExcelOpRo, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.importExcel1(importExcelOpRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.importExcel1WithHttpInfo(rsp)));
            }));
    }

    /**
     * all parameters must be
     * Import excel
     * @param importExcelOpRo
     */
    public importExcel1(importExcelOpRo?: ImportExcelOpRo, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.importExcel1WithHttpInfo(importExcelOpRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * scenario: query an existing dashboard
     * Get nodes of the specified type
     * @param type node type
     * @param xSpaceId space id
     * @param role role（manageable by default）
     */
    public list6WithHttpInfo(type: number, xSpaceId: string, role?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfo>> {
        const requestContextPromise = this.requestFactory.list6(type, xSpaceId, role, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list6WithHttpInfo(rsp)));
            }));
    }

    /**
     * scenario: query an existing dashboard
     * Get nodes of the specified type
     * @param type node type
     * @param xSpaceId space id
     * @param role role（manageable by default）
     */
    public list6(type: number, xSpaceId: string, role?: string, _options?: Configuration): Observable<ResponseDataListNodeInfo> {
        return this.list6WithHttpInfo(type, xSpaceId, role, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfo>) => apiResponse.data));
    }

    /**
     * Node ID and parent node ID are required, and pre Node Id is not required.
     * Move node
     * @param nodeMoveOpRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public moveWithHttpInfo(nodeMoveOpRo: NodeMoveOpRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.move(nodeMoveOpRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.moveWithHttpInfo(rsp)));
            }));
    }

    /**
     * Node ID and parent node ID are required, and pre Node Id is not required.
     * Move node
     * @param nodeMoveOpRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public move(nodeMoveOpRo: NodeMoveOpRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataListNodeInfoVo> {
        return this.moveWithHttpInfo(nodeMoveOpRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeInfoVo>) => apiResponse.data));
    }

    /**
     * node in must <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Position node
     * @param nodeId node id
     */
    public positionWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoTreeVo>> {
        const requestContextPromise = this.requestFactory.position(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.positionWithHttpInfo(rsp)));
            }));
    }

    /**
     * node in must <br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Position node
     * @param nodeId node id
     */
    public position(nodeId: string, _options?: Configuration): Observable<ResponseDataNodeInfoTreeVo> {
        return this.positionWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoTreeVo>) => apiResponse.data));
    }

    /**
     * Gets no permission member before remind
     * @param remindUnitsNoPermissionRo
     */
    public postRemindUnitsNoPermissionWithHttpInfo(remindUnitsNoPermissionRo: RemindUnitsNoPermissionRo, _options?: Configuration): Observable<HttpInfo<ResponseDataListMemberBriefInfoVo>> {
        const requestContextPromise = this.requestFactory.postRemindUnitsNoPermission(remindUnitsNoPermissionRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.postRemindUnitsNoPermissionWithHttpInfo(rsp)));
            }));
    }

    /**
     * Gets no permission member before remind
     * @param remindUnitsNoPermissionRo
     */
    public postRemindUnitsNoPermission(remindUnitsNoPermissionRo: RemindUnitsNoPermissionRo, _options?: Configuration): Observable<ResponseDataListMemberBriefInfoVo> {
        return this.postRemindUnitsNoPermissionWithHttpInfo(remindUnitsNoPermissionRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListMemberBriefInfoVo>) => apiResponse.data));
    }

    /**
     * member recent open node list
     * member recent open node list
     * @param xSpaceId space id
     */
    public recentListWithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeSearchResult>> {
        const requestContextPromise = this.requestFactory.recentList(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.recentListWithHttpInfo(rsp)));
            }));
    }

    /**
     * member recent open node list
     * member recent open node list
     * @param xSpaceId space id
     */
    public recentList(xSpaceId: string, _options?: Configuration): Observable<ResponseDataListNodeSearchResult> {
        return this.recentListWithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeSearchResult>) => apiResponse.data));
    }

    /**
     * Remind notification
     * @param remindMemberRo
     */
    public remindWithHttpInfo(remindMemberRo: RemindMemberRo, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.remind(remindMemberRo, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.remindWithHttpInfo(rsp)));
            }));
    }

    /**
     * Remind notification
     * @param remindMemberRo
     */
    public remind(remindMemberRo: RemindMemberRo, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.remindWithHttpInfo(remindMemberRo, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Enter the search term to search for the node of the working directory.<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Fuzzy search node
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className highlight style
     */
    public searchNodeWithHttpInfo(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListNodeSearchResult>> {
        const requestContextPromise = this.requestFactory.searchNode(keyword, xSpaceId, className, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.searchNodeWithHttpInfo(rsp)));
            }));
    }

    /**
     * Enter the search term to search for the node of the working directory.<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Fuzzy search node
     * @param keyword keyword
     * @param xSpaceId space id
     * @param className highlight style
     */
    public searchNode(keyword: string, xSpaceId: string, className?: string, _options?: Configuration): Observable<ResponseDataListNodeSearchResult> {
        return this.searchNodeWithHttpInfo(keyword, xSpaceId, className, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListNodeSearchResult>) => apiResponse.data));
    }

    /**
     * Nodes that are not in the center of the template, make spatial judgments.
     * Node info window
     * @param nodeId
     */
    public showNodeInfoWindowWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoWindowVo>> {
        const requestContextPromise = this.requestFactory.showNodeInfoWindow(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showNodeInfoWindowWithHttpInfo(rsp)));
            }));
    }

    /**
     * Nodes that are not in the center of the template, make spatial judgments.
     * Node info window
     * @param nodeId
     */
    public showNodeInfoWindow(nodeId: string, _options?: Configuration): Observable<ResponseDataNodeInfoWindowVo> {
        return this.showNodeInfoWindowWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoWindowVo>) => apiResponse.data));
    }

    /**
     * Nodes that are not in the center of the template, make cross-space judgments.
     * Folder preview
     * @param nodeId node id
     * @param shareId share id
     */
    public showcaseWithHttpInfo(nodeId: string, shareId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataShowcaseVo>> {
        const requestContextPromise = this.requestFactory.showcase(nodeId, shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.showcaseWithHttpInfo(rsp)));
            }));
    }

    /**
     * Nodes that are not in the center of the template, make cross-space judgments.
     * Folder preview
     * @param nodeId node id
     * @param shareId share id
     */
    public showcase(nodeId: string, shareId?: string, _options?: Configuration): Observable<ResponseDataShowcaseVo> {
        return this.showcaseWithHttpInfo(nodeId, shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataShowcaseVo>) => apiResponse.data));
    }

    /**
     * node id must. name, icon is not required<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Edit node
     * @param nodeUpdateOpRo
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public update5WithHttpInfo(nodeUpdateOpRo: NodeUpdateOpRo, nodeId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.update5(nodeUpdateOpRo, nodeId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.update5WithHttpInfo(rsp)));
            }));
    }

    /**
     * node id must. name, icon is not required<br/>Role Type：<br/>1.owner can add, edit, move, sort, delete, copy folders in the specified working directory。<br/>2.manager can add, edit, move, sort, delete, and copy folders in the specified working directory.<br/>3.editor can only edit records and views of the data table, but not edit fields<br/>4.readonly can only view the number table, you cannot make any edits and modifications, you can only assign read-only permissions to other members。<br/>
     * Edit node
     * @param nodeUpdateOpRo
     * @param nodeId node id
     * @param xSocketId user socket id
     */
    public update5(nodeUpdateOpRo: NodeUpdateOpRo, nodeId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.update5WithHttpInfo(nodeUpdateOpRo, nodeId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

    /**
     * Update node description
     * @param nodeDescOpRo
     * @param xSocketId user socket id
     */
    public updateDescWithHttpInfo(nodeDescOpRo: NodeDescOpRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateDesc(nodeDescOpRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateDescWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update node description
     * @param nodeDescOpRo
     * @param xSocketId user socket id
     */
    public updateDesc(nodeDescOpRo: NodeDescOpRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateDescWithHttpInfo(nodeDescOpRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { WorkbenchNodeFavoriteApiApiRequestFactory, WorkbenchNodeFavoriteApiApiResponseProcessor} from "../apis/WorkbenchNodeFavoriteApiApi";
export class ObservableWorkbenchNodeFavoriteApiApi {
    private requestFactory: WorkbenchNodeFavoriteApiApiRequestFactory;
    private responseProcessor: WorkbenchNodeFavoriteApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchNodeFavoriteApiApiRequestFactory,
        responseProcessor?: WorkbenchNodeFavoriteApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchNodeFavoriteApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchNodeFavoriteApiApiResponseProcessor();
    }

    /**
     * Get favorite nodes
     * @param xSpaceId space id
     */
    public list7WithHttpInfo(xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListFavoriteNodeInfo>> {
        const requestContextPromise = this.requestFactory.list7(xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list7WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get favorite nodes
     * @param xSpaceId space id
     */
    public list7(xSpaceId: string, _options?: Configuration): Observable<ResponseDataListFavoriteNodeInfo> {
        return this.list7WithHttpInfo(xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListFavoriteNodeInfo>) => apiResponse.data));
    }

    /**
     * Move favorite node
     * @param markNodeMoveRo
     * @param xSpaceId space id
     */
    public move1WithHttpInfo(markNodeMoveRo: MarkNodeMoveRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.move1(markNodeMoveRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.move1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Move favorite node
     * @param markNodeMoveRo
     * @param xSpaceId space id
     */
    public move1(markNodeMoveRo: MarkNodeMoveRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.move1WithHttpInfo(markNodeMoveRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Change favorite status
     * @param nodeId node id
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public updateStatusWithHttpInfo(nodeId: string, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.updateStatus(nodeId, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateStatusWithHttpInfo(rsp)));
            }));
    }

    /**
     * Change favorite status
     * @param nodeId node id
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public updateStatus(nodeId: string, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.updateStatusWithHttpInfo(nodeId, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

}

import { WorkbenchNodeRoleApiApiRequestFactory, WorkbenchNodeRoleApiApiResponseProcessor} from "../apis/WorkbenchNodeRoleApiApi";
export class ObservableWorkbenchNodeRoleApiApi {
    private requestFactory: WorkbenchNodeRoleApiApiRequestFactory;
    private responseProcessor: WorkbenchNodeRoleApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchNodeRoleApiApiRequestFactory,
        responseProcessor?: WorkbenchNodeRoleApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchNodeRoleApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchNodeRoleApiApiResponseProcessor();
    }

    /**
     * Batch delete node role
     * @param batchDeleteNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public batchDeleteRoleWithHttpInfo(batchDeleteNodeRoleRo: BatchDeleteNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.batchDeleteRole(batchDeleteNodeRoleRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.batchDeleteRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch delete node role
     * @param batchDeleteNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public batchDeleteRole(batchDeleteNodeRoleRo: BatchDeleteNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.batchDeleteRoleWithHttpInfo(batchDeleteNodeRoleRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Batch modify the role of the organizational unit of the node
     * Batch edit role
     * @param batchModifyNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public batchEditRoleWithHttpInfo(batchModifyNodeRoleRo: BatchModifyNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.batchEditRole(batchModifyNodeRoleRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.batchEditRoleWithHttpInfo(rsp)));
            }));
    }

    /**
     * Batch modify the role of the organizational unit of the node
     * Batch edit role
     * @param batchModifyNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public batchEditRole(batchModifyNodeRoleRo: BatchModifyNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.batchEditRoleWithHttpInfo(batchModifyNodeRoleRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Add the organizational unit of the node specified role
     * Create node role
     * @param addNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public createRole1WithHttpInfo(addNodeRoleRo: AddNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.createRole1(addNodeRoleRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Add the organizational unit of the node specified role
     * Create node role
     * @param addNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public createRole1(addNodeRoleRo: AddNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.createRole1WithHttpInfo(addNodeRoleRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete role
     * @param deleteNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public deleteRole2WithHttpInfo(deleteNodeRoleRo: DeleteNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.deleteRole2(deleteNodeRoleRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.deleteRole2WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete role
     * @param deleteNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public deleteRole2(deleteNodeRoleRo: DeleteNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.deleteRole2WithHttpInfo(deleteNodeRoleRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Disable role extend
     * @param nodeId node id
     * @param xSpaceId space id
     * @param roleControlOpenRo
     * @param xSocketId user socket id
     */
    public disableRoleExtendWithHttpInfo(nodeId: string, xSpaceId: string, roleControlOpenRo?: RoleControlOpenRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.disableRoleExtend(nodeId, xSpaceId, roleControlOpenRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.disableRoleExtendWithHttpInfo(rsp)));
            }));
    }

    /**
     * Disable role extend
     * @param nodeId node id
     * @param xSpaceId space id
     * @param roleControlOpenRo
     * @param xSocketId user socket id
     */
    public disableRoleExtend(nodeId: string, xSpaceId: string, roleControlOpenRo?: RoleControlOpenRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.disableRoleExtendWithHttpInfo(nodeId, xSpaceId, roleControlOpenRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Modify the role of the organizational unit of the node
     * Edit node role
     * @param modifyNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public editRole1WithHttpInfo(modifyNodeRoleRo: ModifyNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.editRole1(modifyNodeRoleRo, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.editRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Modify the role of the organizational unit of the node
     * Edit node role
     * @param modifyNodeRoleRo
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public editRole1(modifyNodeRoleRo: ModifyNodeRoleRo, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.editRole1WithHttpInfo(modifyNodeRoleRo, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Enable role extend
     * @param nodeId node id
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public enableRoleExtendWithHttpInfo(nodeId: string, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.enableRoleExtend(nodeId, xSpaceId, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.enableRoleExtendWithHttpInfo(rsp)));
            }));
    }

    /**
     * Enable role extend
     * @param nodeId node id
     * @param xSpaceId space id
     * @param xSocketId user socket id
     */
    public enableRoleExtend(nodeId: string, xSpaceId: string, xSocketId?: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.enableRoleExtendWithHttpInfo(nodeId, xSpaceId, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Scene: Collaborator Card Information
     * Get Collaborator Info
     * @param uuid
     * @param nodeId
     * @param xSpaceId space id
     */
    public getCollaboratorInfoWithHttpInfo(uuid: string, nodeId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeCollaboratorVO>> {
        const requestContextPromise = this.requestFactory.getCollaboratorInfo(uuid, nodeId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCollaboratorInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Scene: Collaborator Card Information
     * Get Collaborator Info
     * @param uuid
     * @param nodeId
     * @param xSpaceId space id
     */
    public getCollaboratorInfo(uuid: string, nodeId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataNodeCollaboratorVO> {
        return this.getCollaboratorInfoWithHttpInfo(uuid, nodeId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeCollaboratorVO>) => apiResponse.data));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page Query the Node\' Collaborator
     * @param nodeId node id
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getCollaboratorPageWithHttpInfo(nodeId: string, page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<HttpInfo<ResponseDataPageInfoNodeRoleMemberVo>> {
        const requestContextPromise = this.requestFactory.getCollaboratorPage(nodeId, page, xSpaceId, pageObjectParams, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCollaboratorPageWithHttpInfo(rsp)));
            }));
    }

    /**
     * Description of Paging: <br/> pageNo: number of paging <br/>pageSize: size of paging。<br/>order: order in current page。<br/>sort: sorting in current page。<br/>simple usage example：{\"pageNo\":1,\"pageSize\":20}<br/>complex usage example：{\"pageNo\":1,\"pageSize\":20,\"order\":\"createTime,updateTime\",\"sort\":\"asc,desc\"}
     * Page Query the Node\' Collaborator
     * @param nodeId node id
     * @param page
     * @param xSpaceId space id
     * @param pageObjectParams page\&#39;s parameter
     */
    public getCollaboratorPage(nodeId: string, page: Page, xSpaceId: string, pageObjectParams: string, _options?: Configuration): Observable<ResponseDataPageInfoNodeRoleMemberVo> {
        return this.getCollaboratorPageWithHttpInfo(nodeId, page, xSpaceId, pageObjectParams, _options).pipe(map((apiResponse: HttpInfo<ResponseDataPageInfoNodeRoleMemberVo>) => apiResponse.data));
    }

    /**
     * Get node roles
     * @param nodeId node id
     * @param xSpaceId space id
     * @param includeAdmin Whether to include the master administrator, can not be passed, the default includes
     * @param includeSelf Whether to get userself, do not pass, the default contains
     * @param includeExtend Contains superior inherited permissions. By default, it does not include
     */
    public listRole1WithHttpInfo(nodeId: string, xSpaceId: string, includeAdmin?: boolean, includeSelf?: boolean, includeExtend?: boolean, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeCollaboratorsVo>> {
        const requestContextPromise = this.requestFactory.listRole1(nodeId, xSpaceId, includeAdmin, includeSelf, includeExtend, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.listRole1WithHttpInfo(rsp)));
            }));
    }

    /**
     * Get node roles
     * @param nodeId node id
     * @param xSpaceId space id
     * @param includeAdmin Whether to include the master administrator, can not be passed, the default includes
     * @param includeSelf Whether to get userself, do not pass, the default contains
     * @param includeExtend Contains superior inherited permissions. By default, it does not include
     */
    public listRole1(nodeId: string, xSpaceId: string, includeAdmin?: boolean, includeSelf?: boolean, includeExtend?: boolean, _options?: Configuration): Observable<ResponseDataNodeCollaboratorsVo> {
        return this.listRole1WithHttpInfo(nodeId, xSpaceId, includeAdmin, includeSelf, includeExtend, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeCollaboratorsVo>) => apiResponse.data));
    }

}

import { WorkbenchNodeRubbishApiApiRequestFactory, WorkbenchNodeRubbishApiApiResponseProcessor} from "../apis/WorkbenchNodeRubbishApiApi";
export class ObservableWorkbenchNodeRubbishApiApi {
    private requestFactory: WorkbenchNodeRubbishApiApiRequestFactory;
    private responseProcessor: WorkbenchNodeRubbishApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchNodeRubbishApiApiRequestFactory,
        responseProcessor?: WorkbenchNodeRubbishApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchNodeRubbishApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchNodeRubbishApiApiResponseProcessor();
    }

    /**
     * Delete node in rubbish
     * @param nodeId node id
     * @param xSpaceId space id
     */
    public delete6WithHttpInfo(nodeId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete6(nodeId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete6WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete node in rubbish
     * @param nodeId node id
     * @param xSpaceId space id
     */
    public delete6(nodeId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete6WithHttpInfo(nodeId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Delete node in rubbish
     * @param nodeId node id
     * @param xSpaceId space id
     */
    public delete7WithHttpInfo(nodeId: string, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.delete7(nodeId, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.delete7WithHttpInfo(rsp)));
            }));
    }

    /**
     * Delete node in rubbish
     * @param nodeId node id
     * @param xSpaceId space id
     */
    public delete7(nodeId: string, xSpaceId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.delete7WithHttpInfo(nodeId, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * If the last node id is passed in, the service status code 422 is returned.It means that the node is no longer in the recovery compartment, the positioning fails, and the last node can be requested again.
     * Get node in rubbish
     * @param xSpaceId space id
     * @param size expected load quantity（May be because the total number or permissions are not enough）
     * @param isOverLimit whether to request an overrun node（default FALSE）
     * @param lastNodeId id of the last node in the loaded list
     */
    public list5WithHttpInfo(xSpaceId: string, size?: number, isOverLimit?: boolean, lastNodeId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataListRubbishNodeVo>> {
        const requestContextPromise = this.requestFactory.list5(xSpaceId, size, isOverLimit, lastNodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.list5WithHttpInfo(rsp)));
            }));
    }

    /**
     * If the last node id is passed in, the service status code 422 is returned.It means that the node is no longer in the recovery compartment, the positioning fails, and the last node can be requested again.
     * Get node in rubbish
     * @param xSpaceId space id
     * @param size expected load quantity（May be because the total number or permissions are not enough）
     * @param isOverLimit whether to request an overrun node（default FALSE）
     * @param lastNodeId id of the last node in the loaded list
     */
    public list5(xSpaceId: string, size?: number, isOverLimit?: boolean, lastNodeId?: string, _options?: Configuration): Observable<ResponseDataListRubbishNodeVo> {
        return this.list5WithHttpInfo(xSpaceId, size, isOverLimit, lastNodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataListRubbishNodeVo>) => apiResponse.data));
    }

    /**
     * Recover node
     * @param nodeRecoverRo
     * @param xSpaceId space id
     */
    public recoverWithHttpInfo(nodeRecoverRo: NodeRecoverRo, xSpaceId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeInfoVo>> {
        const requestContextPromise = this.requestFactory.recover(nodeRecoverRo, xSpaceId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.recoverWithHttpInfo(rsp)));
            }));
    }

    /**
     * Recover node
     * @param nodeRecoverRo
     * @param xSpaceId space id
     */
    public recover(nodeRecoverRo: NodeRecoverRo, xSpaceId: string, _options?: Configuration): Observable<ResponseDataNodeInfoVo> {
        return this.recoverWithHttpInfo(nodeRecoverRo, xSpaceId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeInfoVo>) => apiResponse.data));
    }

}

import { WorkbenchNodeShareApiApiRequestFactory, WorkbenchNodeShareApiApiResponseProcessor} from "../apis/WorkbenchNodeShareApiApi";
export class ObservableWorkbenchNodeShareApiApi {
    private requestFactory: WorkbenchNodeShareApiApiRequestFactory;
    private responseProcessor: WorkbenchNodeShareApiApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkbenchNodeShareApiApiRequestFactory,
        responseProcessor?: WorkbenchNodeShareApiApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new WorkbenchNodeShareApiApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new WorkbenchNodeShareApiApiResponseProcessor();
    }

    /**
     * Disable node sharing
     * @param nodeId node id
     */
    public disableShareWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataVoid>> {
        const requestContextPromise = this.requestFactory.disableShare(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.disableShareWithHttpInfo(rsp)));
            }));
    }

    /**
     * Disable node sharing
     * @param nodeId node id
     */
    public disableShare(nodeId: string, _options?: Configuration): Observable<ResponseDataVoid> {
        return this.disableShareWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataVoid>) => apiResponse.data));
    }

    /**
     * Get node share info
     * @param nodeId node id
     */
    public nodeShareInfoWithHttpInfo(nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeShareSettingInfoVO>> {
        const requestContextPromise = this.requestFactory.nodeShareInfo(nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.nodeShareInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * Get node share info
     * @param nodeId node id
     */
    public nodeShareInfo(nodeId: string, _options?: Configuration): Observable<ResponseDataNodeShareSettingInfoVO> {
        return this.nodeShareInfoWithHttpInfo(nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeShareSettingInfoVO>) => apiResponse.data));
    }

    /**
     * get shared content according to share id
     * Get share node info
     * @param shareId share id
     */
    public readShareInfoWithHttpInfo(shareId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataNodeShareInfoVO>> {
        const requestContextPromise = this.requestFactory.readShareInfo(shareId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.readShareInfoWithHttpInfo(rsp)));
            }));
    }

    /**
     * get shared content according to share id
     * Get share node info
     * @param shareId share id
     */
    public readShareInfo(shareId: string, _options?: Configuration): Observable<ResponseDataNodeShareInfoVO> {
        return this.readShareInfoWithHttpInfo(shareId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataNodeShareInfoVO>) => apiResponse.data));
    }

    /**
     * Sotre share data
     * @param storeShareNodeRo
     * @param xSocketId user socket id
     */
    public storeShareDataWithHttpInfo(storeShareNodeRo: StoreShareNodeRo, xSocketId?: string, _options?: Configuration): Observable<HttpInfo<ResponseDataStoreNodeInfoVO>> {
        const requestContextPromise = this.requestFactory.storeShareData(storeShareNodeRo, xSocketId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.storeShareDataWithHttpInfo(rsp)));
            }));
    }

    /**
     * Sotre share data
     * @param storeShareNodeRo
     * @param xSocketId user socket id
     */
    public storeShareData(storeShareNodeRo: StoreShareNodeRo, xSocketId?: string, _options?: Configuration): Observable<ResponseDataStoreNodeInfoVO> {
        return this.storeShareDataWithHttpInfo(storeShareNodeRo, xSocketId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataStoreNodeInfoVO>) => apiResponse.data));
    }

    /**
     * Update node share setting  stringObjectParams share setting parameter description: <br/> There are three option parameters for sharing settings. Only one can be set true, and more than two cannot be set to true at the same time.<br/>onlyRead: Bool, whether to set sharing only for others to view.<br/>canBeEdited: Bool, whether to set up sharing to others for collaborative editing.<br/>canBeStored: Bool, whether to set up sharing to others and save as a copy.<br/>Example: Set <Share Only for Others to View>, parameters:{\"onlyRead\": true}
     * Update node share setting
     * @param updateNodeShareSettingRo
     * @param nodeId node id
     */
    public updateNodeShareWithHttpInfo(updateNodeShareSettingRo: UpdateNodeShareSettingRo, nodeId: string, _options?: Configuration): Observable<HttpInfo<ResponseDataShareBaseInfoVo>> {
        const requestContextPromise = this.requestFactory.updateNodeShare(updateNodeShareSettingRo, nodeId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.updateNodeShareWithHttpInfo(rsp)));
            }));
    }

    /**
     * Update node share setting  stringObjectParams share setting parameter description: <br/> There are three option parameters for sharing settings. Only one can be set true, and more than two cannot be set to true at the same time.<br/>onlyRead: Bool, whether to set sharing only for others to view.<br/>canBeEdited: Bool, whether to set up sharing to others for collaborative editing.<br/>canBeStored: Bool, whether to set up sharing to others and save as a copy.<br/>Example: Set <Share Only for Others to View>, parameters:{\"onlyRead\": true}
     * Update node share setting
     * @param updateNodeShareSettingRo
     * @param nodeId node id
     */
    public updateNodeShare(updateNodeShareSettingRo: UpdateNodeShareSettingRo, nodeId: string, _options?: Configuration): Observable<ResponseDataShareBaseInfoVo> {
        return this.updateNodeShareWithHttpInfo(updateNodeShareSettingRo, nodeId, _options).pipe(map((apiResponse: HttpInfo<ResponseDataShareBaseInfoVo>) => apiResponse.data));
    }

}

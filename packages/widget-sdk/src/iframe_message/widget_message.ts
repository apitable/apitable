/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import {
  ICollaCommandExecuteResult, ICollaCommandOptions, IUnitInfo, IPageParams, ILabs, IShareInfo, IDatasheetMap, IViewRow, IMirrorMap,
  IUserInfo
} from 'core';
import { loadWidget, WidgetLoadError } from 'initialize_widget';
import { IDatasheetClient, IDatasheetMainSimple, IExpandRecordProps, IWidgetConfigIframe, IWidgetDashboardState } from 'interface';
import { IExpireCalcCachePayload } from 'store';
import {
  IResponse, WidgetMessageType, IMessage, IContentWindow, ISyncOperations, IConnectResponse, IInitResponse, MouseListenerType
} from './interface';
import { isSafeOrigin } from './utils';

type IWidgetListenEvents = {
  [key in WidgetMessageType]: (res: IResponse) => void;
};

class WidgetMessageBase {
  widgetId: string;
  /** As the window for sending messages */
  private contentWindow: IContentWindow | null = null;

  private listenEvents: IWidgetListenEvents | {} = {};

  constructor(widgetId: string) {
    this.widgetId = widgetId;
    window.addEventListener('message', (event: MessageEvent<IMessage>) => {
      const { origin, data } = event;
      if (!isSafeOrigin(origin)) {
        return;
      }
      const { type } = data;
      this.listenEvents[type]?.(data.response);
    }, false);
  }
  
  /**
   * Send a message.
   * @param type 
   * @param data 
   */
  emit(type: WidgetMessageType, data: IResponse) {
    if (!this.contentWindow) {
      return;
    }
    const { window: messageWindow, origin } = this.contentWindow;
    messageWindow && messageWindow.postMessage({
      response: data,
      type,
      targetId: this.widgetId
    }, origin);
  }

  on(type: WidgetMessageType, callback: (data: IResponse) => void) {
    this.listenEvents[type] = callback;
  }

  setContentWindow(contentWindow: IContentWindow) {
    this.contentWindow = contentWindow;
  }
}

class WidgetMessage extends WidgetMessageBase {
  connected = false;

  constructor(widgetId: string) {
    super(widgetId);
    this.on(WidgetMessageType.CONNECT_IFRAME, (res: IResponse<IConnectResponse>) => {
      if (res.data?.origin) {
        this.setContentWindow({
          origin: res.data?.origin,
          window: window.parent
        });
        this.connected = true;
        this.emit(WidgetMessageType.CONNECT_IFRAME, { success: true });
      }
    });
  }

  /**
   * The widget initializes and goes to the main application to get the data.
   */
  initWidget(): Promise<IInitResponse> {
    this.emit(WidgetMessageType.INIT_WIDGET, { success: true, data: this.widgetId });
    return new Promise((resolve, reject) => {
      this.on(WidgetMessageType.INIT_WIDGET, (res: IResponse<IInitResponse>) => {
        if (res.success && res.data) {
          resolve(res.data);
        } else {
          reject(res.message);
        }
      });
    });
  }

  /**
   * Listening to operations pushes from autonomous applications.
   * @param callback 
   */
  onSyncOperations(callback: (res: IResponse<ISyncOperations>) => void) {
    this.on(WidgetMessageType.SYNC_OPERATIONS, (res: IResponse<ISyncOperations>) => {
      return callback(res);
    });
  }

  /**
   * Listening for config update messages from the main application.
   * @param callback 
   */
  onSyncWidgetConfig(callback: (res: IResponse<IWidgetConfigIframe>) => void) {
    this.on(WidgetMessageType.SYNC_WIDGET_CONFIG, (config: IResponse<IWidgetConfigIframe>) => callback(config));
  }

  /**
   * @param callback 
   */
  onRefreshWidget(callback: (res: IResponse<string>) => void) {
    this.on(WidgetMessageType.REFRESH_WIDGET, (res: IResponse<string>) => callback(res));
  }

  onRefreshSnapshot(callback: (datasheetId: string) => void) {
    this.on(WidgetMessageType.REFRESH_SNAPSHOT, (res: IResponse<string>) => {
      if (res.success && res.data) {
        callback(res.data);
      }
    });
  }

  /**
   * Synchronize config data to the main application.
   */
  syncWidgetConfig(config: IWidgetConfigIframe) {
    this.emit(WidgetMessageType.SYNC_WIDGET_CONFIG, { success: true, data: config });
  }

  /**
   * The operation generated by synchronizing the collaboration data to the main application.
   */
  syncCmd(cmdOptions: ICollaCommandOptions): Promise<ICollaCommandExecuteResult<any>> {
    this.emit(WidgetMessageType.SYNC_COMMAND, { success: true, data: cmdOptions });
    return new Promise((resolve, reject) => {
      this.on(WidgetMessageType.SYNC_COMMAND_RESULT, (res: IResponse<ICollaCommandExecuteResult<any>>) => {
        if (res.success && res.data) {
          resolve(res.data);
          return;
        }
        reject(res.message);
      });
    });
  }

  /**
   * Listening to datasheet client update messages from the main application.
   */
  onSyncDatasheetClient(callback: (res: IDatasheetClient) => void) {
    this.on(WidgetMessageType.SYNC_DATASHEET_CLIENT, (res: IResponse<IDatasheetClient>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for unitInfo update messages from the main application.
   */
  onSyncUnitInfo(callback: (res: IUnitInfo) => void) {
    this.on(WidgetMessageType.SYNC_UNIT_INFO, (res: IResponse<IUnitInfo>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for pageParams update messages from the main application.
   */
  onSyncPageParams(callback: (res: IPageParams) => void) {
    this.on(WidgetMessageType.SYNC_PAGE_PARAMS, (res: IResponse<IPageParams>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for labs update messages from the main application.
   */
  onSyncLabs(callback: (res: ILabs) => void) {
    this.on(WidgetMessageType.SYNC_LABS, (res: IResponse<ILabs>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for share update messages from the main application.
   */
  onSyncShare(callback: (res: IShareInfo) => void) {
    this.on(WidgetMessageType.SYNC_SHARE, (res: IResponse<IShareInfo>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for dashboard-related data updates from the main application.
   * @param callback 
   */
  onSyncDashboard(callback: (dashboard: IWidgetDashboardState) => void) {
    this.on(WidgetMessageType.SYNC_DASHBOARD, (res: IResponse<IWidgetDashboardState>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for mirrorMap update messages from the main application.
   */
  onSyncMirrorMap(callback: (res: IMirrorMap) => void) {
    this.on(WidgetMessageType.SYNC_MIRROR, (res: IResponse<IMirrorMap>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Load other related table data, initialize for the first time.
   */
  loadOtherDatasheetInit(datasheetId: string) {
    this.emit(WidgetMessageType.LOAD_OTHER_DATASHEET_INIT, { success: true, data: datasheetId });
  }

  /**
   * Listening for initialization returns from other related table data.
   */
  onLoadOtherDatasheet(callback: (res: IDatasheetMap) => void) {
    this.on(WidgetMessageType.LOAD_OTHER_DATASHEET_INIT, res => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Listening for updates returned from other related table data (in addition to snapshot).
   */
  onDatasheetSimpleUpdate(callback: (res: {[datasheetId: string]: IDatasheetMainSimple}) => void) {
    this.on(WidgetMessageType.LOAD_OTHER_DATASHEET_UPDATE, res => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Trigger expandRecord.
   */
  expandRecord(expandRecordParams: IExpandRecordProps) {
    this.emit(WidgetMessageType.EXPAND_RECORD, { success: true, data: expandRecordParams });
  }

  /**
   * Mouse in and mouse out widgets iframe.
   */
  mouseListener(type: MouseListenerType) {
    this.emit(WidgetMessageType.MOUSE_EVENT, { success: true, data: type });
  }

  /**
   * Listening for cache updates from the main application.
   */
  onSyncCalcCache(callback: (res: { datasheetId: string, viewId: string, cache: IViewRow[]}) => void) {
    this.on(WidgetMessageType.CALC_CACHE, res => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }

  /**
   * Initializing the view calculation cache.
   * @param datasheetId 
   * @param viewId 
   */
  initCache(datasheetId: string, viewId: string) {
    this.emit(WidgetMessageType.CALC_CACHE, { success: true, data: { datasheetId, viewId }});
  }

  /**
   * Expand to enter the developer mode pop-up window.
   */
  expandDevConfig() {
    this.emit(WidgetMessageType.EXPAND_DEV_CONFIG, { success: true });
  }

  /**
   * Send loading widget results
   * @param widgetId 
   * @param devUrl 
   * @param widgetPackageId 
   * @param refresh 
   */
  sendLoadWidget(error?: WidgetLoadError) {
    this.emit(WidgetMessageType.LOAD_WIDGET_RESULT, { success: true, data: error });
  }

  /**
   * Listening to loading widget.
   * @param callback 
   */
  onLoadWidget() {
    this.on(WidgetMessageType.LOAD_WIDGET,
      (res: IResponse<{ devUrl: string, widgetPackageId: string, refresh?: boolean }>) => {
        if (res.success && res.data) {
          const { devUrl, widgetPackageId, refresh } = res.data;
          loadWidget(devUrl, widgetPackageId, refresh).then(() => {
            this.sendLoadWidget();
          }).catch(error => this.sendLoadWidget(error));
        }
      }
    );
  }

  /**
   * Listening for marker cache expiration.
   * @param callback 
   */
  onCalcExpire(callback: (params: IExpireCalcCachePayload) => void) {
    this.on(WidgetMessageType.CALC_EXPIRE, (res: IResponse<IExpireCalcCachePayload>) => {
      if (res.success && res.data) {
        callback(res.data);
      } else {
        console.log(res.message);
      }
    });
  }

  /**
   * Listening for synchronize data related to the main application userInfo
   * @param userInfo
   */
  onSyncUserInfo(callback: (res: IUserInfo) => void) {
    this.on(WidgetMessageType.SYNC_USER_INFO, (res: IResponse<IUserInfo>) => {
      if (res.success && res.data) {
        callback(res.data);
        return;
      }
      console.error(res.message);
    });
  }
}

export let widgetMessage: WidgetMessage;

export const initWidgetMessage = (widgetId: string) => {
  if (widgetMessage) {
    console.log('Do not repeat the initialization of widgetMessage.');
    return widgetMessage;
  }
  widgetMessage = new WidgetMessage(widgetId);
  return widgetMessage;
};